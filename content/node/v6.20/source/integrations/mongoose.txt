.. _node-mongoose:

=======================
Integrate with Mongoose
=======================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference

.. meta::
   :description: Learn about Mongoose, an Object Data Modeling (ODM) library for MongoDB, and how it compares to the MongoDB Node.js driver.
   :keywords: mongoose, odm, schema, validation, node.js

.. toctree::
   :titlesonly:
   :maxdepth: 1

   Mongoose Get Started </integrations/mongoose/mongoose-get-started>

Overview
--------

`Mongoose <https://mongoosejs.com/>`__ is a Node.js-based Object Data Modeling
(ODM) library that provides schema-based data modeling, validation, query
building, and business logic hooks.

An ODM is similar to Object Relational Mapper (ORM) used with
traditional SQL databases, but designed specifically for MongoDB's
document-based data model.

.. tip:: Mongoose Compatibility

   To learn about Mongoose compatibility with different MongoDB server versions,
   see the `Mongoose Compatibility <https://mongoosejs.com/docs/compatibility.html>`__
   page in the Mongoose documentation.

What is Object Data Modeling?
------------------------------

Object Data Modeling (ODM) creates a structured relationship
between your application code and your database documents. With an
ODM such as Mongoose, you define schemas at the application level
that map to MongoDB collections and enforce structure on the
documents within those collections.

MongoDB provides a flexible data model that allows you to modify your database
schema as your application evolves. However, your use case might require
consistency in your data structure across documents in a collection.

Mongoose addresses this need for consistency by providing the following features:

- Define the structure and data types for your documents
- Generate models from schemas to interact with collections
- Enforce data validation rules at the application level
- Execute custom logic before or after database operations
- Construct and execute database queries with a fluent API
- Reference documents from other collections (similar to joins)

Schema Enforcement
~~~~~~~~~~~~~~~~~~

Mongoose enforces schemas at the application level. You define a
schema that specifies the structure of documents in a collection,
including field names, data types, and validation rules. Mongoose
validates data against this schema before performing database
operations.

The schema and validation rules exist only in your Node.js
application code. The MongoDB server itself remains unaware of these
constraints and accepts any valid BSON document that your
application sends.

Data Modeling
~~~~~~~~~~~~~

Mongoose requires you to define schemas and models before
interacting with your collections. This structured approach might be
familiar to developers with experience in relational databases or
other ORMs.

The trade-off is reduced flexibility. When you need to modify your
data structure, you must update your Mongoose schemas.

Schema Validation
-----------------

Mongoose validates data in two ways. First, by defining field types in your
schema, you specify what data types each field allows. Mongoose rejects
operations that attempt to insert data that does not match the defined types.

Second, you can add specific validation rules such as required
fields, minimum or maximum values, string length constraints, or
custom validation functions.

These validation rules only apply when you use Mongoose in your
Node.js application. Other applications or database tools can
bypass these rules because they exist only in your application
code.

For more information on validating data by using the {+driver-long+} together
with MongoDB's built-in schema validation, see the :manual:`MongoDB Schema Validation </core/schema-validation/>` guide in the Server manual.

Working with Multiple Collections
----------------------------------

Both Mongoose and the {+driver-long+} support combining
documents from multiple collections, similar to joins in
relational databases.

Populate in Mongoose
~~~~~~~~~~~~~~~~~~~~

Mongoose provides the ``populate()`` method to reference documents from other
collections. You define references in your schema by specifying which collection
they reference. ``ObjectId`` is a common type to use for references, but Mongoose also
supports the use of other types such as strings, numbers, UUIDs, and buffers. When
querying, Mongoose can automatically replace these references with the actual
documents.

Mongoose performs populate operations by executing multiple queries. This
approach can be beneficial in certain scenarios, such as when working with large
scans or when indexes are missing.

$lookup in MongoDB
~~~~~~~~~~~~~~~~~~

MongoDB provides the ``$lookup`` aggregation stage for performing an action
similar to left outer joins between collections in the same database. The
{+driver-long+} gives you direct access to this feature through aggregation
pipelines.

The ``$lookup`` operator runs as a single aggregation pipeline operation. This
approach can offer performance benefits in some cases, but the actual
performance depends on factors such as your data size, available indexes, and
query patterns.

Get Started with Mongoose
--------------------------

To learn how to install Mongoose, connect to MongoDB, and perform
CRUD operations by using Mongoose schemas and models, see the
:ref:`Mongoose Get Started <node-mongoose-get-started>` tutorial.

Additional Resources
--------------------

- `Mongoose Documentation <https://mongoosejs.com/docs/guide.html>`__
- `Mongoose API Reference <https://mongoosejs.com/docs/api/mongoose.html>`__
- `Mongoose Compatibility <https://mongoosejs.com/docs/compatibility.html>`__
- :manual:`MongoDB Schema Validation </core/schema-validation/>`
- :manual:`$lookup Aggregation Stage </reference/operator/aggregation/lookup/>`
- :ref:`node-aggregation`
