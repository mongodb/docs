=========================
db.collection.updateOne()
=========================

.. default-domain:: mongodb

.. role:: red(strong)
   :class: text-danger

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. method:: db.collection.updateOne(filter, update, options)

   .. versionadded:: 3.2

   Updates a single document within the collection based on the filter.

Syntax
------

The :method:`~db.collection.updateOne()` method has the following syntax:

.. code-block:: javascript

   db.collection.updateOne(
      <filter>,
      <update>,
      {
        upsert: <boolean>,
        writeConcern: <document>,
        collation: <document>,
        arrayFilters: [ <filterdocument1>, ... ]
      }
   )

Parameters
~~~~~~~~~~

The :method:`db.collection.updateOne()` method takes the following
parameters:

.. list-table::
   :header-rows: 1
   :widths: 20 20 80

   * - Parameter

     - Type

     - Description

   * - :ref:`filter <updateOne-filter>`

     - document

     - .. _updateOne-filter:
     
       The selection criteria for the update. The same :ref:`query
       selectors <query-selectors>` as in the :method:`find()
       <db.collection.find()>` method are available.
       
       Specify an empty document ``{ }`` to update the first document returned in 
       the collection.

   * - ``update``

     - document

     - The modifications to apply.
       
       The value can be either:
       
       - A document that contains :ref:`update operator expressions
         <update-operators>`, or
       
       - Starting in MongoDB 4.2, an aggregation pipeline. The pipeline can
         consist of the following stages:
       
         .. include:: /includes/list-update-agg-stages.rst
       
       For more information on the update modification parameter, see
       :ref:`updateOne-behavior-update-expressions` and
       :ref:`updateOne-behavior-aggregation-pipeline`.
       
       To update with a replacement document, see
       :method:`db.collection.replaceOne()`.

   * - ``upsert``

     - boolean

     - .. include:: /includes/extracts/updateOne-behavior-method.rst

   * - ``writeConcern``

     - document

     - Optional. A document expressing the :doc:`write concern
       </reference/write-concern>`. Omit to use the default write concern.
       
       .. include:: /includes/extracts/transactions-operations-write-concern.rst

   * - ``collation``

     - document

     - Optional. 
       
       .. include:: /includes/extracts/collation-option.rst

   * - ``arrayFilters``

     - array

     - Optional. An array of filter documents that determine which array elements to
       modify for an update operation on an array field.
       
       .. include::  /includes/extracts/arrayFilters-details.rst

       For examples, see :ref:`updateOne-arrayFilters`.
       
       .. versionadded:: 3.6

Returns
~~~~~~~

The method returns a document that contains:

- ``matchedCount`` containing the number of matched documents

- ``modifiedCount`` containing the number of modified documents

- ``upsertedId`` containing the ``_id`` for the upserted document.

- A boolean ``acknowledged`` as ``true`` if the operation ran with
  :term:`write concern` or ``false`` if write concern was disabled

Access Control
--------------

On deployments running with :setting:`~security.authorization`, the
user must have access that includes the following privileges:

- :authaction:`update` action on the specified collection(s).

- :authaction:`find` action on the specified collection(s).

- :authaction:`insert` action on the specified collection(s) if the
  operation results in an upsert.

The built-in role :authrole:`readWrite` provides the required
privileges.

.. _updateOne-behavior:

Behavior
--------

Updates a Single Document
~~~~~~~~~~~~~~~~~~~~~~~~~

:method:`db.collection.updateOne()` updates the first matching document in 
the collection that matches the ``filter``, using the ``update`` instructions 
to apply modifications.

.. _updateOne-behavior-update-expressions:

Update with an Update Operator Expressions Document
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the modification specification, the
:method:`db.collection.updateOne()` method can accept a document that
only contains :ref:`update operator <update-operators>` expressions to
perform.

For example:

.. code-block:: javascript
   :emphasize-lines: 3
   :copyable: false

   db.collection.updateOne( 
      <query>,
      { $set: { status: "D" }, $inc: { quantity: 2 } },
      ...
   )

.. _updateOne-behavior-aggregation-pipeline:

Update with an Aggregation Pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting in MongoDB 4.2, the :method:`db.collection.updateOne()` method
can accept an :doc:`aggregation pipeline
</core/aggregation-pipeline>` ``[ <stage1>, <stage2>, ... ]`` that
specifies the modifications to perform. The pipeline can consist of
the following stages:

.. include:: /includes/list-update-agg-stages.rst

Using the aggregation pipeline allows for a more expressive update
statement, such as expressing conditional updates based on current
field values or updating one field using the value of another field(s).

For example:

.. code-block:: javascript
   :emphasize-lines: 3-6
   :copyable: false

   db.collection.updateOne( 
      <query>,
      [ 
         { $set: { status: "Modified", comments: [ "$misc1", "$misc2" ] } }, 
         { $unset: [ "misc1", "misc2" ] } 
      ]
      ...
   )

.. note::

   The ``$set`` and ``$unset`` used in the pipeline refers to the
   aggregation stages :pipeline:`$set` and :pipeline:`$unset`
   respectively, and not the update operators :update:`$set` and :update:`$unset`.

For examples, see :ref:`updateOne-example-agg`.

Upsert
~~~~~~

If ``upsert: true`` and no documents match the ``filter``, 
:method:`db.collection.updateOne()` creates a new 
document based on the ``filter`` criteria and ``update`` modifications. See 
:ref:`updateOne-example-update-with-upsert`.

If you specify ``upsert: true`` on a sharded collection, you must
include the full shard key in the :ref:`filter <updateOne-filter>`. For
additional :method:`db.collection.updateOne()` behavior on a sharded
collection, see :ref:`updateOne-sharded-collection`.

.. _updateOne-capped-collection:

Capped Collection
~~~~~~~~~~~~~~~~~

.. include:: /includes/extracts/capped-collection-immutable-document-size-update.rst

.. _updateOne-sharded-collection:

Sharded Collections
~~~~~~~~~~~~~~~~~~~

To use :method:`db.collection.updateOne()` on a sharded collection:

- If you don't specify ``upsert: true``, you must include an exact
  match on the ``_id`` field or target a single shard (such as by
  including the shard key in the :ref:`filter <updateOne-filter>`).

- If you specify ``upsert: true``, the :ref:`filter <updateOne-filter>`
  must include the shard key.

Shard Key Modification
``````````````````````

.. include:: /includes/limits-sharding-shardkey-document-immutable.rst

To use :method:`db.collection.updateOne()` to update the shard key:

.. include:: /includes/shard-key-modification-requirements.rst


Explainability
~~~~~~~~~~~~~~

.. |write-method| replace:: :method:`~db.collection.updateOne()`
.. |old-write-method| replace:: :method:`~db.collection.update()`

.. include:: /includes/fact-bulkwrite-explainable.rst

Transactions
~~~~~~~~~~~~

.. include:: /includes/extracts/transactions-supported-operation.rst

.. include:: /includes/extracts/transactions-usage.rst

Existing Collections and Transactions
`````````````````````````````````````

Inside a transaction, you can specify read/write operations on existing
collections. If the |operation| results in an
upsert, the collection must already exist.

Write Concerns and Transactions
````````````````````````````````

.. include:: /includes/extracts/transactions-operations-write-concern.rst

.. |operation| replace:: :method:`db.collection.updateOne()`

.. _updateOne-method-examples:

Examples
--------

.. _updateOne-example-update:

Update using Update Operator Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``restaurant`` collection contains the  following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Central Perk Cafe", "Borough" : "Manhattan" },
   { "_id" : 2, "name" : "Rock A Feller Bar and Grill", "Borough" : "Queens", "violations" : 2 },
   { "_id" : 3, "name" : "Empire State Pub", "Borough" : "Brooklyn", "violations" : 0 }

The following operation updates a single document where 
``name: "Central Perk Cafe"`` with the ``violations`` field:

.. code-block:: javascript

   try {
      db.restaurant.updateOne( 
         { "name" : "Central Perk Cafe" }, 
         { $set: { "violations" : 3 } } 
      );
   } catch (e) {
      print(e);
   }
  
The operation returns:

.. code-block:: javascript

   { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

If no matches were found, the operation instead returns:

.. code-block:: javascript

   { "acknowledged" : true, "matchedCount" : 0, "modifiedCount" : 0 }

Setting ``upsert: true`` would insert the document if no match was found. See 
:ref:`updateOne-example-update-with-upsert`

.. _updateOne-example-agg:

Update with Aggregation Pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting in MongoDB 4.2, the :method:`db.collection.updateOne()` can use
an aggregation pipeline for the update. The pipeline can consist of the
following stages:

.. include:: /includes/list-update-agg-stages.rst

Using the aggregation pipeline allows for a more expressive update
statement, such as expressing conditional updates based on current
field values or updating one field using the value of another field(s).

Example 1
`````````

The following examples uses the aggregation pipeline to modify a field
using the values of the other fields in the document.

Create a ``members`` collection with the following documents:

.. code-block:: javascript

   db.members.insertMany([
      { "_id" : 1, "member" : "abc123", "status" : "A", "points" : 2, "misc1" : "note to self: confirm status", "misc2" : "Need to activate" },
      { "_id" : 2, "member" : "xyz123", "status" : "A", "points" : 60, comments: [ "reminder: ping me at 100pts", "Some random comment" ] }
   ])

Assume that instead of separate ``misc1`` and ``misc2`` fields in the
first document, you want to gather these into a ``comments`` field,
like the second document. The following update operation uses an
aggregation pipeline to add the new ``comments`` field and remove the
``misc1`` and ``misc2`` fields for the specified document.

.. code-block:: javascript

   db.members.updateOne(
      { _id: 1 },
      [
         { $set: { status: "Modified", comments: [ "$misc1", "$misc2" ] } },
         { $unset: [ "misc1", "misc2" ] }
      ]
   )

.. note::

   The ``$set`` and ``$unset`` used in the pipeline refers to the
   aggregation stages :pipeline:`$set` and :pipeline:`$unset`
   respectively, and not the update operators :update:`$set` and :update:`$unset`.

First Stage
   The :pipeline:`$set` stage creates a new array field ``comments``
   whose elements are the current content of the ``misc1`` and
   ``misc2`` fields.

Second Stage
   The :pipeline:`$unset` stage removes the ``misc1`` and ``misc2`` fields.

After the command, the collection contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "member" : "abc123", "status" : "Modified", "points" : 2, "comments" : [ "note to self: confirm status", "Need to activate" ] }
   { "_id" : 2, "member" : "xyz123", "status" : "A", "points" : 60, "comments" : [ "reminder: ping me at 100pts", "Some random comment" ] }

Example 2
`````````

The aggregation pipeline allows the update to perform conditional
updates based on the current field values as well as use current field
values to calculate a separate field value.

For example, create a ``students3`` collection with the following documents:

.. code-block:: javascript

   db.students3.insert([
      { "_id" : 1, "tests" : [ 95, 92, 90 ], "average" : 92.33333333333333, "grade" : "A"  },
      { "_id" : 2, "tests" : [ 94, 88, 90 ], "average" : 90.66666666666667, "grade" : "A" },
      { "_id" : 3, "tests" : [ 70, 75, 82 ] }
   ]);

The third document ``_id: 3`` is missing the ``average`` and ``grade``
fields. Using an aggregation pipeline, you can update the document with
the calculated grade average and letter grade.

.. code-block:: javascript

   db.students3.updateOne(
      { _id: 3 },
      [
        { $set: { average : { $avg: "$tests" } } },
        { $set: { grade: { $switch: {
                              branches: [
                                  { case: { $gte: [ "$average", 90 ] }, then: "A" },
                                  { case: { $gte: [ "$average", 80 ] }, then: "B" },
                                  { case: { $gte: [ "$average", 70 ] }, then: "C" },
                                  { case: { $gte: [ "$average", 60 ] }, then: "D" }
                              ],
                              default: "F"
        } } } }
      ]
   )

.. note::

   The ``$set`` used in the pipeline refers to the aggregation stage
   :pipeline:`$set`, and not the update operators :update:`$set`.

First Stage
   The :pipeline:`$set` stage calculates a new field ``average`` based
   on the average of the ``tests`` field. See :group:`$avg` for
   more information on the ``$avg`` aggregation operator.

Second Stage
   The :pipeline:`$set` stage calculates a new field ``grade`` based on
   the ``average`` field calculated in the previous stage. See
   :expression:`$switch` for more information on the ``$switch``
   aggregation operator.

After the command, the collection contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "tests" : [ 95, 92, 90 ], "average" : 92.33333333333333, "grade" : "A" }
   { "_id" : 2, "tests" : [ 94, 88, 90 ], "average" : 90.66666666666667, "grade" : "A" }
   { "_id" : 3, "tests" : [ 70, 75, 82 ], "average" : 75.66666666666667, "grade" : "C" }

.. _updateOne-example-update-with-upsert:

Update with Upsert
~~~~~~~~~~~~~~~~~~

The ``restaurant`` collection contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Central Perk Cafe", "Borough" : "Manhattan", "violations" : 3 },
   { "_id" : 2, "name" : "Rock A Feller Bar and Grill", "Borough" : "Queens", "violations" : 2 },
   { "_id" : 3, "name" : "Empire State Pub", "Borough" : "Brooklyn", "violations" : "0" }

The following operation attempts to update the document with 
``name : "Pizza Rat's Pizzaria"``, while ``upsert: true`` :

.. code-block:: javascript

   try {
      db.restaurant.updateOne( 
         { "name" : "Pizza Rat's Pizzaria" },
         { $set: {"_id" : 4, "violations" : 7, "borough" : "Manhattan" } }, 
         { upsert: true }
      );
   } catch (e) {
      print(e);
   }

Since ``upsert:true`` the document is ``inserted`` based on the ``filter`` and 
``update`` criteria. The operation returns:

.. code-block:: javascript

   {
      "acknowledged" : true,
      "matchedCount" : 0,
      "modifiedCount" : 0,
      "upsertedId" : 4
   }

The collection now contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Central Perk Cafe", "Borough" : "Manhattan", "violations" : 3 },
   { "_id" : 2, "name" : "Rock A Feller Bar and Grill", "Borough" : "Queens", "violations" : 2 },
   { "_id" : 3, "name" : "Empire State Pub", "Borough" : "Brooklyn", "violations" : 4 },
   { "_id" : 4, "name" : "Pizza Rat's Pizzaria", "Borough" : "Manhattan", "violations" : 7 }

The ``name`` field was filled in using the ``filter`` criteria, while the 
``update`` operators were used to create the rest of the document.

The following operation updates the first document with ``violations`` that 
are greater than ``10``:

.. code-block:: javascript

   try {
      db.restaurant.updateOne( 
         { "violations" : { $gt: 10} }, 
         { $set: { "Closed" : true } }, 
         { upsert: true }
      );
   } catch (e) {
      print(e);
   }

The operation returns:

.. code-block:: javascript

   {
      "acknowledged" : true,
      "matchedCount" : 0,
      "modifiedCount" : 0,
      "upsertedId" : ObjectId("56310c3c0c5cbb6031cafaea")
   }

The collection now contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Central Perk Cafe", "Borough" : "Manhattan", "violations" : 3 },
   { "_id" : 2, "name" : "Rock A Feller Bar and Grill", "Borough" : "Queens", "violations" : 2 },
   { "_id" : 3, "name" : "Empire State Pub", "Borough" : "Brooklyn", "violations" : 4 },
   { "_id" : 4, "name" : "Pizza Rat's Pizzaria", "Borough" : "Manhattan", "grade" : 7 }
   { "_id" : ObjectId("56310c3c0c5cbb6031cafaea"), "Closed" : true }

Since no documents matched the filter, and ``upsert`` was ``true``, 
:method:`~db.collection.updateOne` inserted the document with a generated 
``_id`` and the ``update`` criteria only.

.. _updateOne-example-update-with-write-concern:

Update with Write Concern
~~~~~~~~~~~~~~~~~~~~~~~~~

Given a three member replica set, the following operation specifies a 
``w`` of ``majority``, ``wtimeout`` of ``100``:

.. code-block:: javascript

   try {
      db.restaurant.updateOne(
          { "name" : "Pizza Rat's Pizzaria" },
          { $inc: { "violations" : 3}, $set: { "Closed" : true } },
          { w: "majority", wtimeout: 100 }
      );
   } catch (e) {
      print(e);
   }

If the primary and at least one secondary acknowledge each write operation 
within 100 milliseconds, it returns:

.. code-block:: javascript

   { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

If the acknowledgement takes longer than the ``wtimeout`` limit, the following 
exception is thrown:

.. code-block:: javascript

   WriteConcernError({
      "code" : 64,
      "errInfo" : {
         "wtimeout" : true
      },
      "errmsg" : "waiting for replication timed out"
   }) :

Specify Collation
~~~~~~~~~~~~~~~~~

.. include:: /includes/extracts/collation-versionadded.rst

A collection ``myColl`` has the following documents:

.. code-block:: javascript

   { _id: 1, category: "caf√©", status: "A" }
   { _id: 2, category: "cafe", status: "a" }
   { _id: 3, category: "cafE", status: "a" }

The following operation includes the :ref:`collation <collation>`
option:

.. code-block:: javascript

   db.myColl.updateOne(
      { category: "cafe" },
      { $set: { status: "Updated" } },
      { collation: { locale: "fr", strength: 1 } }
   );

.. _updateOne-arrayFilters:

Specify ``arrayFilters`` for an Array Update Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: /includes/extracts/arrayFilters-blurb.rst

Update Elements Match ``arrayFilters`` Criteria
```````````````````````````````````````````````

Create a collection ``students`` with the following documents:

.. code-block:: javascript

   db.students.insert([
      { "_id" : 1, "grades" : [ 95, 92, 90 ] },
      { "_id" : 2, "grades" : [ 98, 100, 102 ] },
      { "_id" : 3, "grades" : [ 95, 110, 100 ] }
   ])

To modify all elements that are greater than or equal to ``100`` in the
``grades`` array, use the filtered positional operator
:update:`$[\<identifier\>]` with the ``arrayFilters`` option in the
:method:`db.collection.updateOne` method:

.. code-block:: javascript

   db.students.updateOne(
      { grades: { $gte: 100 } },
      { $set: { "grades.$[element]" : 100 } },
      { arrayFilters: [ { "element": { $gte: 100 } } ] }
   )

The operation updates the ``grades`` field of a single document, and
after the operation, the collection has the following documents:

.. code-block:: javascript
   :emphasize-lines: 2

   { "_id" : 1, "grades" : [ 95, 92, 90 ] }
   { "_id" : 2, "grades" : [ 98, 100, 100 ] }
   { "_id" : 3, "grades" : [ 95, 110, 100 ] }

Update Specific Elements of an Array of Documents
`````````````````````````````````````````````````

Create a collection ``students2`` with the following documents:

.. code-block:: javascript

   db.students2.insert([
      {
         "_id" : 1,
         "grades" : [
            { "grade" : 80, "mean" : 75, "std" : 6 },
            { "grade" : 85, "mean" : 90, "std" : 4 },
            { "grade" : 85, "mean" : 85, "std" : 6 }
         ]
      },
      {
         "_id" : 2,
         "grades" : [
            { "grade" : 90, "mean" : 75, "std" : 6 },
            { "grade" : 87, "mean" : 90, "std" : 3 },
            { "grade" : 85, "mean" : 85, "std" : 4 }
         ]
      }
   ])

To modify the value of the ``mean`` field for all elements in the
``grades`` array where the grade is greater than or equal to ``85``,
use the filtered positional operator :update:`$[\<identifier\>]` with
the ``arrayFilters`` in the :method:`db.collection.updateOne` method:

.. code-block:: javascript

   db.students2.updateOne(
      { },
      { $set: { "grades.$[elem].mean" : 100 } },
      { arrayFilters: [ { "elem.grade": { $gte: 85 } } ] }
   )

The operation updates the array of a single document, and after the
operation, the collection has the following documents:

.. code-block:: javascript
   :emphasize-lines: 5-6

   {
      "_id" : 1,
      "grades" : [
         { "grade" : 80, "mean" : 75, "std" : 6 },
         { "grade" : 85, "mean" : 100, "std" : 4 },
         { "grade" : 85, "mean" : 100, "std" : 6 } 
       ]
   }
   {
      "_id" : 2,
      "grades" : [
         { "grade" : 90, "mean" : 75, "std" : 6 },
         { "grade" : 87, "mean" : 90, "std" : 3 },
         { "grade" : 85, "mean" : 85, "std" : 4 }
      ]
   }

.. seealso:: To update multiple documents, see
   :method:`db.collection.updateMany()`.
