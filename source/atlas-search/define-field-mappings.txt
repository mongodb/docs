.. _fts-field-mappings:

=====================
Define Field Mappings
=====================

.. default-domain:: mongodb

.. meta::
   :keywords: atlas search, define a static mapping, define a dynamic mapping, index a field, index multiple fields, index an array, array of fields, atlas search supported data types, atlas search field types, index definition example, static mapping example, static and dynamic mapping example, combined mapping example
   :description: Learn how to include specific fields in your search index or how to configure Atlas Search to automatically include all supported field types.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

When you create an |fts| index, you can:

- Specify the fields to index using static mappings. 
- Configure |fts| to automatically index all supported field types using
  dynamic mappings. 

To use static mappings, you must explicitly include the fields in the
collection that you want to index. In the ``type`` field, specify the 
:ref:`data type <bson-data-chart>` of the field in the field 
definition. Alternatively, you can specify an array of field definitions
for a field, one for each data type.

.. code-block:: json  
   :caption: Syntax 
   :emphasize-lines: 3-12
   :linenos:

   "mappings": { 
     "dynamic": <boolean>, 
     "fields": { 
       "<field-name>": [
         {
           "type": "<field-type>",
           ...
         },
         ...
       ],
       ...  
     }
   }

.. include:: /includes/fact-fts-index-field-order.rst 

.. _static-dynamic-mappings:

Static and Dynamic Mappings 
---------------------------

You can use static and dynamic mappings to specify whether |fts| must
automatically index all the dynamically indexable fields in your
collection.

Static Mappings 
~~~~~~~~~~~~~~~

Use static mappings to configure index options for fields that
you *don't* want indexed dynamically, or to configure a single field 
independently from others in an index.

For static mappings, set ``mappings.dynamic`` to ``false`` and 
specify the fields to index using ``mappings.fields``. |fts| 
indexes only the specified fields with specific options. 

Dynamic Mappings 
~~~~~~~~~~~~~~~~

Use dynamic mappings if your schema changes regularly or is unknown, or 
when experimenting with |fts|. You can configure an entire index to use 
dynamic mappings, or specify individual fields, such as fields of type 
``document``, to be dynamically mapped. Before using dynamic mappings,
see the table for :ref:`bson-data-chart`. 

For dynamic mappings, set ``mappings.dynamic`` to ``true``. |fts| 
automatically indexes the fields of :ref:`supported types 
<bson-data-chart>` in each document. For fields of type 
:ref:`string <bson-data-types-string>`, |fts| stores the fields on ``mongot``.

.. note::

   Dynamically mapped indexes occupy more disk space than statically 
   mapped indexes and may be less performant.

.. _bson-data-chart:
.. _bson-data-types:

Data Types
----------

|fts| doesn't support the following :manual:`BSON data types 
</reference/bson-types/>`\:

- Binary Data
- Decimal128
- JavaScript code with scope
- Max key
- Min key
- Null
- Regular Expression
- Timestamp

The following table enumerates the supported :manual:`BSON data types
</reference/bson-types/>` and the :ref:`Atlas Search field
types<bson-data-types>` that you can use to index the BSON data types.
The table also indicates whether the |fts| field type is automatically
included in an |fts| index when you enable :ref:`dynamic mappings
<static-dynamic-mappings>`. 

.. list-table::
   :header-rows: 1

   * - BSON Type
     - Atlas Search Field Type
     - Dynamically Indexed

   * - :ref:`Array <fts-array-ref>`
     - ``boolean``, ``date``, ``number``, ``objectId``, ``string`` 
     - ✓ :icon-fa5:`star`

   * - Boolean
     - :ref:`boolean <boolean-ref>`
     - ✓

   * - Date
     - :ref:`date <bson-data-types-date>`
     - ✓ 

   * - Date
     - :ref:`dateFacet <bson-data-types-date-facet>`
     - 

   * - Double
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - Double
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - Double
     - :ref:`knnVector <fts-data-types-knn-vector>` (Preview feature)
     - 

   * - :manual:`GeoJSON Object </reference/geojson/>`
     - :ref:`geo <bson-data-types-geo>`
     - 

   * - 32-bit integer
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - 32-bit integer
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - 64-bit integer
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - 64-bit integer
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - Object
     - :ref:`document <bson-data-types-document>`
     - ✓ 

   * - Object
     - :ref:`embeddedDocuments <bson-data-types-embedded-documents>` 
       (for array of objects)
     - 

   * - ObjectId
     - :ref:`objectId <objectId-ref>`
     - ✓

   * - String 
     - :ref:`string <bson-data-types-string>`
     - ✓ 

   * - String 
     - :ref:`stringFacet <bson-data-types-string-facet>`
     - 

   * - String 
     - :ref:`autocomplete <bson-data-types-autocomplete>`
     - 

   * - String 
     - :ref:`token <bson-data-types-token>` 
     - 

:icon-fa5:`star` Some limitations apply. To learn more, see
:ref:`fts-array-ref`. 

.. note:: 

   You can store fields of all supported :ref:`data types 
   <bson-data-chart>` on |fts| using the ``storedSource`` :ref:`option 
   <index-definition-options>`.

.. _bson-data-types-limitations:

Limitations
~~~~~~~~~~~

|fts| doesn't support indexing more than two billion index objects,
where each indexed document counts as a single object. If you plan to
index fields that might exceed this limit, you must  
:ref:`shard your cluster <create-cluster-sharding>`. If you use the 
:ref:`embeddedDocuments <bson-data-types-embedded-documents>` field
type, |fts| might index objects over this limit.

.. _bson-data-types-indexing:

Index Field as Multiple Data Types 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To index a field as multiple types, define the types in the field 
definition array for the field.  

.. example:: 
   
   The following example shows the field definition for indexing a 
   field as multiple types.

   .. code-block:: json
      :copyable: false 
      :linenos:
      :emphasize-lines: 6-16

      {
        ...
        "mappings": { 
          "dynamic": <boolean>, 
          "fields": { 
            "<field-name>": [
              {
                "type": "<field-type>",
                ...
              },
              {
                "type": "<field-type>",
                ...
              },
              ...
            ],
            ...  
          },
          ... 
        }
      }

.. _index-config-example:

Examples
--------

Static Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~

The following index definition example uses static mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that are not explicitly 
  mentioned are not indexed. So, the index definition includes:

  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``.
    
    The ``city`` sub-field uses the :ref:`lucene.simple
    <ref-simple-analyzer>` analyzer by default for queries.
    It uses the ``ignoreAbove`` option to ignore any string of
    more than 255 bytes in length.
    
    The ``state`` sub-field uses the :ref:`lucene.english
    <ref-language-analyzers>` analyzer by default for queries.

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries.

    To learn more about ``multi`` analyzers, see :ref:`Path 
    Construction <ref-path>`.

  - The ``employees`` field, which is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. For indexing arrays, |fts| 
    only requires the data type of the array elements. You don't 
    have to specify that the data is contained in an array in the 
    index definition.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "address": {
           "type": "document",
           "fields": {
             "city": {
               "type": "string",
               "analyzer": "lucene.simple",
               "ignoreAbove": 255
             },
             "state": {
               "type": "string",
               "analyzer": "lucene.english"
             }
           }
         },
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string", 
           "analyzer": "lucene.standard"
         }
       }
     }
   }

Combined Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~~~

The following index definition example uses both static 
and dynamic mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that aren't explicitly 
  mentioned aren't indexed. So, the index definition includes:

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries. To learn more about ``multi`` 
    analyzers, see :ref:`Path Construction <ref-path>`.
  - The ``employees`` field, which  is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. 
  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``. Instead of 
    explicitly mentioning each nested field in the document, the 
    index definition enables dynamic mapping for all the 
    sub-fields in the document. It uses the :ref:`lucene.standard 
    <ref-keyword-analyzer>` analyzer by default for queries.  

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "address": {
           "type": "document",
           "dynamic": true
         }
       }
     }
   }

.. toctree::
   :titlesonly:

   array Type </atlas-search/field-types/array-type>
   autocomplete Type </atlas-search/field-types/autocomplete-type>
   boolean Type </atlas-search/field-types/boolean-type>
   date Type </atlas-search/field-types/date-type>
   dateFacet Type </atlas-search/field-types/date-facet-type>
   document Type </atlas-search/field-types/document-type>
   embeddedDocuments Type </atlas-search/field-types/embedded-documents-type>
   geo Type </atlas-search/field-types/geo-type>
   number Type </atlas-search/field-types/number-type>
   numberFacet Type </atlas-search/field-types/number-facet-type>
   objectId Type </atlas-search/field-types/object-id-type>
   string Type </atlas-search/field-types/string-type>
   stringFacet Type </atlas-search/field-types/string-facet-type>
   token Type </atlas-search/field-types/token-type>
 