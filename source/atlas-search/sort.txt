.. _sort-ref:

==================
Sort |fts| Results 
==================

.. default-domain:: mongodb

.. meta::
   :description: Sort you Atlas Search results by date, number, and string fields.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol
   
Overview
--------

|fts| allows you to sort the results in ascending or descending order on 
fields that you define in your |fts| index. You can sort by date, number
(integer, float, and double values), boolean, and string fields indexed
as a :ref:`token <bson-data-types-token>` type using the ``sort``
option. You can also sort by the score of the documents in the results. 

.. note:: 

   |fts| :ref:`sort <sort-ref>` option is available in sharded
   {+clusters+} only if you run MongoDB v6.0+ or higher.

Usage 
~~~~~

To sort your |fts| results, you must do the following:

1. Create an |fts| index on the fields to sort the results by. 
   
   |fts| automatically indexes number and date fields in all indexes
   created after :ref:`July 2023 <fts20230710>` for sorting. For
   preexisting indexes, you must trigger an index rebuild from the
   {+atlas-ui+} to use any date and number fields in the indexes for
   sorting. To learn more, see :ref:`sort-index-rebuild`.

   For string fields, you must manually index the field as ``token``
   type. To learn more, see :ref:`bson-data-types-token`. 

   |fts| automatically indexes boolean fields in all indexes
   created after {DATE-PLACEHOLDER} for sorting. For preexisting
   indexes, you must trigger an index rebuild from the {+atlas-ui+} to
   use any date and number fields in the indexes for sorting. To learn
   more, see :ref:`sort-index-rebuild`. 

#. Create and run your query with the ``sort`` option against the fields
   you defined in the index for sorting. To learn more, see 
   :ref:`sort-syntax-ref`.

Behavior 
~~~~~~~~

Sort by Date, Numeric, String, or Boolean Field 
```````````````````````````````````````````````

The ``sort`` option takes a document that specifies the fields to sort 
by and the respective sort order. |fts| follows the :manual:`MongoDB
comparison order </reference/bson-type-comparison-order/>` for the
supported data types. It treats null and missing values as equivalent in
its sort order. To learn more, see :manual:`non-existent fields
</reference/bson-type-comparison-order/#non-existent-fields>`. 

You can specify the following sort order to sort your results by: 

.. list-table:: 
   :widths: 10 90 

   * - ``1`` 
     - Sort in ascending order. 
  
       When you sort in ascending order, |fts| returns documents with
       missing values before documents with values. 

   * - ``-1`` 
     - Sort in descending order.

Sort by Score and a Unique Field 
`````````````````````````````````

You can also sort by score in ascending or descending order. The
``sort`` option takes a document that specifies the :manual:`$meta
</reference/operator/aggregation/meta/>` expression, which requires the
``searchScore`` value. 

.. example:: 

   Suppose your application allows users to skip to the last page of the
   search results. The following example sorts the results by score in
   ascending order so that the document with the lowest score displays at
   the top of the results: 

   .. code-block:: json 
      :copyable: true 

      sort: {score: {$meta: "searchScore", order: 1}}

You can use ``sort`` to also ensure that the results have a determined
order when multiple documents in the results have identical scores. The
following example doesn't sort the results by a unique field.   

If you don't specify a unique date or numeric field to sort the results
by, |fts| defaults to sorting the results by score in descending order
and returns results with identical scores in an arbitrary order:  

.. example:: 

   .. code-block:: shell 
      :copyable: false 

      sort: {score: {$meta: "searchScore"}}

However, if you sort the results by a unique date or numeric field, such
as a date field named ``lastUpdated`` as shown in the following example,
|fts| uses the value of the specified field to return results with
identical scores in a determined order:  

.. example::

   .. code-block:: 
      :copyable: false

      sort: {score: {$meta: "searchScore"}, lastUpdated: 1}

To learn more, see :ref:`scoring-ref`.

Sort Arrays 
```````````

|fts| flattens the arrays for sorting. 

.. example:: 

   Consider the following array: 

   .. code-block:: shell 
      :copyable: false 

      [4, [1, [8,5], 9], 2]

   |fts| flattens the preceding array similar to the following:

   .. code-block:: shell 
      :copyable: false 

      4, 1, 8, 5, 9, 2

   For an ascending sort, |fts| uses ``1`` to compare the array to other
   values. For a descending sort, |fts| uses ``9`` to compare the array
   to other values.

When comparing with elements inside an array:

- For an ascending sort, |fts| compares the smallest elements of the
  array or performs a less than (``<``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in ascending order:

     .. code-block:: shell 
        :copyable: false 

        -20
        [-3, 12] // <- -3 comes before 5.
        5
        [6, 18]  // <- 6 comes after 5.
        13
        14

- For a descending sort, |fts| compares the largest elements of the
  array or performs a greater than (``>``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in descending order:

     .. code-block:: shell 
        :copyable: false 

        [6, 18]  // <- 18 comes before 14.
        14
        13
        [-3, 12] // <- 12 comes after 13.
        5
        -20

Sort on Embedded Documents Array Fields 
```````````````````````````````````````

.. include:: /includes/fact-fts-embedded-documents-sort.rst

.. _sort-considerations:

Considerations 
~~~~~~~~~~~~~~

Consistency 
```````````

|fts| indexes are eventually :ref:`consistent
<index-eventual-consistency-and-latency>`, and values returned in
results might be different from values used in sorting.

Performance 
```````````

This feature optimizes queries that use :pipeline:`$search` with
:pipeline:`$limit` as a subsequent stage. If |fts| needs to sort all 
documents in the collection, the response might be slow.

Scoring 
```````

|fts| returns :ref:`scores <scoring-ref>` for all documents in the
results. However, you might see higher scoring documents after lower
scoring documents because the order of documents in the results is based
on the sort criteria unless you explicitly sort by score.

Limitations 
~~~~~~~~~~~

- You can't sort on fields of :ref:`embeddedDocuments
  <bson-data-types-embedded-documents>` type.
- You can't use the ``sort`` option with the :ref:`knn-beta-ref`
  operator. 

.. _sort-compatibility-ref:

Compatibility 
~~~~~~~~~~~~~

|service| supports non-sharded sort queries across all major and minor
MongoDB 5.0 and later versions. Sharded sort queries are available on
all major releases for 6.0 and on all major and minor releases for for
7.0 and later versions. If you use ``sort``  on sharded |service|
{+clusters+} running MongoDB v5.0 and earlier, |fts| returns an error.

.. _sort-syntax-ref:

Syntax 
------

``sort`` has the following syntax:

.. code-block:: json
   :emphasize-lines: 7-11
   :linenos:

   {
     "$search": {  
       "index": "<index name>", // optional, defaults to "default"
       "<operator>": { // such as "text", "compound", or "phrase"
         <operator-specification>
       },
       "sort": { 
         score: {$meta: "searchScore"},
         "<field-to-sort>": <sort-order>, 
         ...
       } 
     }
   }

Examples 
--------

The following examples use the ``sample_mflix.movies``, 
``sample_airbnb.listingsAndReview``, or a custom collection. 

Index Definition
~~~~~~~~~~~~~~~~

The example queries in this page use either the ``sample_mflix.movies``,
the ``sample_airbnb.listingsAndReview``, or a custom collection. If you
create the following indexes on these collections, you can run the
sample queries against the indexed fields.

.. tabs:: 

   .. tab:: ``movies`` Collection
      :tabid: movies

      The example queries against the ``sample_mflix.movies`` collection
      in this section use the following index. The index definition for
      the collection specifies the following:    

      - Index ``awards.wins`` field as: 

        - ``number`` type for sorting and querying
        - ``numberFacet`` type for running :ref:`fts-facet-ref` queries

      - Index ``released`` field as: 

        - ``date`` type for sorting and querying
        - ``dateFacet`` type for running :ref:`fts-facet-ref` queries

      - Index ``title`` field as: 

        - ``token`` type for sorting 
        - ``string`` type for querying  

      .. code-block:: json
         :copyable: true 
         :linenos:

         {
           "mappings": {
             "dynamic": true,
             "fields": {
               "awards": {
                 "dynamic": false,
                 "fields": {
                   "wins": [
                     {
                       "type": "number"
                     },
                     {
                       "type": "numberFacet"
                     }
                   ]
                 },
                 "type": "document"
               },
               "released": [
                 {
                   "type": "date"
                 },
                 {
                   "type": "dateFacet"
                 }
               ],
               "title": [{
                 "type": "token"
               }, {
                 "type": "string"
               }]
             }
           }
         }

      For the preceding index definition, |fts| creates an index named
      ``default`` with :ref:`static mappings <static-dynamic-mappings>`
      on the specified fields. 

   .. tab:: ``listingsAndReviews`` Collection
      :tabid: airbnb

      The example queries against the
      ``sample_airbnb.listingsAndReviews`` collection in this section
      use the following index. The index definition specifies dynamic
      mappings on the fields in the collection: 

      .. code-block:: json
         :copyable: true 
         :linenos:

         {
           "mappings": {
             "dynamic": true
           }
         }

Date Search and Sort 
~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``released`` in the results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "range": {
              "path": "released",
              "gt": ISODate("2010-01-01T00:00:00.000Z"),
              "lt": ISODate("2015-01-01T00:00:00.000Z")
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1
          }
        }
      ])

   .. output::
      :language: json
      :visible: false

      [
        {
          title: 'The Gambler',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'Cold in July',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'Force Majeure',
          released: ISODate("2014-12-30T00:00:00.000Z")
        },
        { 
          title: 'LFO', 
          released: ISODate("2014-12-27T00:00:00.000Z") 
        },
        {
          title: 'The Water Diviner',
          released: ISODate("2014-12-26T00:00:00.000Z")
        }
      ]

Number Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have won awards.  
- Sort the results in descending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``awards.wins`` in the results.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
             "range": {
               "path": "awards.wins",
               "gt": 3
            },
            "sort": {
              "awards.wins": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "awards.wins": 1
          }
        }
      ])

   .. output::
      :language: json
      :visible: false

      [
        { title: '12 Years a Slave', awards: { wins: 267 } },
        { title: 'Gravity', awards: { wins: 231 } },
        { title: 'Gravity', awards: { wins: 231 } },
        {
          title: 'Birdman: Or (The Unexpected Virtue of Ignorance)',
          awards: { wins: 210 }
        },
        { title: 'Boyhood', awards: { wins: 185 } },
      ]

String Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``country`` in the title.  
- Sort the results in ascending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title`` in the results.
- Add a field named ``score``.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "text": {
              "path": "title",
              "query": "country"
            },
            "sort": {
              "title": 1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json
      :visible: false

      [
        { title: 'A Country Called Home', score: 2.536633253097534 },
        { title: 'A Month in the Country', score: 2.258953094482422 },
        { title: 'A Quiet Place in the Country', score: 2.0360684394836426 },
        { title: 'A Sunday in the Country', score: 2.258953094482422 },
        { title: 'Another Country', score: 3.3635599613189697 }
      ]

UUID Search and Sort
~~~~~~~~~~~~~~~~~~~~

UUID sorting follows the behavior of :manual:`MongoDB comparison order </reference/bson-type-comparison-order/>`.

.. code-block:: json
   :copyable: true

   db.users.insertMany([
     {
       "_id": 0,
       "a": UUID("00000000-1111-2222-3333-444444444444"),
       "b": "hello"
     },
     {
       "_id": 1,
       "a": "foo",
       "b": "hello"
     },
     {
       "_id": 2,
       "a": 5,
       "b": "hello"
     },
     {
       "_id": 3,
       "b": "hello"
     }
   ])

.. io-code-block::
   :copyable: true

   .. input::
      :language: json

      {
        $search: {
          "text": {
            "path": "b",
            "query": "hello"
          },
          "sort": {
            "a": 1
          }
        }
      }

   .. output::
      :language: json
      :visible: false

      "results": [
        {
          "_id": 3      // missing
        },
        {
          "_id": 2      // number
        },
        {
          "_id": 1      // string
        },
        {
          "_id": 0      // binary data (UUID)
        }
      ]

Null Value Search and Sort
~~~~~~~~~~~~~~~~~~~~~~~~~~

Fields which contain null values that are used for sorting will treat null as equivalent to missing fields.
For example, given the following documents and query,
the ordering between documents 2 and 3 is non-deterministic,
since the MQL sort order treats missing and nulls equally when sorting.

.. code-block:: json
   :copyable: true

   db.users.insertMany([
     {
       "_id": 0,
       "a": 20,
       "b": "hello"
     },
     {
       "_id": 1,
       "a": 10,
       "b": "hello"
     },
     {
       "_id": 2,
       "a": null,
       "b": "hello"
     },
     {
       "_id": 3,
       "b": "hello"
     }
   ])

.. io-code-block::
   :copyable: true

   .. input::
      :language: json

      {
        $search: {
          "text": {
            "path": "b",
            "query": "hello"
          },
          "sort": {
            "a": 1
          }
        }
      }

   .. output::
      :language: json
      :visible: false

      "results": [
        {
          "_id": 3
        },
        {
          "_id": 2
        },
        {
          "_id": 1
        },
        {
          "_id": 0
        }
      ]

Sort by Boolean
~~~~~~~~~~~~~~~

The following query searches the ``sample_airbnb.listingsAndReviews``
collection for properties in ``Portugal`` and sorts the results in 
descending order by the ``boolean`` field ``is_location_exact``.

The query uses the :pipeline:`$limit` stage to limit the output to ``5`` 
documents. It also uses the :pipeline:`$project` stage to omit all
fields except ``name``, ``property_type``, ``address.country``, and
``address.location.is_location_exact`` in the results. 

.. io-code-block:: 
   :copyable: true 

   .. input:: 
      :language: json 
      :linenos: 

      db.listingsAndReviews.aggregate([
        {
          "$search": {
            "text": {
              "path": "address.country",
              "query": "Portugal"
            },
            "sort": {
              "address.location.is_location_exact": -1,
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "name": 1,
            "property_type": 1,
            "address.country": 1,
            "address.location.is_location_exact": 1
          }
        }
      ])

   .. output:: 
      :language: javascript 
      :linenos: 
      :visible: false 

      [
        {
          name: 'BBC OPORTO 4X2',
          property_type: 'Apartment',
          address: { country: 'Portugal', location: { is_location_exact: true } }
        },
        {
          name: 'Heroísmo IV',
          property_type: 'Apartment',
          address: { country: 'Portugal', location: { is_location_exact: true } }
        },
        {
          name: 'Spacious and well located apartment',
          property_type: 'Apartment',
          address: { country: 'Portugal', location: { is_location_exact: true } }
        },
        {
          name: 'Renovated Classic Design Studio with Sun Room',
          property_type: 'Apartment',
          address: { country: 'Portugal', location: { is_location_exact: true } }
        },
        {
          name: "O'Porto Studio | Historic Center",
          property_type: 'Loft',
          address: { country: 'Portugal', location: { is_location_exact: true } }
        }
      ]

In the preceding results, the value of ``is_location_exact`` is ``true``
for the documents because in a descending sort, |fts| ranks ``true``
values above ``false`` values. If you do an ascending sort by changing
the value on line 9 of the preceding query to ``1``, |fts| ranks the
documents with ``false`` values higher than ``true`` values and returns
the following documents:  
   
.. code-block:: json 
   :copyable: false 

   [
     {
       name: 'Ribeira Charming Duplex',
       property_type: 'House',
       address: { country: 'Portugal', location: { is_location_exact: false } }
     },
     {
       name: 'Be Happy in Porto',
       property_type: 'Loft',
       address: { country: 'Portugal', location: { is_location_exact: false } }
     },
     {
       name: 'Downtown Oporto Inn (room cleaning)',
       property_type: 'Hostel',
       address: { country: 'Portugal', location: { is_location_exact: false } }
     },
     {
       name: 'A Casa Alegre é um apartamento T1.',
       property_type: 'Apartment',
       address: { country: 'Portugal', location: { is_location_exact: false } }
     },
     {
       name: 'FloresRooms 3T',
       property_type: 'Apartment',
       address: { country: 'Portugal', location: { is_location_exact: false } }
     }
   ]

Compound Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``dance`` in the title, with
  a preference for movies that have won 2 or more awards and were
  released after 01 January, 1990.  
- Sort the results by the number of awards in descending order, then by
  the movie title in ascending order, and then by the release date in
  descending order. 

The query uses the :pipeline:`$limit` stage to limit the output to ``10``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title``, ``released``, and ``awards.wins`` in
  the results. 
- Add a field named ``score``.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "compound": {
              "must": [{
                "text": {
                  "path": "title",
                  "query": "dance"
                }
              }],
              "should": [{
                "range": {
                  "path": "awards.wins",
                  "gte": 2
                }
              }, {
                "range": {
                  "path": "released",
                  "gte": ISODate("1990-01-01T00:00:00.000Z")
                }
              }]
            },
            "sort": {
              "awards.wins": -1, 
              "title": 1, 
              "released": -1
            }
          }
        },
        {
          "$limit": 10
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1,
            "awards.wins": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json
      :visible: false

      [
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'War Dance',
          released: ISODate("2008-11-01T00:00:00.000Z"),
          awards: { wins: 11 },
          score: 5.466421127319336
        },
        {
          title: 'Dance with the Devil',
          released: ISODate("1997-10-31T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Save the Last Dance',
          released: ISODate("2001-01-12T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Dance with a Stranger',
          released: ISODate("1985-08-09T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 3.615056037902832
        },
        {
          title: 'The Baby Dance',
          released: ISODate("1998-08-23T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: 'Three-Step Dance',
          released: ISODate("2004-02-19T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: "Cats Don't Dance",
          released: ISODate("1997-03-26T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        },
        {
          title: 'Dance Me Outside',
          released: ISODate("1995-03-10T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        }
      ]

Facet Search and Sort 
~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Get a count of the number of movies that won ``1``, ``5``, ``10``, and
  ``15`` awards.
- Get a count of the number of movies released on ``2010-01-01``,
  ``2011-01-01``, ``2012-01-01``, ``2013-01-01``, ``2014-01-01``, and
  ``2015-01-01``.
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to do the following: 

- Limit the output to ``5`` documents in the ``docs`` output field. 
- Limit the output to ``1`` document in the ``meta`` output field. 

It uses the :pipeline:`$project` stage to omit all fields except the
``awards.wins``, ``released``, and ``title`` fields.

It also uses the :pipeline:`$replaceWith` stage to include the metadata
results stored in the ``$$SEARCH_META`` variable in the ``meta`` output
field and the :pipeline:`$set` stage to add the ``meta`` field to the
results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "facet": {
              "operator": {
                "range": {
                  "path": "released",
                  "gt": ISODate("2010-01-01T00:00:00.000Z"),
                  "lt": ISODate("2015-01-01T00:00:00.000Z")
                }
              },
              "facets": {
                "awardsFacet": {
                  "type": "number",
                  "path": "awards.wins",
                  "boundaries" : [1,5,10,15]
                },
                "releasedFacet" : {
                  "type" : "date",
                  "path" : "released",
                  "boundaries" : [ISODate("2010-01-01T00:00:00.000Z"), ISODate("2011-01-01T00:00:00.000Z"), ISODate("2012-01-01T00:00:00.000Z"), ISODate("2013-01-01T00:00:00.000Z"), ISODate("2014-01-01T00:00:00.000Z"), ISODate("2015-01-01T00:00:00.000Z")]
                }
              }
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$facet": {
            "docs": [
              { "$limit": 5 },
              { "$project":
                {
                  "_id": 0,
                  "title": 1,
                  "released": 1,
                  "awards.wins": 1
                }
              }
            ],
            "meta": [
              {"$replaceWith": "$$SEARCH_META"},
              {"$limit": 1}
            ]
          }
        },
        {
          "$set": {
            "meta": {
              "$arrayElemAt": ["$meta", 0]
            }
          }
        }
      ])

   .. output::
      :language: json
      :visible: false

      [
        {
          docs: [
            {
              title: 'The Gambler',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 7 }
            },
            {
              title: 'Cold in July',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 1 }
            },
            {
              title: 'Force Majeure',
              released: ISODate("2014-12-30T00:00:00.000Z"),
              awards: { wins: 31 }
            },
            {
              title: 'LFO',
              released: ISODate("2014-12-27T00:00:00.000Z"),
              awards: { wins: 3 }
            },
            {
              title: 'The Water Diviner',
              released: ISODate("2014-12-26T00:00:00.000Z"),
              awards: { wins: 8 }
            }
          ],
          meta: {
            count: { lowerBound: Long("4821") },
              facet: {
                releasedFacet: {
                  buckets: [
                    {
                      _id: ISODate("2010-01-01T00:00:00.000Z"),
                      count: Long("857")
                    },
                    {
                      _id: ISODate("2011-01-01T00:00:00.000Z"),
                      count: Long("909")
                    },
                    {
                      _id: ISODate("2012-01-01T00:00:00.000Z"),
                      count: Long("903")
                    },
                    {
                      _id: ISODate("2013-01-01T00:00:00.000Z"),
                      count: Long("1063")
                    },
                    {
                      _id: ISODate("2014-01-01T00:00:00.000Z"),
                      count: Long("1089")
                    }
                  ]
                },
                awardsFacet: {
                  buckets: [
                    { _id: 1, count: Long("2330") },
                    { _id: 5, count: Long("604") },
                    { _id: 10, count: Long("233") }
                  ]
                }
              }
            }
          }
        }
      ]

.. _sort-by-score-egs:

Sort by Score
~~~~~~~~~~~~~

The following examples demonstrate how to sort the results by the score
of the documents in the results. The examples demonstrate how to perform
the following actions: 

- Retrieve the lowest scoring documents first by sorting the results in
  ascending order.
- Sort the results by score in descending order and for results with
  identical scores, sort arbitrarily. 
- Sort the results by score and for results with identical scores, sort
  using a unique field. 

.. tabs:: 

   .. tab:: Ascending Sort 
      :tabid: ascending-sort

      The following query uses the :pipeline:`$search` stage to perform
      the following actions: 

      - Search for movies that have the term ``story`` in the title.  
      - Sort the results by score in ascending order. 

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``title`` in the results.
      - Add a field named ``score``.

      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "story"
                  },
                  "sort": {score: {$meta: "searchScore", order: 1}}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 0,
                  "title": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json
            :emphasize-lines: 12-21
            :visible: false

            [
              {
                title: 'Do You Believe in Miracles? The Story of the 1980 U.S. Hockey Team',
                score: 0.8674521446228027
              },
              {
                title: 'Once in a Lifetime: The Extraordinary Story of the New York Cosmos',
                score: 0.9212141036987305
              },
              {
                title: 'The Source: The Story of the Beats and the Beat Generation',
                score: 0.9820802211761475
              },
              {
                title: 'If These Knishes Could Talk: The Story of the NY Accent',
                score: 0.9820802211761475
              },
              {
                title: 'Dream Deceivers: The Story Behind James Vance vs. Judas Priest',
                score: 1.051558256149292
              }
            ]

   .. tab:: Default (Descending) Sort 
      :tabid: descending-sort

      The following query uses the :pipeline:`$search` stage to perform
      the following actions: 

      - Search for movies that have the term ``summer`` in the title.  
      - Sort the results by score in descending order and for results
        with identical scores, sort arbitrarily. 

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``_id`` and ``title`` in the results.
      - Add a field named ``score``.

      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "summer"
                  },
                  "sort": {score: {$meta: "searchScore"}}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 1,
                  "title": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json
            :visible: false

            [
              {
                _id: ObjectId("573a1398f29313caabcea21e"),
                title: 'Summer',
                score: 3.5844719409942627
              },
              {
                _id: ObjectId("573a13a6f29313caabd18eca"),
                title: 'Summer Things',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a13b8f29313caabd4c1d0"),
                title: 'Summer Palace',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a1394f29313caabcde8e8"),
                title: 'Summer Stock',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a13acf29313caabd284fa"),
                title: 'Wolf Summer',
                score: 3.000213623046875
              }
            ]

   .. tab:: Sort by Unique Field
      :tabid: unique-field-sort

      The following query uses the :pipeline:`$search` stage to perform the
      following actions: 

      - Search for movies that have the term ``prince`` in the title.  
      - Sort the results first by score and then by the value of the
        ``released`` field in ascending order for results with identical
        scores.  

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``title`` and ``released`` in the results.
      - Add a field named ``score``.
 
      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "prince"
                  },
                  "sort": {score: {$meta: "searchScore"}, "released": 1}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 0,
                  "title": 1,
                  "released": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json
            :visible: false

            [
              {
                title: 'Prince',
                released: ISODate("2015-08-14T00:00:00.000Z"),
                score: 4.168826103210449
              },
              {
                title: 'Prince Avalanche',
                released: ISODate("2013-09-19T00:00:00.000Z"),
                score: 3.4893198013305664
              },
              {
                title: 'The Prince',
                released: ISODate("2014-08-22T00:00:00.000Z"),
                score: 3.4893198013305664
              },
              {
                title: 'Prince of Foxes',
                released: ISODate("1949-12-23T00:00:00.000Z"),
                score: 3.0002830028533936
             },
              {
                title: 'The Oil Prince',
                released: ISODate("1966-01-01T00:00:00.000Z"),
                score: 3.0002830028533936
              }
            ]
