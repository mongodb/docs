================================
E-Commerce: Inventory Management
================================

Problem
=======

You have a product catalog and you would like to maintain an accurate
inventory count as users shop your online store, adding and removing
things from their cart.

Solution Overview
=================

In an ideal world, consumers would begin browsing an online store, add
items to their shopping cart, and proceed in a timely manner to checkout
where their credit cards would always be successfully validated and
charged. In the real world, however, customers often add or remove items
from their shopping cart, change quantities, abandon the cart, and have
problems at checkout time.

This solution keeps the traditional metaphor of the shopping cart, but
the shopping cart will *age* . Once a shopping cart has not been active
for a certain period of time, all the items in the cart once again
become part of available inventory and the cart is cleared. The state
transition diagram for a shopping cart is below:

.. figure:: img/ecommerce-inventory1.png
   :align: center
   :alt:

Schema Design
=============

In your inventory collection, you need to maintain the current available
inventory of each stock-keeping unit (SKU) as well as a list of 'carted'
items that may be released back to available inventory if their shopping
cart times out:

.. code-block:: javascript

    {
        _id: '00e8da9b',
        qty: 16,
        carted: [
            { qty: 1, cart_id: 42,
              timestamp: ISODate("2012-03-09T20:55:36Z"), },
            { qty: 2, cart_id: 43,
              timestamp: ISODate("2012-03-09T21:55:36Z"), },
        ]
    }

(Note that, while in an actual implementation, you might choose to merge
this schema with the product catalog schema described in
:doc:`E-Commerce: Product Catalog <ecommerce-product-catalog>`, the inventory
schema is simplified here for brevity.) Continuing the metaphor of the
brick-and-mortar store, your SKU above has 16 items on the shelf, 1 in one cart,
and 2 in another for a total of 19 unsold items of merchandise.

For the shopping cart model, you need to maintain a list of (``sku``,
``quantity``, ``price``) line items:

.. code-block:: javascript

    {
        _id: 42,
        last_modified: ISODate("2012-03-09T20:55:36Z"),
        status: 'active',
        items: [
            { sku: '00e8da9b', qty: 1, item_details: {...} },
            { sku: '0ab42f88', qty: 4, item_details: {...} }
        ]
    }

Note that the cart model includes item details in each line
item. This allows your app to display the contents of the cart to the user
without needing a second query back to the catalog collection to fetch
the details.

Operations
==========

Here, the various inventory-related operations in an ecommerce site are described
as they would occur using the schema above. The examples use the Python
programming language and the ``pymongo`` MongoDB driver, but implementations
would be similar in other languages as well.

Add an Item to a Shopping Cart
------------------------------

The most basic operation is moving an item off the "shelf" in to the
"cart." The constraint is that you would like to guarantee that you never
move an unavailable item off the shelf into the cart. To solve this
problem, this solution ensures that inventory is only updated if there is
sufficient inventory to satisfy the request:

.. code-block:: python

    def add_item_to_cart(cart_id, sku, qty, details):
        now = datetime.utcnow()

        # Make sure the cart is still active and add the line item
        result = db.cart.update(
            {'_id': cart_id, 'status': 'active' },
            { '$set': { 'last_modified': now },
              '$push':
                  'items': {'sku': sku, 'qty':qty, 'details': details }
            },
            safe=True)
        if not result['updatedExisting']:
            raise CartInactive()

        # Update the inventory
        result = db.inventory.update(
            {'_id':sku, 'qty': {'$gte': qty}},
            {'$inc': {'qty': -qty},
             '$push': {
                 'carted': { 'qty': qty, 'cart_id':cart_id,
                             'timestamp': now } } },
            safe=True)
        if not result['updatedExisting']:
            # Roll back our cart update
            db.cart.update(
                {'_id': cart_id },
                { '$pull': { 'items': {'sku': sku } } }
            )
            raise InadequateInventory()

Note here in particular that the system does not trust that the request is
satisfiable. The first check makes sure that the cart is still "active"
(more on inactive carts below) before adding a line item. The next check
verifies that sufficient inventory exists to satisfy the request before
decrementing inventory. In the case of inadequate inventory, the system
*compensates* for the non-transactional nature of MongoDB by removing the
cart update. Using safe=True and checking the result in the case of
these two updates allows you to report back an error to the user if the
cart has become inactive or available quantity is insufficient to
satisfy the request.

Index Support
~~~~~~~~~~~~~

To support this query efficiently, all you really need is an index on
``_id``, which MongoDB provides us by default.

Modifying the Quantity in the Cart
----------------------------------

Here, you'd like to allow the user to adjust the quantity of items in their
cart. The system must ensure that when they adjust the quantity upward, there
is sufficient inventory to cover the quantity, as well as updating the
particular ``carted`` entry for the user's cart.

.. code-block:: python

    def update_quantity(cart_id, sku, old_qty, new_qty):
        now = datetime.utcnow()
        delta_qty = new_qty - old_qty

        # Make sure the cart is still active and add the line item
        result = db.cart.update(
            {'_id': cart_id, 'status': 'active', 'items.sku': sku },
            {'$set': {
                 'last_modified': now,
                 'items.$.qty': new_qty },
            },
            safe=True)
        if not result['updatedExisting']:
            raise CartInactive()

        # Update the inventory
        result = db.inventory.update(
            {'_id':sku,
             'carted.cart_id': cart_id,
             'qty': {'$gte': delta_qty} },
            {'$inc': {'qty': -delta_qty },
             '$set': { 'carted.$.qty': new_qty, 'timestamp': now } },
            safe=True)
        if not result['updatedExisting']:
            # Roll back our cart update
            db.cart.update(
                {'_id': cart_id, 'items.sku': sku },
                {'$set': { 'items.$.qty': old_qty }
            })
            raise InadequateInventory()

Note in particular here the use of the positional operator '$' to
update the particular ``carted`` entry and line item that matched for the
query. This allows the system to update the inventory and keep track of the data
necessary need to "rollback" the cart in a single atomic operation. The code above
also ensures the cart is active and timestamp it as in the case of adding
items to the cart.

Index Support
~~~~~~~~~~~~~

To support this query efficiently, again all we really need is an index on ``_id``.

Checking Out
------------

During checkout, you'd like to validate the method of payment and remove
the various ``carted`` items after the transaction has succeeded.

.. code-block:: python

    def checkout(cart_id):
        now = datetime.utcnow()

        # Make sure the cart is still active and set to 'pending'. Also
        #     fetch the cart details so we can calculate the checkout price
        cart = db.cart.find_and_modify(
            {'_id': cart_id, 'status': 'active' },
            update={'$set': { 'status': 'pending','last_modified': now } } )
        if cart is None:
            raise CartInactive()

        # Validate payment details; collect payment
        try:
            collect_payment(cart)
            db.cart.update(
                {'_id': cart_id },
                {'$set': { 'status': 'complete' } } )
            db.inventory.update(
                {'carted.cart_id': cart_id},
                {'$pull': {'cart_id': cart_id} },
                multi=True)
        except:
            db.cart.update(
                {'_id': cart_id },
                {'$set': { 'status': 'active' } } )
            raise

Here, the cart is first "locked" by setting its status to "pending"
(disabling any modifications.) Then the system collects payment data, verifying
at the same time that the cart is still active. MongoDB's
``findAndModify`` command is used to atomically update the cart and return its
details so you can capture payment information. If the payment is
successful, you then remove the ``carted`` items from individual items'
inventory and set the cart to "complete." If payment is unsuccessful, you
unlock the cart by setting its status back to "active" and report a
payment error.

Index Support
~~~~~~~~~~~~~

Once again the ``_id`` default index is enough to make this operation efficient.

Returning Timed-Out Items to Inventory
--------------------------------------

Periodically, you'd like to expire carts that have been inactive for a
given number of seconds, returning their line items to available
inventory:

.. code-block:: python

    def expire_carts(timeout):
        now = datetime.utcnow()
        threshold = now - timedelta(seconds=timeout)

        # Lock and find all the expiring carts
        db.cart.update(
            {'status': 'active', 'last_modified': { '$lt': threshold } },
            {'$set': { 'status': 'expiring' } },
            multi=True )

        # Actually expire each cart
        for cart in db.cart.find({'status': 'expiring'}):

            # Return all line items to inventory
            for item in cart['items']:
                db.inventory.update(
                    { '_id': item['sku'],
                      'carted.cart_id': cart['id'],
                      'carted.qty': item['qty']
                    },
                    {'$inc': { 'qty': item['qty'] },
                     '$pull': { 'carted': { 'cart_id': cart['id'] } } })

            db.cart.update(
                {'_id': cart['id'] },
                {'$set': { status': 'expired' })

Here, you first find all carts to be expired and then, for each cart,
return its items to inventory. Once all items have been returned to
inventory, the cart is moved to the 'expired' state.

Index Support
~~~~~~~~~~~~~

In this case, you need to be able to efficiently query carts based on
their ``status`` and ``last_modified`` values, so an index on these would help
the performance of the periodic expiration process:

.. code-block:: python

    >>> db.cart.ensure_index([('status', 1), ('last_modified', 1)])

Note in particular the order in which the index is defined: in order to
efficiently support range queries ('$lt' in this case), the ranged item
must be the last item in the index. Also note that there is no need to
define an index on the ``status`` field alone, as any queries for status
can use the compound index we have defined here.

Error Handling
--------------

There is one failure mode above that thusfar has not been handled adequately: the
case of an exception that occurs after updating the inventory collection
but before updating the shopping cart. The result of this failure mode
is a shopping cart that may be absent or expired where the 'carted'
items in the inventory have not been returned to available inventory. To
account for this case, you'll need to run a cleanup method periodically that
will find old ``carted`` items and check the status of their cart:

.. code-block:: python

    def cleanup_inventory(timeout):
        now = datetime.utcnow()
        threshold = now - timedelta(seconds=timeout)

        # Find all the expiring carted items
        for item in db.inventory.find(
            {'carted.timestamp': {'$lt': threshold }}):

            # Find all the carted items that matched
                  carted = dict(
                      (carted_item['cart_id'], carted_item)
                      for carted_item in item['carted']
                      if carted_item['timestamp'] < threshold)

            # Find any carts that are active and refresh the carted items
            for cart in db.cart.find(
                { '_id': {'$in': carted.keys() },
                  'status':'active'}):
                cart = carted[cart['_id']]
                db.inventory.update(
                    { '_id': item['_id'],
                      'carted.cart_id': cart['_id'] },
                    { '$set': {'carted.$.timestamp': now } })
                del carted[cart['_id']]

            # All the carted items left in the dict need to now be
            #    returned to inventory
            for cart_id, carted_item in carted.items():
                db.inventory.update(
                    { '_id': item['_id'],
                      'carted.cart_id': cart_id,
                      'carted.qty': carted_item['qty'] },
                    { '$inc': { 'qty': carted_item['qty'] },
                      '$pull': { 'carted': { 'cart_id': cart_id } } })

Note that the function above is safe, as it checks to be sure the cart
is expired or expiring before removing items from the cart and returning
them to inventory. This function could, however, be slow as well as
slowing down other updates and queries, so it should be used
infrequently.

Sharding
========

If you choose to shard this system, the use of an ``_id`` field for most of
our updates makes ``_id`` an ideal sharding candidate, for both carts and
products. Using ``_id`` as your shard key allows all updates that query on
``_id`` to be routed to a single mongod process. There are two potential
drawbacks with using ``_id`` as a shard key, however.

-  If the cart collection's ``_id`` is generated in a generally increasing
   order, new carts will all initially be assigned to a single shard.
-  Cart expiration and inventory adjustment requires several broadcast
   queries and updates if ``_id`` is used as a shard key.

It turns out you can mitigate the first pitfall by choosing a random
value (perhaps the sha-1 hash of an ``ObjectId``) as the ``_id`` of each cart
as it is created. The second objection is valid, but relatively
unimportant, as the expiration function runs relatively infrequently and can be
slowed down by the judicious use of ``sleep()`` calls in order to
minimize server load.

The sharding commands you'd use to shard the cart and inventory
collections, then, would be the following:

.. code-block:: python

    >>> db.command('shardcollection', 'inventory')
    { "collectionsharded" : "inventory", "ok" : 1 }
    >>> db.command('shardcollection', 'cart')
    { "collectionsharded" : "cart", "ok" : 1 }

Note that there is no need to specify the shard key, as MongoDB will
default to using ``_id`` as a shard key.
