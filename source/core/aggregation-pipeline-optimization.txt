=================================
Aggregation Pipeline Optimization
=================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Aggregation pipeline operations have an optimization phase which
attempts to reshape the pipeline for improved performance.

To see how the optimizer transforms a particular aggregation pipeline,
include the :method:`explain <db.collection.aggregate()>` option in the
:method:`db.collection.aggregate()` method.

.. include:: /includes/fact-optimizations-subject-to-change.rst

.. _aggregation-pipeline-projection-optimization:

Projection Optimization
-----------------------

The aggregation pipeline can determine if it requires only a subset of
the fields in the documents to obtain the results. If so, the pipeline
will only use those required fields, reducing the amount of data
passing through the pipeline.

.. _aggregation-pipeline-sequence-optimization:

Pipeline Sequence Optimization
------------------------------

.. _agg-project-addFields-match-optimization:

``$project`` or ``$addFields`` + ``$match`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For an aggregation pipeline that contains a projection stage
(:pipeline:`$project` or :pipeline:`$addFields`) followed by a
:pipeline:`$match` stage, MongoDB moves any filters in the
:pipeline:`$match` stage that do not require values computed in the
projection stage to a new :pipeline:`$match` stage before the
projection.

If an aggregation pipeline contains multiple projection and/or
:pipeline:`$match` stages, MongoDB performs this optimization for each
:pipeline:`$match` stage, moving each :pipeline:`$match` filter before
all projection stages that the filter does not depend on.

Consider a pipeline of the following stages:

.. code-block:: javascript
   :emphasize-lines: 9-14

   { $addFields: {
       maxTime: { $max: "$times" },
       minTime: { $min: "$times" }
   } },
   { $project: {
       _id: 1, name: 1, times: 1, maxTime: 1, minTime: 1,
       avgTime: { $avg: ["$maxTime", "$minTime"] }
   } },
   { $match: {
       name: "Joe Schmoe",
       maxTime: { $lt: 20 },
       minTime: { $gt: 5 },
       avgTime: { $gt: 7 }
   } }

The optimizer breaks up the :pipeline:`$match` stage into four
individual filters, one for each key in the :pipeline:`$match` query
document. The optimizer then moves each filter before as many projection
stages as possible, creating new :pipeline:`$match` stages as needed.
Given this example, the optimizer produces the following *optimized*
pipeline:

.. code-block:: javascript
   :emphasize-lines: 1, 6, 11

   { $match: { name: "Joe Schmoe" } },
   { $addFields: {
       maxTime: { $max: "$times" },
       minTime: { $min: "$times" }
   } },
   { $match: { maxTime: { $lt: 20 }, minTime: { $gt: 5 } } },
   { $project: {
       _id: 1, name: 1, times: 1, maxTime: 1, minTime: 1,
       avgTime: { $avg: ["$maxTime", "$minTime"] }
   } },
   { $match: { avgTime: { $gt: 7 } } }

The :pipeline:`$match` filter ``{ avgTime: { $gt: 7 } }`` depends on the
:pipeline:`$project` stage to compute the ``avgTime`` field. The
:pipeline:`$project` stage is the last projection stage in this
pipeline, so the :pipeline:`$match` filter on ``avgTime`` could not be
moved.

The ``maxTime`` and ``minTime`` fields are computed in the
:pipeline:`$addFields` stage but have no dependency on the
:pipeline:`$project` stage. The optimizer created a new
:pipeline:`$match` stage for the filters on these fields and placed it
before the :pipeline:`$project` stage.

The :pipeline:`$match` filter ``{ name: "Joe Schmoe" }`` does not
use any values computed in either the :pipeline:`$project` or
:pipeline:`$addFields` stages so it was moved to a new
:pipeline:`$match` stage before both of the projection stages.

.. note::
   After optimization, the filter ``{ name: "Joe Schmoe" }`` is in
   a :pipeline:`$match` stage at the beginning of the pipeline. This has
   the added benefit of allowing the aggregation to use an index on the
   ``name`` field when initially querying the collection.
   See :ref:`aggregation-pipeline-operators-and-performance` for more
   information.

.. _agg-sort-match-optimization:

``$sort`` + ``$match`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you have a sequence with :pipeline:`$sort` followed by a
:pipeline:`$match`, the :pipeline:`$match` moves before the
:pipeline:`$sort` to minimize the number of objects to sort. For
example, if the pipeline consists of the following stages:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $match: { status: 'A' } }

During the optimization phase, the optimizer transforms the sequence to
the following:

.. code-block:: javascript

   { $match: { status: 'A' } },
   { $sort: { age : -1 } }

``$redact`` + ``$match`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When possible, when the pipeline has the :pipeline:`$redact` stage
immediately followed by the :pipeline:`$match` stage, the aggregation
can sometimes add a portion of the :pipeline:`$match` stage before the
:pipeline:`$redact` stage. If the added :pipeline:`$match` stage is at
the start of a pipeline, the aggregation can use an index as well as
query the collection to limit the number of documents that enter the
pipeline. See :ref:`aggregation-pipeline-operators-and-performance` for
more information.

For example, if the pipeline consists of the following stages:

.. code-block:: javascript

   { $redact: { $cond: { if: { $eq: [ "$level", 5 ] }, then: "$$PRUNE", else: "$$DESCEND" } } },
   { $match: { year: 2014, category: { $ne: "Z" } } }

The optimizer can add the same :pipeline:`$match` stage before the
:pipeline:`$redact` stage:

.. code-block:: javascript

   { $match: { year: 2014 } },
   { $redact: { $cond: { if: { $eq: [ "$level", 5 ] }, then: "$$PRUNE", else: "$$DESCEND" } } },
   { $match: { year: 2014, category: { $ne: "Z" } } }

.. _agg-skip-limit-optimization:

``$skip`` + ``$limit`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you have a sequence with :pipeline:`$skip` followed by a
:pipeline:`$limit`, the :pipeline:`$limit` moves before the
:pipeline:`$skip`. With the reordering, the :pipeline:`$limit` value
increases by the :pipeline:`$skip` amount.

For example, if the pipeline consists of the following stages:

.. code-block:: javascript

   { $skip: 10 },
   { $limit: 5 }

During the optimization phase, the optimizer transforms the sequence to
the following:

.. code-block:: javascript

   { $limit: 15 },
   { $skip: 10 }

This optimization allows for more opportunities for
:ref:`agg-sort-limit-coalescence`, such as with ``$sort`` + ``$skip`` +
``$limit`` sequences. See :ref:`agg-sort-limit-coalescence` for details
on the coalescence and :ref:`agg-sort-skip-limit-sequence` for an
example.

For aggregation operations on :doc:`sharded collections
<aggregation-pipeline-sharded-collections>`, this optimization reduces
the results returned from each shard.

.. _agg-project-skip-limit-optimization:

``$project`` + ``$skip`` or ``$limit`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 3.2

When you have a sequence with :pipeline:`$project` followed by either
:pipeline:`$skip` or :pipeline:`$limit`, the :pipeline:`$skip` or
:pipeline:`$limit` moves before :pipeline:`$project`. For example, if
the pipeline consists of the following stages:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $project: { status: 1, name: 1 } },
   { $limit: 5 }

During the optimization phase, the optimizer transforms the sequence to
the following:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $limit: 5 }
   { $project: { status: 1, name: 1 } },

This optimization allows for more opportunities for
:ref:`agg-sort-limit-coalescence`, such as with ``$sort`` + ``$limit``
sequences. See :ref:`agg-sort-limit-coalescence` for details on the
coalescence.

.. _aggregation-pipeline-coalescence-optimization:

Pipeline Coalescence Optimization
---------------------------------

When possible, the optimization phase coalesces a pipeline stage into
its predecessor. Generally, coalescence occurs *after* any sequence
reordering optimization.

.. _agg-sort-limit-coalescence:

``$sort`` + ``$limit`` Coalescence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a :pipeline:`$sort` immediately precedes a :pipeline:`$limit`, the
optimizer can coalesce the :pipeline:`$limit` into the
:pipeline:`$sort`. This allows the sort operation to only maintain the
top ``n`` results as it progresses, where ``n`` is the specified limit,
and MongoDB only needs to store ``n`` items in memory
[#coalescence-allowDiskUse]_. See :ref:`sort-and-memory` for more
information.

.. [#coalescence-allowDiskUse] The optimization will still apply when
   ``allowDiskUse`` is ``true`` and the ``n`` items exceed the
   :ref:`aggregation memory limit <agg-memory-restrictions>`.

.. _agg-limit-limit-coalescence:

``$limit`` + ``$limit`` Coalescence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a :pipeline:`$limit` immediately follows another
:pipeline:`$limit`, the two stages can coalesce into a single
:pipeline:`$limit` where the limit amount is the *smaller* of the two
initial limit amounts. For example, a pipeline contains the following
sequence:

.. code-block:: javascript

   { $limit: 100 },
   { $limit: 10 }

Then the second :pipeline:`$limit` stage can coalesce into the first
:pipeline:`$limit` stage and result in a single :pipeline:`$limit`
stage where the limit amount ``10`` is the minimum of the two initial
limits ``100`` and ``10``.

.. code-block:: javascript

   { $limit: 10 }

.. _agg-skip-skip-coalescence:

``$skip`` + ``$skip`` Coalescence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a :pipeline:`$skip` immediately follows another :pipeline:`$skip`,
the two stages can coalesce into a single :pipeline:`$skip` where the
skip amount is the *sum* of the two initial skip amounts. For example, a
pipeline contains the following sequence:

.. code-block:: javascript

   { $skip: 5 },
   { $skip: 2 }

Then the second :pipeline:`$skip` stage can coalesce into the first
:pipeline:`$skip` stage and result in a single :pipeline:`$skip`
stage where the skip amount ``7`` is the sum of the two initial
limits ``5`` and ``2``.

.. code-block:: javascript

   { $skip: 7 }

.. _agg-match-match-coalescence:

``$match`` + ``$match`` Coalescence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a :pipeline:`$match` immediately follows another
:pipeline:`$match`, the two stages can coalesce into a single
:pipeline:`$match` combining the conditions with an
:expression:`$and`. For example, a pipeline contains the following
sequence:

.. code-block:: javascript

   { $match: { year: 2014 } },
   { $match: { status: "A" } }

Then the second :pipeline:`$match` stage can coalesce into the first
:pipeline:`$match` stage and result in a single :pipeline:`$match`
stage 

.. code-block:: javascript

   { $match: { $and: [ { "year" : 2014 }, { "status" : "A" } ] } }

.. _agg-lookup-unwind-coalescence:

``$lookup`` + ``$unwind`` Coalescence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 3.2

When a :pipeline:`$unwind` immediately follows another
:pipeline:`$lookup`, and the :pipeline:`$unwind` operates on the ``as``
field of the :pipeline:`$lookup`, the optimizer can coalesce the
:pipeline:`$unwind` into the :pipeline:`$lookup` stage. This avoids
creating large intermediate documents.

For example, a pipeline contains the following sequence:

.. code-block:: javascript

   {
     $lookup: {
       from: "otherCollection",
       as: "resultingArray",
       localField: "x",
       foreignField: "y"
     }
   },
   { $unwind: "$resultingArray"}

The optimizer can coalesce the :pipeline:`$unwind` stage into the
:pipeline:`$lookup` stage. If you run the aggregation with ``explain``
option, the ``explain`` output shows the coalesced stage:

.. code-block:: javascript

   {
     $lookup: {
       from: "otherCollection",
       as: "resultingArray",
       localField: "x",
       foreignField: "y",
       unwinding: { preserveNullAndEmptyArrays: false }
     }
   }

Examples
--------

The following examples are some sequences that can take advantage of
both sequence reordering and coalescence. Generally, coalescence occurs
*after* any sequence reordering optimization.

.. _agg-sort-skip-limit-sequence:

``$sort`` + ``$skip`` + ``$limit`` Sequence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A pipeline contains a sequence of :pipeline:`$sort` followed by a
:pipeline:`$skip` followed by a :pipeline:`$limit`:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $skip: 10 },
   { $limit: 5 }

First, the optimizer performs the :ref:`agg-skip-limit-optimization` to
transforms the sequence to the following:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $limit: 15 }
   { $skip: 10 }

The :ref:`agg-skip-limit-optimization` increases the :pipeline:`$limit`
amount with the reordering. See :ref:`agg-skip-limit-optimization` for
details.

The reordered sequence now has :pipeline:`$sort` immediately preceding
the :pipeline:`$limit`, and the pipeline can coalesce the two stages to
decrease memory usage during the sort operation. See
:ref:`agg-sort-limit-coalescence` for more information.

``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` Sequence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A pipeline contains a sequence of alternating :pipeline:`$limit` and
:pipeline:`$skip` stages:

.. code-block:: javascript

   { $limit: 100 },
   { $skip: 5 },
   { $limit: 10 },
   { $skip: 2 }

The :ref:`agg-skip-limit-optimization` reverses the position of the ``{
$skip: 5 }`` and ``{ $limit: 10 }`` stages and increases the limit
amount:

.. code-block:: javascript

   { $limit: 100 },
   { $limit: 15},
   { $skip: 5 },
   { $skip: 2 }

The optimizer then coalesces the two :pipeline:`$limit` stages into a
single :pipeline:`$limit` stage and the two :pipeline:`$skip` stages
into a single :pipeline:`$skip` stage. The resulting sequence is the
following:

.. code-block:: javascript

   { $limit: 15 },
   { $skip: 7 }

See :ref:`agg-limit-limit-coalescence` and
:ref:`agg-skip-skip-coalescence` for details.

.. seealso:: 
   :method:`explain <db.collection.aggregate()>` option in the
   :method:`db.collection.aggregate()`
