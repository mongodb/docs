.. _fts-facet-ref:

=====================================
``facet`` (|fts| Operator)
=====================================

.. default-domain:: mongodb

.. facet::
   :name: genre
   :values: reference

.. meta::
   :keywords: facet collector, grouped results, faceted field, group count, $search stage, $searchMeta stage, SEARCH_META Aggregation, $$SEARCH_META variable
   :description: Use the facet collector to group results by values or ranges in the specified faceted fields and return the count for each of those groups.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Definition
----------

.. expression:: facet

   The ``facet`` collector groups results by values or ranges in the 
   specified faceted fields and returns the count for each of those 
   groups. 
   
   You can use ``facet`` with both the :pipeline:`$search` and 
   :pipeline:`$searchMeta` stages. MongoDB recommends using ``facet`` 
   with the :pipeline:`$searchMeta` stage to retrieve metadata results 
   only for the query. To retrieve metadata results and query results 
   using the :pipeline:`$search` stage, you must use the 
   ``$$SEARCH_META`` aggregation variable. See 
   :ref:`fts-facet-aggregation-variable` to learn more. 
   
   If you define :ref:`storedSource <fts-stored-source-definition>` in your
   :ref:`embeddedDocuments <bson-data-types-embedded-documents>` field
   type definition, you can use :ref:`returnScope <fts-return-scope>`
   with :ref:`returnStoredSource <fts-return-stored-source-option>` to
   facet on nested fields inside an array of objects. Otherwise, you can
   only facet on the root :ref:`embeddedDocuments
   <bson-data-types-embedded-documents>` type field. For an example of
   faceting on: 
  
   - Nested fields inside an array of objects, see :ref:`returnScope
     Example <fts-facet-egs>`.
   - Root ``embeddedDocuments`` type field, see
     :ref:`Facet Query <embedded-document-query-examples>`. 

.. _fts-facet-syntax:

Syntax 
------

``facet`` has the following syntax: 

.. code-block:: javascript
   :copyable: false
   :emphasize-lines: 4-11

   {
     "$searchMeta"|"$search": {
       "index": <index name>, // optional, defaults to "default"
       "facet": {
         "operator": {
           <operator-specifications>
         },
         "facets": {
           <facet-definitions>
         }
       },
       "returnScope": {
         "path": "<embedded-documents-field-to-query>"
       },
       "returnStoredSource": true
     }
   }

.. _fts-facet-fields:

Fields 
------

.. list-table::
   :header-rows: 1
   :widths: 10 20 10 60

   * - Field
     - Type
     - Required?
     - Description

   * - ``facets``
     - document
     - yes
     - :ref:`Information <fts-facet-definition>` for bucketing the data 
       for each facet. You must specify at least one 
       :ref:`fts-facet-definition`.    

   * - ``operator``
     - document
     - no
     - :ref:`Operator <operators-ref>` to use to perform the facet over. 
       If omitted, |fts| performs the facet over all documents in 
       the collection.

.. _fts-facet-definition:

Facet Definition
----------------

The facet definition document contains the facet name and options
specific to a type of facet. |fts| supports the following types of
facets:

- :ref:`fts-string-facet`
- :ref:`fts-numeric-facet`
- :ref:`fts-date-facet`

.. _fts-string-facet:

String Facets 
~~~~~~~~~~~~~

.. |alternative-type| replace:: :ref:`token <bson-data-types-token>`
.. |fts-field-type| replace:: :ref:`stringFacet <bson-data-types-string-facet>`

.. include:: /includes/fts/facts/fact-fts-facet-type-deprecation.rst

String facets allow you to narrow down |fts| results based on the most  
frequent string values in the specified string field. Note that the 
string field must be indexed as :ref:`token
<bson-data-types-token>`. To facet on string fields in embedded
documents, you must also index the parent fields as the :ref:`document
<bson-data-types-document>` type. When you facet on strings in arrays or
embedded documents, |fts| returns facet counts based on the number of
matching root documents. 

.. _fts-string-facet-syntax:

Syntax 
``````
String facets have the following syntax:

.. code-block:: json 
   :emphasize-lines: 8-12

   {
     "$searchMeta": {
       "facet":{
         "operator": {
           <operator-specification>
         },
         "facets": {
           "<facet-name>" : {
             "type" : "string",
             "path" : "<field-path>", 
             "numBuckets" : <number-of-categories>, 
           }
         }
       }
     }
   }

.. _fts-string-facet-options:

Options 
```````

.. list-table::
   :header-rows: 1
   :widths: 10 20 60 10

   * - Option
     - Type
     - Description
     - Required?

   * - ``numBuckets``
     - int
     - Maximum number of facet categories to return in the results. 
       Value must be less than or equal to ``1000``. If specified, 
       |fts| may return fewer categories than requested if the data is 
       grouped into fewer categories than your requested number. If 
       omitted, defaults to ``10``, which means that |fts| will return 
       only the top ``10`` facet categories by count.
     - no

   * - ``path``
     - string
     - Field path to facet on. You can specify a field that is  
       indexed as a :ref:`token <bson-data-types-token>`.
     - yes

   * - ``type``
     - string
     - Type of facet. Value must be ``string``.
     - yes

.. _fts-string-facet-egs:

Example 
```````

.. example::

   The following example uses an index named ``default`` on the 
   ``sample_mflix.movies`` collection. The ``genres`` field in the 
   collection is indexed as the :ref:`token
   <bson-data-types-token>` type and the ``year`` field is
   indexed as the :ref:`number <bson-data-types-number>` type. 

   .. code-block:: json 

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "genres": {
              "type": "token"
            },
            "year": {
              "type": "number"
            }
          }
        }
      }

   The query  uses the :pipeline:`$searchMeta` stage to search the 
   ``year`` field in the ``movies`` collection for movies from 2000 to 
   2015 and retrieve a count of the number of movies in each genre.

   .. io-code-block::
      :copyable: true 

      .. input:: 
         :language: shell 
         :linenos: 

         db.movies.aggregate([ 
           {
             "$searchMeta": {
               "facet": {
                 "operator": {
                   "range": {
                     "path": "year",
                     "gte": 2000,
                     "lte": 2015
                   }
                 },
                 "facets": {
                   "genresFacet": {
                     "type": "string",
                     "path": "genres"
                   }
                 }
               }
             }
           }
         ])

      .. output:: 
         :language: shell 
         :linenos: 
         :visible: false

         [
           {
             count: { lowerBound: Long('12568') },
             facet: {
               genresFacet: {
                 buckets: [
                   { _id: 'Drama', count: Long('7079') },
                   { _id: 'Comedy', count: Long('3689') },
                   { _id: 'Romance', count: Long('1764') },
                   { _id: 'Thriller', count: Long('1584') },
                   { _id: 'Documentary', count: Long('1472') },
                   { _id: 'Action', count: Long('1471') },
                   { _id: 'Crime', count: Long('1367') },
                   { _id: 'Adventure', count: Long('1056') },
                   { _id: 'Horror', count: Long('866') },
                   { _id: 'Biography', count: Long('796') }
                 ]
               }
             }
           }
         ]

   To learn more about these results, see :ref:`fts-facet-results`.

.. _fts-numeric-facet:

Numeric Facets
~~~~~~~~~~~~~~

.. |alternative-type| replace:: :ref:`number <bson-data-types-number>`
.. |fts-field-type| replace:: :ref:`numberFacet <bson-data-types-number-facet>`

.. include:: /includes/fts/facts/fact-fts-facet-type-deprecation.rst

Numeric facets allow you to determine the frequency of numeric values 
in your search results by breaking the results into separate ranges of 
numbers. When you facet on numbers in arrays or embedded documents, |fts| returns facet
counts based on the number of matching root documents. 

.. _fts-numeric-facet-syntax:

Syntax 
``````
Numeric facets have the following syntax:

.. code-block:: json 
   :emphasize-lines: 8-13

   {
     "$searchMeta": {
       "facet":{
         "operator": {
           <operator-specification>
         },
         "facets": {
           "<facet-name>" : {
             "type" : "number",
             "path" : "<field-path>", 
             "boundaries" : <array-of-numbers>, 
             "default": "<bucket-name>"
           }
         }
       }
     }
   }

.. _fts-numeric-facet-options:

Options 
```````

.. list-table::
   :header-rows: 1
   :widths: 10 20 60 10

   * - Option
     - Type
     - Description
     - Required?

   * - ``boundaries``
     - array of numbers
     - List of numeric values, in ascending order, that specify the 
       boundaries for each bucket. You must specify at least two 
       boundaries, which are less than or equal to one thousand (``[2,
       1000]``). Each adjacent pair of values acts as the inclusive
       lower bound and the exclusive upper bound for the bucket. You can
       specify any combination of values of the following :manual:`BSON
       types </reference/bson-types/>`: 

       - 32-bit integer (``int32``)
       - 64-bit integer (``int64``)
       - 64-bit binary floating point (``double``)

     - yes

   * - ``default``
     - string
     - Name of an additional bucket that counts documents returned from 
       the operator that do not fall within the specified boundaries. 
       If omitted, |fts| includes the results of the facet operator 
       that do not fall under a specified bucket also, but doesn't 
       include it in any bucket counts.
     - no

   * - ``path``
     - string
     - Field path to facet on. You can specify a field that is  
       indexed as the :ref:`number <bson-data-types-number>`
       type.
     - yes

   * - ``type``
     - string
     - Type of facet. Value must be ``number``.
     - yes

.. _fts-numeric-facet-egs:

Example 
```````

.. example:: 

   The following example uses an index named ``default`` on the 
   ``sample_mflix.movies`` collection. The ``year`` field in the 
   collection is indexed as the :ref:`number
   <bson-data-types-number>` type.

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "year": [
              {
                "type": "number"
              }
            ]
          }
        }
      }

   The query  uses the :pipeline:`$searchMeta` stage to search the 
   ``year`` field in the ``movies`` collection for movies between  
   the years ``1980`` to ``2000`` and retrieve metadata results for the 
   query. The query specifies three buckets: 
   
   - ``1980``, inclusive lower bound for this bucket
   - ``1990``, exclusive upper bound for the ``1980`` bucket and 
     inclusive lower bound for this bucket
   - ``2000``, exclusive upper bound for the ``1990`` bucket

   The query also specifies a ``default`` bucket named ``other`` to 
   retrieve results of the query that don't fall under any of the 
   specified boundaries.

   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos:  

         db.movies.aggregate([
           {
             "$searchMeta": {
               "facet": {
                 "operator": {
                  "range": {
                     "path": "year",
                     "gte": 1980,
                     "lte": 2000
                   }
                 },
                 "facets": {
                   "yearFacet": {
                     "type": "number",
                     "path": "year",
                     "boundaries": [1980,1990,2000],
                     "default": "other"
                   }
                 }
               }
             }
           }
         ])

      .. output:: 
         :language: shell 
         :linenos: 
         :visible: false

         [
           {
             count: { lowerBound: Long('6095') },
             facet: {
               yearFacet: {
                 buckets: [
                   { _id: 1980, count: Long('1956') },
                   { _id: 1990, count: Long('3558') },
                   { _id: 'other', count: Long('581') }
                 ]
               }
             }
           }
         ]

   To learn more about these results, see :ref:`fts-facet-results`.

.. _fts-date-facet:

Date Facets
~~~~~~~~~~~

.. |alternative-type| replace:: :ref:`date <bson-data-types-date>`
.. |fts-field-type| replace:: :ref:`dateFacet <bson-data-types-date-facet>`

.. include:: /includes/fts/facts/fact-fts-facet-type-deprecation.rst

Date facets allow you to narrow down search results based on a 
date. When you facet on dates in arrays or embedded documents, |fts| returns facet counts
based on the number of matching root documents.

.. _fts-date-facet-syntax:

Syntax 
``````

Date facets have the following syntax:

.. code-block:: json 
   :emphasize-lines: 8-13

   {
     "$searchMeta": {
       "facet":{
         "operator": {
           <operator-specification>
         },
         "facets": {
           "<facet-name>" : {
             "type" : "date",
             "path" : "<field-path>", 
             "boundaries" : <array-of-dates>, 
             "default": "<bucket-name>"
           }
         }
       }
     }
   }

.. _fts-date-facet-options:

Options 
```````

.. list-table::
   :header-rows: 1
   :widths: 10 20 60 10

   * - Option
     - Type
     - Description
     - Required?

   * - ``boundaries``
     - array of numbers
     - List of date values that specify the boundaries for each bucket. 
       You must specify: 
       
       - At least two boundaries, which are less than or equal to one
         thousand (``[2, 1000]``)
       - Values in ascending order, with the earliest date first
       
       Each adjacent pair of values acts as the inclusive lower bound
       and the exclusive upper bound for the bucket.  
     - yes

   * - ``default``
     - string
     - Name of an additional bucket that counts documents returned from 
       the operator that do not fall within the specified boundaries. 
       If omitted, |fts| includes the results of the facet operator 
       that do not fall under a specified bucket also, but |fts| 
       doesn't include these results in any bucket counts.
     - no

   * - ``path``
     - string
     - Field path to facet on. You can specify a field that is  
       indexed as a :ref:`date <bson-data-types-date>` type. 
     - yes

   * - ``type``
     - string
     - Type of facet. Value must be ``date``.
     - yes

.. _fts-date-facet-egs:

Example 
```````

.. example:: 

   The following example uses an index named ``default`` on the 
   ``sample_mflix.movies`` collection. The ``released`` field in the 
   collection is indexed as the :ref:`date <bson-data-types-date>`
   type. 

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "released": [
              {
                "type": "date"
              }
            ]
          }
        }
      }

   The query  uses the :pipeline:`$searchMeta` stage to search the 
   ``released`` field in the ``movies`` collection for movies between  
   the years ``2000`` to ``2015`` and retrieve metadata results for the 
   query string. The query specifies four buckets: 
   
   - ``2000-01-01``, inclusive lower bound for this bucket
   - ``2005-01-01``, exclusive upper bound for the ``2000-01-01`` 
     bucket and inclusive lower bound for this bucket
   - ``2010-01-01``, exclusive upper bound for the ``2005-01-01`` 
     bucket and inclusive lower bound for this bucket
   - ``2015-01-01``, exclusive upper bound for the ``2010-01-01`` bucket

   The query also specifies a ``default`` bucket named ``other`` to 
   retrieve results of the query that don't fall under any of the 
   specified boundaries.

   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos: 

         db.movies.aggregate([
           {
             "$searchMeta": {
               "facet": {
                 "operator": {
                   "range": {
                     "path": "released",
                     "gte": ISODate("2000-01-01T00:00:00.000Z"),
                     "lte": ISODate("2015-01-31T00:00:00.000Z")
                   }
                 },
                 "facets": {
                   "yearFacet": {
                     "type": "date",
                     "path": "released",
                     "boundaries": [ISODate("2000-01-01"), ISODate("2005-01-01"), ISODate("2010-01-01"), ISODate("2015-01-01")],
                     "default": "other"
                   }
                 }
               }
             }
           }
         ])

      .. output:: 
         :language: shell 
         :linenos: 
         :visible: false

         [
           {
             count: { lowerBound: Long('11922') },
             facet: {
               yearFacet: {
                 buckets: [
                   {
                     _id: ISODate('2000-01-01T00:00:00.000Z'),
                     count: Long('3028')
                   },
                   {
                     _id: ISODate('2005-01-01T00:00:00.000Z'),
                     count: Long('3953')
                   },
                   {
                     _id: ISODate('2010-01-01T00:00:00.000Z'),
                     count: Long('4832')
                   },
                   { _id: 'other', count: Long('109') }
                 ]
               }
             }
           }
         ]

   To learn more about these results, see :ref:`fts-facet-results`.

.. _fts-facet-type-differences:

Comparing Field Types for Facet
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The updated |fts| field types provide improved functionality to support faceting
compared to the outdated types (``stringFacet``, ``numberFacet``, ``dateFacet``). 
The following table outlines the key differences in functionality:

.. list-table::
   :header-rows: 1
   :widths: 15 15 15 55

   * - Facet Category
     - Updated Field Type
     - Outdated Facet Type
     - Key Differences

   * - String
     - :ref:`token <bson-data-types-token>`
     - :ref:`stringFacet <bson-data-types-string-facet>` (outdated)
     - **Normalizer Support**: The ``token`` type supports normalizers
       that transform facet buckets. For example, with ``normalizer: lowercase``,
       "ADIDAS" and "adidas" count towards the same bucket while
       ``stringFacet`` treats them as separate buckets.

   * - Numeric
     - :ref:`number <bson-data-types-number>`
     - :ref:`numberFacet <bson-data-types-number-facet>` (outdated)
     - **Array Support**: The ``number`` type considers values within
       arrays for facet buckets. For example, a document with an array value ``[0, 10]``
       counts towards both buckets ``[1, 5]`` and ``[6, 10]`` while
       ``numberFacet`` ignores array values completely.

   * - Date
     - :ref:`date <bson-data-types-date>`
     - :ref:`dateFacet <bson-data-types-date-facet>` (outdated)
     - **Array Support**: The ``date`` type considers values within
       arrays for facet buckets. For example, an array value with dates
       can contribute to multiple date range buckets while ``dateFacet``
       ignores array values completely.

.. note::

   When both the outdated and updated field types are
   defined for the same field, the outdated facet types take precedence.
   For example, if both ``token`` and ``stringFacet`` are defined for a
   field, the facet calculation uses the ``stringFacet`` mapping.

.. _fts-facet-results:

Facet Results 
-------------

For a facet query, |fts| returns a mapping of the defined facet names 
to an array of buckets for that facet in the results. The facet result 
document contains the ``buckets`` option, which is an array of 
resulting buckets for the facet. Each facet bucket document in the 
array has the following fields: 

.. list-table:: 
   :header-rows: 1
   :widths: 10 15 75

   * - Option 
     - Type
     - Description 

   * - ``_id``
     - object 
     - Unique identifier that identifies this facet bucket. This value 
       matches the type of data that is being faceted on.

   * - ``count`` 
     - int 
     - Count of documents in this facet bucket. To learn more about the 
       ``count`` field, see :ref:`count-ref`.

.. _fts-facet-multi-select:

Multi-Select Facets
-------------------

|fts| allows you to view and select multiple buckets within the same
facet simultaneously. Typically, selecting a bucket within a facet
filters search results according to that selection and alters counts
for all facets.

.. example::

   Suppose an index definition for the ``sample_airbnb.listings``
   collection specifies facets for the following fields:

   - ``cancellation_policy``
   - ``room_type``
   - ``accommodates``

   The ``cancellation_policy`` facet has the following buckets:

   - ``flexible``
   - ``moderate``
   - ``strict_14_with_grace_period``
   - ``super_strict_30``
   - ``super_strict_60``

   Each have their own result counts. When you search for the
   ``moderate`` ``cancellation_policy``, the counts for the four other
   buckets go to ``0``. Additionally, the counts for buckets in the
   ``room_type`` and ``accommodates`` facets reduce to the number of results
   in each bucket that also have a ``flexible``
   ``cancellation_policy``.

In scenarios where you need more granular control of how facets affect
search result counts, enable multi-select faceting with the
``doesNotAffect`` property in your faceted queries. These facets still
filter results, but the query doesn't alter their result counts.

.. example::
   
   Consider a query against the ``sample_airbnb.listings`` collection
   for documents with a ``moderate`` ``cancellation_policy``. If you
   specify a ``doesNotAffect`` value of ``cancellation_policy``, the
   counts for buckets in the ``cancellation_policy`` facet don't
   change, but the result counts for the buckets of other facets
   reduce to the number of results in each bucket which also have a
   ``moderate`` ``cancellation_policy``.

   For more information, see the :ref:`Multi-Select Faceting example
   <fts-facet-egs>`.

Finally, for use cases with many facets, it can be useful to limit
which other filters affect a given facet. You can do this by
specifying any facet in the ``doesNotAffect`` property of any filter,
including facets on other fields. This allows you to observe at a
glance which selections narrow options more or less quickly.

.. example::

   Consider a query against the ``sample_airbnb.listings`` collection
   for documents with an ``accommodates`` value of ``3``. If you
   specify a ``doesNotAffect`` value of ``cancellation_policy``, the
   result counts for the ``room_type`` buckets reduce to the number of
   results in each bucket which also accommodate ``3`` people, but the
   result counts for the buckets in ``cancellation_policy`` are
   unaffected.

   For more information, see the :ref:`Inter-Facet Filter Exclusion
   example <fts-facet-egs>`.

.. _fts-facet-aggregation-variable: 

``SEARCH_META`` Aggregation Variable
------------------------------------

.. include:: /includes/fts/facts/fact-fts-search-meta-variable.rst

.. _fts-facet-limitations:

Limitations 
-----------

The following limitations apply: 

- You can run facet queries on a single field only. You can't run 
  facet queries on groups of fields.

.. _fts-facet-egs:

Examples 
--------

The following examples use the :ref:`sample data <sample-data>`. The
metadata results example demonstrates how to run a
:pipeline:`$searchMeta` query with ``facet`` to retrieve only the
metadata in the results. The metadata and search results example
demonstrates how to run a :pipeline:`$search` query with ``facet`` and
the ``$SEARCH_META`` aggregation variable to retrieve both the search
and metadata results. The ``returnScope`` example demonstrates how to
facet on nested fields in an array of objects dynamically indexed using
the ``embeddedDocuments`` type.

.. collapsible::
   :heading: Metadata Results Example
   :sub_heading: Complete the previous steps in the tutorial and install dependencies
   :expanded: false

   The index definition on the ``sample_mflix.movies`` collection
   specifies the following for the fields to index:

   .. list-table:: 
      :header-rows: 1
      :widths: 30 70

      * - Field Name
        - Data Type

      * - ``directors`` 
        - :ref:`token <bson-data-types-token>`

      * - ``year`` 
        - :ref:`number <bson-data-types-number>` 

      * - ``released`` 
        - :ref:`date <bson-data-types-date>`

   .. code-block:: json 

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "directors": {
              "type": "token"
            },
            "year": {
              "type": "number"
            },
            "released": {
              "type": "date"
            }
          }
        }
      }

   The following query searches for movies released between January 
   01, 2000 and January 31, 2015. It requests metadata on the 
   ``directors`` and ``year`` field.

   .. io-code-block:: 
      :copyable: true

      .. input:: 
        :language: json 
        :linenos:

        db.movies.aggregate([
          {
            "$searchMeta": {
              "facet": {
                "operator": {
                  "range": {
                    "path": "released",
                    "gte": ISODate("2000-01-01T00:00:00.000Z"),
                    "lte": ISODate("2015-01-31T00:00:00.000Z")
                  }
                },
                "facets": {
                  "directorsFacet": {
                    "type": "string",
                    "path": "directors",
                    "numBuckets" : 7
                  },
                  "yearFacet" : {
                    "type" : "number",
                    "path" : "year",
                    "boundaries" : [2000,2005,2010, 2015]
                  }
                }
              }
            }
          }
        ])

      .. output:: 
        :language: shell 
        :linenos:
        :visible: false

        [
          {
            count: { lowerBound: Long('11922') },
            facet: {
              yearFacet: {
                buckets: [
                  { _id: 2000, count: Long('3064') },
                  { _id: 2005, count: Long('4035') },
                  { _id: 2010, count: Long('4553') }
                ]
              },
              directorsFacet: {
                buckets: [
                  { _id: 'Takashi Miike', count: Long('26') },
                  { _id: 'Johnnie To', count: Long('20') },
                  { _id: 'Steven Soderbergh', count: Long('18') },
                  { _id: 'Michael Winterbottom', count: Long('16') },
                  { _id: 'Ridley Scott', count: Long('15') },
                  { _id: 'Tyler Perry', count: Long('15') },
                  { _id: 'Clint Eastwood', count: Long('14') }
                ]
              }
            }
          }
        ]

   The results show a count of the following in the 
   ``sample_mflix.movies`` collection: 

   - Number of movies from the year 2000, inclusive lower bound, to 
     2015, exclusive upper bound, that |fts| returned for the query
   - Number of movies for each director that |fts| returned for the 
     query

   To learn more about these results, see :ref:`fts-facet-results`.

.. collapsible::
   :heading: Metadata and Search Results Example
   :sub_heading: Search using $search and retrieve both search and metadata results using $$SEARCH_META variable.
   :expanded: false

   The index definition on the ``sample_mflix.movies`` collection
   specifies the following for the fields to index:

   .. list-table:: 
      :header-rows: 1
      :widths: 30 70

      * - Field Name
        - Data Type

      * - ``genres`` 
        - :ref:`token <bson-data-types-token>`

      * - ``released`` 
        - :ref:`date <bson-data-types-date>`

   .. code-block:: json 

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "genres": {
              "type": "token"
            },
            "released": {
              "type": "date"
            }
          }
        }
      }

   The following query searches for movies released near July 01, 
   1999 using the :pipeline:`$search` stage. The query includes a 
   :pipeline:`$facet` stage to process the input documents using 
   the following sub-pipeline stages:

   - :pipeline:`$project` stage to exclude all fields in the 
     documents except the ``title`` and ``released`` fields in the ``docs`` output field  

   - :pipeline:`$limit` stage to do the following: 
  
     - Limit the ``$search`` stage output to ``2`` documents  
     - Limit the output to ``1`` document in the ``meta`` output field 

     .. note:: 

        The limit must be small for the results to fit in a 16 MB 
        document.

   - :pipeline:`$replaceWith` stage to include the metadata results 
     stored in the ``$$SEARCH_META`` variable in the ``meta`` output 
     field
        
   The query also includes a :pipeline:`$set` stage to add the 
   ``meta`` field.

   .. note:: 

      To see the metadata results for the following query, |fts| 
      must return documents that match the query.

   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos: 

         db.movies.aggregate([
          {
            "$search": {
              "facet": {
                "operator": {
                  "near": {
                    "path": "released",
                    "origin": ISODate("1999-07-01T00:00:00.000+00:00"),
                    "pivot": 7776000000
                  }
                },
                "facets": {
                  "genresFacet": {
                    "type": "string",
                    "path": "genres"
                  }
                }
              }
            }
          },
          { "$limit": 2 },
          {
            "$facet": {
              "docs": [ 
                { "$project":
                  {
                    "title": 1,
                    "released": 1
                  }
                }
              ],
              "meta": [
                {"$replaceWith": "$$SEARCH_META"},
                {"$limit": 1}
              ]
            }
          },
          {
            "$set": {
              "meta": {
                "$arrayElemAt": ["$meta", 0]
              }
            }
          }
         ])

      .. output:: 
         :language: shell 
         :linenos:
         :visible: false

         [
          {
            docs: [
              {
                _id: ObjectId('573a1393f29313caabcde1ae'),
                title: 'Begone Dull Care',
                released: ISODate('1999-07-01T00:00:00.000Z')
              },
              {
                _id: ObjectId('573a13a9f29313caabd2048a'),
                title: 'Fara'                released: ISODate('1999-07-01T00:00:00.000Z')
              }
            ],
            meta: {
              count: { lowerBound: Long('20878') },
              facet: {
                genresFacet: {
                  buckets: [
                    { _id: 'Drama', count: Long('12149') },
                    { _id: 'Comedy', count: Long('6436') },
                    { _id: 'Romance', count: Long('3274') },
                    { _id: 'Crime', count: Long('2429') },
                    { _id: 'Thriller', count: Long('2400') },
                    { _id: 'Action', count: Long('2349') },
                    { _id: 'Adventure', count: Long('1876') },
                    { _id: 'Documentary', count: Long('1755') },
                    { _id: 'Horror', count: Long('1432') },
                    { _id: 'Biography', count: Long('1244') }
                  ]
                }
              }
            }
          }
         ]

   To learn more about these results, see :ref:`fts-facet-results`.

.. collapsible::
   :heading: returnScope Example
   :sub_heading: Search using facet and facet on child fields in embeddedDocuments.
   :expanded: false

   The index definition on the ``sample_training.companies`` collection
   indexes the ``funding_rounds`` field as the :ref:`embeddedDocuments
   <bson-data-types-embedded-documents>` type. It dynamically indexes
   all fields in the ``funding_rounds`` array of objects and stores the
   ``raised_currency_code`` and ``raised_amount`` fields in the
   ``funding_rounds`` array of objects using the :ref:`storedSource
   <fts-stored-source-definition>` option.   

   .. code-block:: json 

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "funding_rounds": {
              "type": "embeddedDocuments",
              "dynamic": true,
              "storedSource": {
                "include": [
                  "raised_currency_code",
                  "raised_amount"
                ]
              }
            }
          }
        }
      }

   The following query:

   - Uses the :ref:`text-ref` to search for funds raised in ``USD`` .
   - Uses :ref:`returnScope <fts-return-scope>` options to set the
     query context to the ``embeddedDocuments`` field named
     ``funding_rounds``. To use ``returnScope``, the query:
     
     - Specifies the :ref:`returnStoredSource
       <fts-return-stored-source-option>` option, which is required, to
       return the stored source fields. 
   
   - Facets on the ``raised_amount`` field in the ``funding_rounds``
     array of objects. The query specifies three buckets:

     - 5000000, inclusive lower bound for this bucket
     - 5250000, exclusive upper bound for the 5000000 bucket and
       inclusive lower bound for this bucket 
     - 5500000, exclusive upper bound for the 5250000 bucket

   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos: 

         db.companies.aggregate([
          {
            "$searchMeta": {
              "returnStoredSource": true,
              "returnScope": {
                "path": "funding_rounds"
              },
              "facet": {
                "operator": {
                  "text": {
                    "path": "funding_rounds.raised_currency_code",
                    "query": "USD"
                  }
                },
                "facets": {
                  "raisedAmountFacet": {
                    "type": "number",
                    "path": "funding_rounds.raised_amount",
                    "boundaries": [5000000, 5250000, 5500000]
                  }
                }
              }
            }
          }
         ])

      .. output:: 
         :language: shell 
         :linenos:
         :visible: false

         [
           {
             count: { lowerBound: Long('5329') },
             facet: {
               raisedAmountFacet: {
                 buckets: [
                   { _id: 5000000, count: Long('251') },
                   { _id: 5250000, count: Long('32') }
                 ]
               }
             }
           }
         ]

   In the preceding |fts| results, the facet counts are based on the
   embedded child documents and not the parents.

.. collapsible::
   :heading: Multi-Select Faceting Example
   :sub_heading: Search with doesNotAffect for more granular control over facet filtering.
   :expanded: false

   The following index definition on the
   ``sample_airbnb.listingsAndReviews`` collection automatically
   indexes all dynamically indexable fields and configures the
   ``cancellation_policy``, ``room_type``, and ``price`` fields for
   faceted search.

   .. code-block:: json 

      {
	"mappings": {
	  "dynamic": false,
	  "fields": {
	    "cancellation_policy": {
	      "type": "token"
	    },
	    "room_type": {
	      "type": "token"
	    },
	    "accommodates": {
	      "type": "number"
	    }
	  }
	}
      }

   The following query uses the :pipeline:`$searchMeta` stage to perform the
   following actions:

   - Facet on the ``cancellation_policy``, ``roomType`` and ``accommodates``
     fields.

     The ``cancellation_policy`` facet has the following buckets:

     - ``"strict_14_with_grace_period"``
     - ``"moderate"``
     - ``"flexible"``
     - ``"super_strict_30"``
     - ``"super_strict_60"``

     The ``room_type`` facet has the following buckets:

     - ``"Entire home/apt"``
     - ``"Private room"``
     - ``"Shared room"``

     The query breaks the ``accommodates`` facet into buckets for:

     - ``1``, inclusive lower bound for this bucket
     - ``2``, exclusive upper bound for the ``1`` bucket and
       inclusive lower bound for this bucket.
     - ``4``, exclusive upper bound for the ``2`` bucket and
       inclusive lower bound for this bucket.
     - ``8``, exclusive upper bound for the ``4`` bucket

   - Perform a :ref:`compound-ref` search for listings that *must*
     contain the text ``new york city`` in the ``description`` and
     *filters* the results for listings with a ``moderate``
     ``cancellation_policy``. The ``doesNotAffect`` setting ensures
     that filtering by a ``moderate`` ``cancellation_policy`` doesn't
     alter the counts of other buckets in the facet; the counts for
     ``"strict_14_with_grace_period"``, ``"flexible"``,
     ``"super_strict_30"``, and ``"super_strict_60"`` are non-zero
     values.

   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos: 

         db.listingsAndReviews.aggregate([
	   {
	     $searchMeta: {
	       facet: {
		 facets: {
		   accommodatesFacet: {
		     path: "accommodates",
		     type: "number",
		     boundaries: [1,2,4,8],
		   },		 
		   cancellationFacet: {
		     path: "cancellation_policy",
		     type: "string",
		   },
		   roomTypeFacet: {
		     path: "room_type",
		     type: "string",
		   }
		 },
		 operator: {
		   compound: {
		     must: [
		       {
			 text: {
			   path: "description",
			   query: "new york city",
			 },
		       },
		     ],
		     filter: [
		       {
			 equals: {
			   path: "cancellation_policy",
			   value: "moderate",
			   doesNotAffect:
			     "cancellationFacet",
			 },
		       },
		     ],
		   },
		 },
	       },
	     }
	   },
	 ]

      .. output:: 
         :language: shell 
         :linenos:
         :visible: false

         [
           {
             count: { lowerBound: Long('531') },
             facet: {
               accomodatesFacet: {
                 buckets: [
                   { _id: "1", count: Long('25') },
                   { _id: "2", count: Long('270') },
		   { _id: "4", count: Long('204') },
                 ]
               },	       	     
               cancellationFacet: {
                 buckets: [
		   { _id: "strict_14_with_grace_period", count: Long('849') },
                   { _id: "moderate", count: Long('531') },		   
                   { _id: "flexible", count: Long('380') },
                   { _id: "super_strict_60", count: Long('25') }
                   { _id: "super_strict_30", count: Long('380') }
                 ]
               },
               roomTypeFacet: {
                 buckets: [
                   { _id: "Entire home/apt", count: Long('369') },
                   { _id: "Private room", count: Long('159') },
		   { _id: "Shared room", count: Long('3') },
                 ]
               }
             }
           }
         ]

   Observe that the counts for buckets in ``cancellationFacet`` are
   not reduced to zero despite the query filtering on a value of
   ``moderate``.

.. collapsible::
   :heading: Inter-Facet Filter Exclusion Example 
   :sub_heading: Search with doesNotAffect on a facet other than the queried field.
   :expanded: false

   The following index definition on the ``sample_airbnb.listingsAndReviews``
   collection indexes the ``cancellation_policy``, ``room_type``, and
   ``price`` fields, enabling faceted search on them.

   .. code-block:: json 

      {
	"mappings": {
	  "dynamic": true,
	  "fields": {
	    "cancellation_policy": {
	      "type": "token"
	    },
	    "room_type": {
	      "type": "token"
	    },
	    "accommodates": {
	      "type": "number"
	    }
	  }
	}
      }   

   The following query:

   - Searches for listings that include the text ``new york city`` in
     their ``description`` and which have a ``cancellation_policy`` of
     ``moderate``.     
   - Facets on the ``cancellation_policy``, ``roomType`` and ``accommodates``
     fields.

     Each of the ``cancellation_policy`` and ``roomType`` facets have
     three buckets, corresponding to the three unique values of these
     fields across the collection. The query breaks the ``accommodates``
     facet into buckets for:

     - ``1``, inclusive lower bound for this bucket
     - ``2``, exclusive upper bound for the ``1`` bucket and
       inclusive lower bound for this bucket.
     - ``4``, exclusive upper bound for the ``2`` bucket and
       inclusive lower bound for this bucket.
     - ``8``, exclusive upper bound for the ``4`` bucket

   - Sets the ``doesNotAffect`` property in the ``equals`` operator of
     the ``compound.filter`` to ``accommodatesFacet``. This excludes
     the buckets within the ``accommodates`` facet from
     filtering. As a result, filtering on the ``moderate``
     ``cancellation_policy`` reduces the counts of other buckets in
     the ``cancellation_policy`` facet to ``0``, and reduces the
     counts of buckets in the ``roomType`` facet, but the counts of
     buckets in the ``accommodates`` facet are unchanged. This allows
     you to compare the impact of filtering on different facets.
     
   .. io-code-block:: 
      :copyable: true 

      .. input:: 
         :language: json 
         :linenos: 

         db.listingsAndReviews.aggregate([
	   {
	     $searchMeta: {
	       facet: {
		 facets: {
		   accommodatesFacet: {
		     path: "accommodates",
		     type: "number",
		     boundaries: [1,2,4,8],
		   },		 
		   cancellationFacet: {
		     path: "cancellation_policy",
		     type: "string",
		   },
		   roomTypeFacet: {
		     path: "room_type",
		     type: "string",
		   }
		 },
		 operator: {
		   compound: {
		     must: [
		       {
			 text: {
			   path: "description",
			   query: "new york city",
			 },
		       },
		     ],
		     filter: [
		       {
			 equals: {
			   path: "cancellation_policy",
			   value: "moderate",
			   doesNotAffect:
			     "accommodatesFacet",
			 },
		       },
		     ],
		   },
		 },
	       },
	     },
	   },
	 ]

      .. output:: 
         :language: shell 
         :linenos:
         :visible: false

         [
           {
             count: { lowerBound: Long('531') },
             facet: {
               accomodatesFacet: {
                 buckets: [
                   { _id: "1", count: Long('25') },
                   { _id: "2", count: Long('270') },
		   { _id: "4", count: Long('204') },
                 ]
               },	       	     
               cancellationFacet: {
                 buckets: [
                   { _id: "flexible", count: Long('XXX') },
                   { _id: "moderate", count: Long('531') },
		   { _id: "strict_14_with_grace_period", count: Long('XXX') },
                 ]
               },
               roomTypeFacet: {
                 buckets: [
                   { _id: "Entire home/apt", count: Long('369') },
                   { _id: "Private room", count: Long('159') },
		   { _id: "Shared room", count: Long('3') },
                 ]
               }
             }
           }
         ]

Continue Learning 
-----------------

To learn more, see :ref:`facet-tutorial`.

You can learn more about :ref:`fts-facet-ref` in |fts| with our
:ref:`course <facet-tutorial-course>` and :ref:`video
<facet-tutorial-video>`.

.. _facet-tutorial-course:

Learn with Courses
~~~~~~~~~~~~~~~~~~

To learn more about using facets in |fts|, take Unit 9 of the
:mdbu-course:`Intro To MongoDB Course on MongoDB University 
</courses/mongodb-atlas-search>`. The 1.5 hour unit includes an overview 
of |fts| and lessons on creating |fts| indexes, running 
:pipeline:`$search` queries using compound operators,
and grouping results using ``facet``.

.. _facet-tutorial-video:

Learn by Watching
~~~~~~~~~~~~~~~~~

Follow along with this video to learn about how you can create and use a
numeric and string :ref:`fts-facet-ref` in your query to group results
and retrieve a count of the results in the groups.

*Duration: 11 Minutes*

.. video:: https://youtu.be/90icEZ8fzJE
