ref: projection-path-collision-embedded-document-full
content: |

   You cannot project an embedded document with any of the embedded 
   document's fields.

   For example, consider a collection ``inventory`` with documents that
   contain a ``size`` field:
  
   .. code-block:: javascript
      :copyable: false

      { ..., size: { h: 10, w: 15.25, uom: "cm" }, ... }

   The following operation fails with a ``Path collision`` error because it 
   attempts to project both ``size`` document and the ``size.uom`` field:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( {}, { size: 1, "size.uom": 1 } ) 

   In previous versions, lattermost projection between the embedded
   documents and its fields determines the projection:

   - If the projection of the embedded document comes after any and all
     projections of its fields, MongoDB projects the embedded document.
     For example, the projection document ``{ "size.uom": 1, size: 1 }``
     produces the same result as the projection document ``{ size: 1 }``.

   - If the projection of the embedded document comes before the
     projection any of its fields, MongoDB projects the specified field or
     fields. For example, the projection document ``{ "size.uom": 1, size:
     1, "size.h": 1 }`` produces the same result as the projection
     document ``{ "size.uom": 1, "size.h": 1 }``.
---
ref: projection-path-collision-slice-embedded-field-full
content: |

   |findoperation| projection cannot contain both a :projection:`$slice` of an 
   array and a field embedded in the array. 

   For example, consider a collection ``inventory`` that contains an array
   field ``instock``:
  
   .. code-block:: javascript
      :copyable: false

      { ..., instock: [ { warehouse: "A", qty: 35 }, { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ], ... }

   The following operation fails with a ``Path
   collision`` error:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( {}, { "instock": { $slice: 1 }, "instock.warehouse": 0 } ) 

   In previous versions, the projection applies both projections and
   returns the first element (``$slice: 1``) in the ``instock`` array
   but suppresses the ``warehouse`` field in the projected element.
   Starting in MongoDB 4.4, to achieve the same result, use the
   :method:`db.collection.aggregate()` method with two separate
   :pipeline:`$project` stages.
   
---
ref: projection-dollar-prefixed-field-full
content: |

   The |findoperation| projection cannot project a field that starts with 
   ``$`` with the exception of the :ref:`DBRef fields <dbref-explanation>`.

   For example, the following operation is invalid:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( {}, { "$instock.warehouse": 0, "$item": 0, "detail.$price": 1 } )

---
ref: projection-positional-operator-slice-full
content: |

   |findoperation| projection cannot include :projection:`$slice` projection 
   expression as part of a :projection:`$` projection expression. 
   
   For example, the following operation is invalid:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( { "instock.qty": { $gt: 25 } }, { "instock.$": { $slice: 1 } } ) 

   In previous versions, MongoDB returns the first element
   (``instock.$``) in the ``instock`` array that matches the query
   condition; i.e. the positional projection ``"instock.$"`` takes
   precedence and the ``$slice:1`` is a no-op. The ``"instock.$": {
   $slice: 1 }`` does not exclude any other document field.
   
---
ref: projection-empty-field-full
content: |
   
   |findoperation| projection cannot include a projection of an empty field 
   name. 

   For example, the following operation is invalid:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( { }, { "": 0 } ) 

   In previous versions, MongoDB treats the inclusion/exclusion of the
   empty field as it would the projection of non-existing fields.
---
ref: projection-values-table
content: |

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Projection
        - Description

      * - ``<field>: <1 or true>``

        - Specifies the inclusion of a field. If you specify a non-zero 
          integer for the projection value, the operation treats the 
          value as ``true``.

      * - ``<field>: <0 or false>``

        - Specifies the exclusion of a field.

      * - ``"<field>.$": <1 or true>``

        - Uses the :projection:`$` array projection operator to return 
          the first element that matches the query condition on the
          array field. If you specify a non-zero integer for the 
          projection value, the operation treats the value as ``true``. 
          
          Not available for :ref:`views <views-landing-page>`.

      * - ``<field>: <array projection>``

        - Uses the array projection operators (:projection:`$elemMatch`,
          :projection:`$slice`) to specify the array elements to
          include. 
          
          Not available for :ref:`views <views-landing-page>`.

      * - ``<field>: <$meta expression>``

        - Uses the :expression:`$meta` operator expression to specify 
          the inclusion of available :expression:`per-document metadata
          <$meta>`. 
          
          Not available for :ref:`views <views-landing-page>`.


      * - ``<field>: <aggregation expression>``

        - Specifies the value of the projected field.

          With the use of :ref:`aggregation expressions and syntax 
          <aggregation-expressions>`, including the use of literals and 
          aggregation variables, you can project new fields or project existing 
          fields with new values.
       
          - If you specify a non-numeric, non-boolean literal (such as a
            literal string or an array or an operator expression) for
            the projection value, the field is projected with the new
            value, for example:

            - ``{ field: [ 1, 2, 3, "$someExistingField" ] }``
            - ``{ field: "New String Value" }``
            - ``{ field: { status: "Active", total: { $sum: "$existingArray" } } }``

          - To project a literal value for a field, use the
            :expression:`$literal` aggregation expression; for example:

            - ``{ field: { $literal: 5 } }``
            - ``{ field: { $literal: true } }``
            - ``{ field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }`` 

---
ref: projection-values-table-without-meta
content: |

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Projection
        - Description

      * - ``<field>: <1 or true>``

        - Specifies the inclusion of a field. If you specify a non-zero 
          integer for the projection value, the operation treats the 
          value as ``true``.

      * - ``<field>: <0 or false>``

        - Specifies the exclusion of a field.

      * - ``"<field>.$": <1 or true>``

        - Uses the :projection:`$` array projection operator to return 
          the first element that matches the query condition on the
          array field. If you specify a non-zero integer for the 
          projection value, the operation treats the value as ``true``.
          
          Not available for :ref:`views <views-landing-page>`.

      * - ``<field>: <array projection>``

        - Uses the array projection operators (:projection:`$elemMatch`,
          :projection:`$slice`) to specify the array elements to
          include. 
          
          Not available for :ref:`views <views-landing-page>`.

      * - ``<field>: <aggregation expression>``

        - Specifies the value of the projected field.

          With the use of :ref:`aggregation
          expressions and syntax <aggregation-expressions>`, including the
          use of literals and aggregation variables, you can project new
          fields or project existing fields with new values.
       
          - If you specify a non-numeric, non-boolean literal (such as a
            literal string or an array or an operator expression) for
            the projection value, the field is projected with the new
            value, for example:

            - ``{ field: [ 1, 2, 3, "$someExistingField" ] }``
            - ``{ field: "New String Value" }``
            - ``{ field: { status: "Active", total: { $sum: "$existingArray" } } }``

          - To project a literal value for a field, use the
            :expression:`$literal` aggregation expression, for example:

            - ``{ field: { $literal: 5 } }``
            - ``{ field: { $literal: true } }``
            - ``{ field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }`` 

---
ref: projection-embedded-field-format
content: |
   For fields in an embedded documents, you can specify the field using
   either:

   - :ref:`dot notation <document-dot-notation-embedded-fields>`, for example ``"field.nestedfield": <value>``

   - nested form, for example ``{ field: { nestedfield: <value> } }``

---
ref: projection-language-consistency-admonition
content: |

   .. important:: Language Consistency


      As part of making :method:`~db.collection.find` and
      :method:`~db.collection.findAndModify` projection consistent with
      aggregation's :pipeline:`$project` stage,
   
      - The :method:`~db.collection.find` and
        :method:`~db.collection.findAndModify` projection can accept
        :ref:`aggregation expressions and syntax
        <aggregation-expressions>`.

      - MongoDB enforces additional restrictions with regards to
        projections. See :limit:`Projection Restrictions` for details.
---
ref: projection-elemMatch-projection-field-order
content: |
 
    Regardless of the ordering of the fields in the document, the 
    :projection:`$elemMatch` projection of an existing field returns 
    the field after the other existing field inclusions.

    For example, consider a ``players`` collection with the following document:

    .. code-block:: javascript

       db.players.insertOne( { 
          name: "player1", 
          games: [ { game: "abc", score: 8 }, { game: "xyz", score: 5 } ], 
          joined: new Date("2020-01-01"),
          lastLogin: new Date("2020-05-01")
       } )

    The following projection returns the ``games`` field
    after the other existing fields included in the projection even though
    in the document, the field is listed before ``joined`` and
    ``lastLogin`` fields:

    .. code-block:: javascript

        db.players.find( {}, { games: { $elemMatch: { score: { $gt: 5 } } }, joined: 1, lastLogin: 1 } )

    That is, the operation returns the following document:

    .. code-block:: javascript 
       :copyable: false

       { 
          "_id" : ObjectId("5edef64a1c099fff6b033977"),
          "joined" : ISODate("2020-01-01T00:00:00Z"),
          "lastLogin" : ISODate("2020-05-01T00:00:00Z"),
          "games" : [ { "game" : "abc", "score" : 8 } ]
       }

---
ref: projection-positional-operator-path
content: |

   The :projection:`$` projection operator can only appear at the end of the 
   field path, for example ``"field.$"`` or ``"fieldA.fieldB.$"``.
   
   For example, the following operation is invalid:

   .. code-block:: javascript
      :copyable: false

      db.inventory.find( { }, { "instock.$.qty": 1 } )

   To resolve, remove the component of the field path that follows the
   :projection:`$` projection operator.
 
---
ref: projection-slice-operator-inclusion
content: |

   The :projection:`$slice` projection of an array in an nested document no 
   longer returns the other fields in the nested document when the projection 
   is part of an inclusion projection. 
   
   For example, consider a collection ``inventory`` with documents that
   contain a ``size`` field:
  
   .. code-block:: javascript
      :copyable: false

      { item: "socks", qty: 100, details: { colors: [ "blue", "red" ], sizes: [ "S", "M", "L"] } }
      
   The following operation projects the ``_id`` field (by default), the 
   ``qty`` field, and the ``details`` field with just the specified slice 
   of the ``colors`` array:

   .. code-block:: javascript

      db.inventory.find( { }, { qty: 1, "details.colors": { $slice: 1 } } )
   
   That is, the operation returns the following document:
   
   .. code-block:: javascript
      :copyable: false
      
      { "_id" : ObjectId("5ee92a6ec644acb6d13eedb1"), "qty" : 100, "details" : { "colors" : [ "blue" ] } }
      
   If the :projection:`$slice` projection is part of an exclusion
   projection, the operation continues to return the other fields in
   the nested document. That is, the following projection is an
   exclusion projection. The projection excludes the ``_id`` field and
   the elements in the ``colors`` array that fall outside the specified
   slice and returns all other fields.

   .. code-block:: javascript

      db.inventory.find( { }, { _id: 0, "details.colors": { $slice: 1 } } )
   
   .. code-block:: javascript
      :copyable: false

      { "item" : "socks", "qty" : 100, "details" : { "colors" : [ "blue" ], "sizes" : [ "S", "M", "L" ] } }

   The :projection:`$slice` projection by itself is considered an exclusion.
   
   In previous versions, the :projection:`$slice` projection also
   include the other fields in the nested document regardless of
   whether the projection is an inclusion or an exclusion.

---
ref: projection-id-field
content: |

   The ``_id`` field is included in the returned documents by default unless
   you explicitly specify ``_id: 0`` in the projection to suppress the field.

---
ref: projection-inclusion-exclusion
content: |
   
   A ``projection`` *cannot* contain *both* include and exclude
   specifications, with the exception of the ``_id`` field:

   - In projections that *explicitly include* fields, the ``_id`` field is
     the only field that you can *explicitly exclude*.

   - In projections that *explicitly excludes* fields, the ``_id`` field
     is the only field that you can *explicitly include*; however, the
     ``_id`` field is included by default.

...
