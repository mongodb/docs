# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2015
# This file is distributed under the same license as the mongodb-manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-30 14:28-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/perform-two-phase-commits.txt:3
# fa6aff97fe35453386e332d159bdb540
msgid "Perform Two Phase Commits"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:8
# 5bc2fd26520c42b9a9b9f72658faeaf6
msgid "Synopsis"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:10
# f0cc0caf78c14b208c75f01b0018d353
msgid "This document provides a pattern for doing multi-document updates or \"multi-document transactions\" using a two-phase commit approach for writing data to multiple documents. Additionally, you can extend this process to provide a :ref:`rollback-like <2-phase-commits-rollback>` functionality."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:17
# e97caa778d154e26aa626f1033b75943
msgid "Background"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:19
# 60f904c81ac74661a023188dd50b73a0
msgid "Operations on a single :term:`document` are always atomic with MongoDB databases; however, operations that involve multiple documents, which are often referred to as \"multi-document transactions\", are not atomic. Since documents can be fairly complex and contain multiple \"nested\" documents, single-document atomicity provides the necessary support for many practical use cases."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:26
# 23a60badfc68438fafd16726703c2abb
msgid "Despite the power of single-document atomic operations, there are cases that require multi-document transactions. When executing a transaction composed of sequential operations, certain issues arise, such as:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:30
# 96feb90ea5a7403e8aa948b58f92d05c
msgid "Atomicity: if one operation fails, the previous operation within the transaction must \"rollback\" to the previous state (i.e. the \"nothing,\" in \"all or nothing\")."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:34
# 4404e980694547ed9acfe6d33ea0bb0a
msgid "Consistency: if a major failure (i.e. network, hardware) interrupts the transaction, the database must be able to recover a consistent state."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:38
# b396deb6fa0249a7954b728cfcef8d68
msgid "For situations that require multi-document transactions, you can implement two-phase commit in your application to provide support for these kinds of multi-document updates. Using two-phase commit ensures that data is consistent and, in case of an error, the state that preceded the transaction is :ref:`recoverable <2-phase-commits-rollback>`. During the procedure, however, documents can represent pending data and states."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:48
# f1393e76965d4815b3cea29d494012e5
msgid "Because only single-document operations are atomic with MongoDB, two-phase commits can only offer transaction-*like* semantics. It is possible for applications to return intermediate data at intermediate points during the two-phase commit or rollback."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:54
# 1b21dec007b44b77833a1ac490a4cd41
msgid "Pattern"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:57
# 008aaf29f2fe41de8dc9b4d12aa37e55
msgid "Overview"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:59
# c8246a507a094d2e9d5469c0d979debf
msgid "Consider a scenario where you want to transfer funds from account ``A`` to account ``B``. In a relational database system, you can subtract the funds from ``A`` and add the funds to ``B`` in a single multi-statement transaction. In MongoDB, you can emulate a two-phase commit to achieve a comparable result."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:65
# 9782e66267c1446dba688d79471a3db1
msgid "The examples in this tutorial use the following two collections:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:67
# 6c909be84aca4f42b74cf9a96cc8f008
msgid "A collection named ``accounts`` to store account information."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:69
# 0b3b46d323f840d59ad3db3b236ee1b5
msgid "A collection named ``transactions`` to store information on the fund transfer transactions."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:73
# 8c3f34b75248484bbb3a98fed23bfc42
msgid "Initialize Source and Destination Accounts"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:75
# 227a5bf68d1f406abf66496644569c9c
msgid "Insert into the ``accounts`` collection a document for account ``A`` and a document for account ``B``."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:87
# 24746520fd32466b8232159b778090d8
msgid "The operation returns a :method:`BulkWriteResult()` object with the status of the operation. Upon successful insert, the :method:`BulkWriteResult()` has :data:`~BulkWriteResult.nInserted` set to ``2`` ."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:95
# 6c90419fdc1e425b8dc93193dc3dbd55
msgid "Initialize Transfer Record"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:97
# 4def08d81a2945658850c27e98d7f43a
msgid "For each fund transfer to perform, insert into the ``transactions`` collection a document with the transfer information. The document contains the following fields:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:101
# f62050951648437b94d69cf2f3ac489f
msgid "``source`` and ``destination`` fields, which refer to the ``_id`` fields from the ``accounts`` collection,"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:104
# 508393aa258b49439d927f03e91b0f22
msgid "``value`` field, which specifies the amount of transfer affecting the ``balance`` of the ``source`` and ``destination`` accounts,"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:107
# a08aef7c6dad41ef8ed848f2207ce26a
msgid "``state`` field, which reflects the current state of the transfer. The ``state`` field can have the value of ``initial``, ``pending``, ``applied``, ``done``, ``canceling``, and ``canceled``."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:111
# 1e567e7e3a824d2d8ce0ff295390c5a0
msgid "``lastModified`` field, which reflects last modification date."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:113
# 5e5c2ec158a048788d74d32983af273b
msgid "To initialize the transfer of ``100`` from account ``A`` to account ``B``, insert into the ``transactions`` collection a document with the transfer information, the transaction ``state`` of ``\"initial\"``, and the ``lastModified`` field set to the current date:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:124
# f90c886c36744f5ab10888b7036f54ae
msgid "The operation returns a :method:`WriteResult()` object with the status of the operation. Upon successful insert, the :method:`WriteResult()` object has :data:`~WriteResult.nInserted` set to ``1``."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:129
# 84662ec5c7214ec6b339961617138971
msgid "Transfer Funds Between Accounts Using Two-Phase Commit"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:136
# afe4ef468c2c475da02d9ff5cc67c5c3
msgid "Recovering from Failure Scenarios"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:138
# 8c5c4118861c4576a58197bda45d5402
msgid "The most important part of the transaction procedure is not the prototypical example above, but rather the possibility for recovering from the various failure scenarios when transactions do not complete successfully. This section presents an overview of possible failures and provides steps to recover from these kinds of events."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:145
# d80f25395df3401a9220f6fc6fcc8bf9
msgid "Recovery Operations"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:147
# a73d4c90df89458398f56d985dbee8b1
msgid "The two-phase commit pattern allows applications running the sequence to resume the transaction and arrive at a consistent state. Run the recovery operations at application startup, and possibly at regular intervals, to catch any unfinished transactions."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:152
# 148fa9bfa24444389e87bcad3b5c6c11
msgid "The time required to reach a consistent state depends on how long the application needs to recover each transaction."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:155
# 084e9e54086a45b686f43d9d8939c1fd
msgid "The following recovery procedures uses the ``lastModified`` date as an indicator of whether the pending transaction requires recovery; specifically, if the pending or applied transaction has not been updated in the last 30 minutes, the procedures determine that these transactions require recovery. You can use different conditions to make this determination."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:163
#: ../source/tutorial/perform-two-phase-commits.txt:216
# 45e84b42ffe5418abd00ccf6af353d5c
# c9b20f8d1c844419a382704865044786
msgid "Transactions in Pending State"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:165
# 18f97327ff914239b1de37bb94c3519b
msgid "To recover from failures that occur after step \"`Update transaction state to pending.`_\" but before \"`Update transaction state to applied.`_\" step, retrieve from the ``transactions`` collection a pending transaction for recovery:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:177
# d49c5a69d03f4e338433466849fd3b91
msgid "And resume from step \"`Apply the transaction to both accounts.`_\""
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:180
#: ../source/tutorial/perform-two-phase-commits.txt:207
# 1c5b61d0270249e684b4600a55893253
# b9ebca6da5af4d25bb21d141eb673f3d
msgid "Transactions in Applied State"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:182
# a3e7d98a2ddb42e2add83884e3b15b8d
msgid "To recover from failures that occur after step \"`Update transaction state to applied.`_\" but before \"`Update transaction state to done.`_\" step, retrieve from the ``transactions`` collection an applied transaction for recovery:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:194
# 05a66f4369244eee8875ca291ea359b3
msgid "And resume from \"`Update both accounts' list of pending transactions.`_\""
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:200
# 1e9936290e7a40c2bd74b0773cdf9728
msgid "Rollback Operations"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:202
# eca41bcaf9884f78a8131c25bcfed54c
msgid "In some cases, you may need to \"roll back\" or undo a transaction; e.g., if the application needs to \"cancel\" the transaction or if one of the accounts does not exist or stops existing during the transaction."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:209
# 8656a1ec3a30401c8d647d44a9cd9f25
msgid "After the \"`Update transaction state to applied.`_\" step, you should **not** roll back the transaction. Instead, complete that transaction and :ref:`create a new transaction <initialize-transfer-record>` to reverse the transaction by switching the values in the source and the destination fields."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:218
# bcdee5028b6c4a098eaa77d808bbca4a
msgid "After the \"`Update transaction state to pending.`_\" step, but before the \"`Update transaction state to applied.`_\" step, you can rollback the transaction using the following procedure:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:227
# 5aa7bb15b98f4417b097124f5b9343dc
msgid "Multiple Applications"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:229
# b8f90a1867354be5b9b586560ca50a26
msgid "Transactions exist, in part, so that multiple applications can create and run operations concurrently without causing data inconsistency or conflicts. In our procedure, to update or retrieve the transaction document, the update conditions include a condition on the ``state`` field to prevent reapplication of the transaction by multiple applications."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:236
# 28fdff359c4443a88ee23462fb153366
msgid "For example, applications ``App1`` and ``App2`` both grab the same transaction, which is in the ``initial`` state. ``App1`` applies the whole transaction before ``App2`` starts. When ``App2`` attempts to perform the \"`Update transaction state to pending.`_\" step, the update condition, which includes the ``state: \"initial\"`` criterion, will not match any document, and the :data:`~WriteResult.nMatched` and :data:`~WriteResult.nModified` will be ``0``. This should signal to ``App2`` to go back to the first step to restart the procedure with a different transaction."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:246
# 96ce7412dab34f29bd11f1e3a36849ff
msgid "When multiple applications are running, it is crucial that only one application can handle a given transaction at any point in time. As such, in addition including the expected state of the transaction in the update condition, you can also create a marker in the transaction document itself to identify the application that is handling the transaction. Use :method:`~db.collection.findAndModify()` method to modify the transaction and get it back in one step:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:268
# ca15d4aa298e493c8a15dfec28c5e9a4
msgid "Amend the transaction operations to ensure that only applications that match the identifier in the ``application`` field apply the transaction."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:271
# dd2606daf7124b358e9e0e58432c47b3
msgid "If the application ``App1`` fails during transaction execution, you can use the :ref:`recovery procedures <2-phase-commits-recovery>`, but applications should ensure that they \"own\" the transaction before applying the transaction. For example to find and resume the pending job, use a query that resembles the following:"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:293
# ec11e2220314468f8f800d74e2fc7238
msgid "Using Two-Phase Commits in Production Applications"
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:295
# 12600c7d980d44d887d109b81e85d662
msgid "The example transaction above is intentionally simple. For example, it assumes that it is always possible to roll back operations to an account and that account balances can hold negative values."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:299
# 31da3299668f4aaaab2a1d0d8709e0a5
msgid "Production implementations would likely be more complex. Typically, accounts need information about current balance, pending credits, and pending debits."
msgstr ""

#: ../source/tutorial/perform-two-phase-commits.txt:303
# 2a4f3f0b0dd24b6d892ce1f08aebe0d4
msgid "For all transactions, ensure that you use the appropriate level of :doc:`write concern </core/write-concern>` for your deployment."
msgstr ""

