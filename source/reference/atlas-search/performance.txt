.. _perf-ref:

==========================
Performance Considerations
==========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

|fts| runs a new process, called ``mongot``, alongside
the :binary:`mongod <bin.mongod>` process on each host in your
|service| cluster. ``mongot`` maintains all
|fts| indexes on collections in your |service| databases.
The amount of CPU, memory, and disk resources ``mongot`` consumes
depends on several factors, including your index configuration
and the complexity of your queries.

Index Size and Configuration
----------------------------

When you :ref:`create <ref-create-index>` an |fts| index, the default
configuration sets field mapping to :ref:`dynamic
<static-dynamic-mappings>`, which means that all the data in your
collection is actively added to your |fts| index. Other options
such as enabling highlights can also result in your index taking up more
disk space. You can reduce the size and performance footprint of your
|fts| index by:

- Specifying a custom :ref:`index definition
  <ref-index-definitions>` to narrow the amount and type of data that is
  indexed.

- Setting the ``store`` option to ``false`` when specifying a :ref:`string
  <bson-data-types-string>` type in an index definition.

Creating and Updating an Atlas Search Index
-------------------------------------------

Creating an |fts| index is resource-intensive. The performance of your
|service| cluster may be impacted while the index builds.

If you :ref:`change the configuration <ref-edit-index>` of an |fts|
index it must rebuild, which also consumes resources and may affect
database performance.

.. note::

   Do not run queries against an |fts| index while it is building. Ensure
   that all nodes in your cluster have the :ref:`Active
   <node-status-ref>` status before running |fts| queries.

Query Operators and Query Complexity
------------------------------------

The complexity level of |fts| queries and the type of :ref:`operators
<fts-operators>` used can affect database performance. Highly
complex queries with :ref:`multiple clauses <compound-ref>` are
resource-intensive, as are queries which use the :ref:`regex
<term-ref>` (regular expression) operator.

|fts| queries are ranked by :ref:`score <scoring-ref>`. Queries that
return a large number of results are more computationally intensive
because they must keep track of all the scores for the result set.

Performance Monitoring
----------------------

You can :ref:`monitor <monitor-cluster-metrics>` your |service|
cluster and view charts with performance statistics on the |service|
:guilabel:`Metrics` tab. These metrics can help you see how |fts|
queries and index building affect your cluster's performance.

.. note::

   If your cluster's resources are stretched or near the
   limits of acceptable performance, consider :doc:`upgrading
   </scale-cluster>` to a larger cluster tier before implementing
   |fts| functionality.

``$match`` Aggregation Stage Usage
----------------------------------

Using a :manual:`$match </reference/operator/aggregation/match/>`
aggregation pipeline stage after a :ref:`$search <query-syntax-ref>`
stage can drastically slow down query results. If possible, design
your ``$search`` query so that all necessary filtering occurs in the
``$search`` stage to remove the need for a ``$match`` stage. The
:ref:`$compound <compound-ref>` |fts| operator is helpful for queries
that require multiple filtering operations.

``$sort`` Aggregation Stage Usage 
---------------------------------

Using a :manual:`$sort </reference/operator/aggregation/sort/>`
aggregation pipeline stage after a :ref:`$search <query-syntax-ref>` 
stage can drastically slow down query results. If possible, design
your ``$search`` query so that all necessary sorting occurs in the 
``$search`` stage to remove the need for a ``$sort`` stage. In 
general, the |fts| :ref:`$compound <compound-ref>` operator is helpful 
for queries that require multiple sorting operations. To sort 
documents based on a numeric, date, or geo field, consider using 
the |fts| :ref:`$near <near-ref>` operator. 
