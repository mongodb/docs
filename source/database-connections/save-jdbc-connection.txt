
.. _rm-save-jdbc-connection:

=============================================
Save a JDBC Connection for Snapshot Migration
=============================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

:ref:`Some databases <jdbc-databases>` are not fully supported in Relational
Migrator, but can be used through a JDBC connection for snapshot migration
jobs. To add one of these databases as a relational connection, modify your
``user.properties`` :ref:`file <file-location>`.


Steps
-----

To save a JDBC connection:

.. procedure::
   :style:  normal

   .. step:: Download the database JDBC driver and dependencies, and add them to the CLASSPATH

      The JAR file and all required libraries must be present on the CLASSPATH.

   .. step:: Open the Relational Migrator user.properties file

      This file is located at:

      .. include:: /includes/fact-user-properties-location.rst

   .. step:: Uncomment and set migrator.connector.source.<CONNECTOR_ID> connection properties

      Duplicate this section if you need to add multiple JDBC connections.

      .. code-block:: ini
         :copyable: true

         ## An example of a custom JDBC-compatible connector
         ## a CONNECTOR_ID is a unique identifier in the context this user.properties file
         migrator.connector.source.<CONNECTOR_ID>.display.name: <connector name for the UI> if not specified, the no-space camel-case version of the CONNECTOR_ID will be used
         migrator.connector.source.<CONNECTOR_ID>.connector.class: "io.debezium.connector.jdbc.source.JdbcSourceConnector"
         migrator.connector.source.<CONNECTOR_ID>.database.hostname: <database hostname> (if needed; could be a stub)
         migrator.connector.source.<CONNECTOR_ID>.tableid.use.catalog: <true/false> whether the table path should contain catalog (database) name
         migrator.connector.source.<CONNECTOR_ID>.tableid.use.schema: <true/false> whether the table path should contain schema name
         migrator.connector.source.<CONNECTOR_ID>.querying.escape.char.opening: <opening escaping character(-s) for SQL queries>
         migrator.connector.source.<CONNECTOR_ID>.querying.escape.char.closing: <closing escaping character(-s) for SQL queries>
         migrator.connector.source.<CONNECTOR_ID>.querying.boolean.true.value: <DB-specific boolean "true" value> could be either "true" or "1", depending on database
         migrator.connector.source.<CONNECTOR_ID>.querying.boolean.false.value: <DB-specific boolean "false" value>
         migrator.connector.source.<CONNECTOR_ID>.querying.special.characters: <characters that must be escaped if present in SQL query>
         migrator.connector.source.<CONNECTOR_ID>.queries.get.database.name: <SQL query used to obtain database name> could use the "databaseName" interpolation variable like so: "$${databaseName}"
         migrator.connector.source.<CONNECTOR_ID>.queries.get.date: <SQL query used to obtain current timestamp>
         migrator.connector.source.<CONNECTOR_ID>.queries.ping: <SQL query used to check if a connection is active> could be as simple as querying current timestamp
         migrator.connector.source.<CONNECTOR_ID>.queries.select.fields.from.collection: <SQL query used to retrieve values for specific columns for a specific table> uses the following interpolation variables: "fields", "schemaName", "collectionName"
         migrator.connector.source.<CONNECTOR_ID>.table.path.format.string: <a format string for table path> must be escaped; can use the following interpolation variables: "databaseName", "schemaName", "tableName"
         migrator.connector.source.<CONNECTOR_ID>.identifier.format.string: <a format string for an identifier> uses the "identifier" interpolation variable
         migrator.connector.source.<CONNECTOR_ID>.select.format.string: <SQL query used to retrieve all values for specific table with a specified LIMIT and WHERE clauses> uses the following interpolation variables: "limitClause", "databaseName", "schemaName", "tableName", "whereClause"
         migrator.connector.source.<CONNECTOR_ID>.limit.format.string: <a format string for the SQL LIMIT clause> uses the "snapshotRowCount" interpolation variable
         migrator.connector.source.<CONNECTOR_ID>.alias.format.string: <a format string for the aliases in SQL queries> uses the following interpolation variables: "original", "alias"
         migrator.connector.source.<CONNECTOR_ID>.schemacrawler.exclude.schemas.pattern: <regular expression for excluded database schemas>
         migrator.connector.source.<CONNECTOR_ID>.schemacrawler.include.schemas.pattern: <regular expression for included database schemas> could be as simple as ".+"
         migrator.connector.source.<CONNECTOR_ID>.schemacrawler.include.imported.schema.pattern: <a format string for schema path used by SchemaCrawler> uses the following interpolation variables: "databaseName", "schemaName"
         migrator.connector.source.<CONNECTOR_ID>.table.include.filter.pattern: <a format string for table name used by SchemaCrawler> must not be escaped; uses the following interpolation variables: "databaseName", "schemaName", "tableName"
         migrator.connector.source.<CONNECTOR_ID>.jdbc.driver.class: <JDBC driver class name> must be fully qualified
         migrator.connector.source.<CONNECTOR_ID>.jdbc.driver.download.link: <a link to the JDBC driver or the instructions on how to get one>

      Use a unique string to identify each connection. For example, if you
      are using a JDBC connection to a Yugabyte database, you could use
      ``migrator.connector.source.YUGABYTE``.

      .. list-table::
         :header-rows: 1
   
         * - migrator.connector.source.<CONNECTOR_ID> Setting
           - Description
           
         * - display.name
           - The name displayed in the Relational Migrator UI when selecting
             a relational database connection. If unset, Relational Migrator 
             uses a camel-case version of the ``CONNECTOR_ID`` string.
           
         * - connector.class
           - The fully qualified JDBC connector class name

         * - database.hostname
           - 

         * - tableid.use.catalog
           - 

         * - tableid.use.schema
           - 

         * - querying.escape.char.opening
           - 

         * - querying.escape.char.closing
           - 

         * - querying.boolean.true.value
           - 

         * - querying.boolean.false.value
           - 

         * - querying.special.characters
           - 

         * - queries.get.database.name
           - 

         * - queries.get.date
           - 

         * - queries.ping
           - 

         * - queries.select.fields.from.collection
           - 

         * - table.path.format.string
           - 

         * - identifier.format.string
           - 

         * - select.format.string
           - 

         * - limit.format.string
           - 

         * - alias.format.string
           - 

         * - schemacrawler.exclude.schemas.pattern
           - 

         * - schemacrawler.include.schemas.pattern
           - 

         * - schemacrawler.include.imported.schema.pattern
           - 

         * - table.include.filter.pattern
           - 

         * - jdbc.driver.class
           - The fully qualified JDBC driver class name

         * - jdbc.driver.download.link
           - The URL to the JDBC driver download page. If Relational Migrator
             doesn't find the ``jdbc.driver.class`` on the CLASSPATH, it
             displays a popup in the UI with this link.

   .. step:: Save and close the file, and restart Relational Migrator.


Example Configuration
---------------------

.. tabs::

   .. tab:: Yugabyte
      :tabid: example-jdbc-yugabyte

      migrator.connector.source.YUGABYTE.display.name: Yugabyte
      migrator.connector.source.YUGABYTE.tableid.use.catalog: false
      migrator.connector.source.YUGABYTE.tableid.use.schema: true
      migrator.connector.source.YUGABYTE.querying.escape.char.opening: "
      migrator.connector.source.YUGABYTE.querying.escape.char.closing: "
      migrator.connector.source.YUGABYTE.querying.boolean.true.value: true
      migrator.connector.source.YUGABYTE.querying.boolean.false.value: false
      migrator.connector.source.YUGABYTE.querying.special.characters: '".
      migrator.connector.source.YUGABYTE.queries.get.database.name: select current_database()
      migrator.connector.source.YUGABYTE.queries.get.date: select CURRENT_TIMESTAMP
      migrator.connector.source.YUGABYTE.queries.ping: select CURRENT_TIMESTAMP
      migrator.connector.source.YUGABYTE.queries.select.fields.from.table: SELECT $${fields} FROM "$${schemaName}"."$${tableName}"
      migrator.connector.source.YUGABYTE.table.include.filter.pattern: \"$${schemaName}\".\"$${tableName}\"
      migrator.connector.source.YUGABYTE.table.path.format.string: "$${schemaName}"."$${tableName}"
      migrator.connector.source.YUGABYTE.identifier.format.string: "$${identifier}"
      migrator.connector.source.YUGABYTE.select.format.string: SELECT * FROM "$${schemaName}"."$${tableName}" $${whereClause} $${limitClause}
      migrator.connector.source.YUGABYTE.limit.format.string: LIMIT $${snapshotRowCount}
      migrator.connector.source.YUGABYTE.alias.format.string:
      migrator.connector.source.YUGABYTE.database.hostname: dummy
      migrator.connector.source.YUGABYTE.jdbc.driver.class: com.yugabyte.Driver
      migrator.connector.source.YUGABYTE.jdbc.driver.download.link: https://docs.yugabyte.com/preview/drivers-orms/java/yugabyte-jdbc-reference/