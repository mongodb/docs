=====================
CMS: Storing Comments
=====================

Problem
=======

In your content management system (CMS), you would like to store
user-generated comments on the various types of content you generate.

Solution Overview
=================

Rather than describing the One True Way to implement comments in this
solution, this use case explores different options and the trade-offs with
each. The three major designs discussed here are:

One document per comment
   This provides the greatest degree of
   flexibility, as it is relatively straightforward to display the
   comments as either threaded or chronological. There are also no
   restrictions on the number of comments that can participate in a
   discussion.
All comments embedded
   In this design, all the comments are
   embedded in their parent document, whether that be a blog article,
   news story, or forum topic. This can be the highest performance
   design, but is also the most restrictive, as the display format of
   the comments is tied to the embedded structure. There are also
   potential problems with extremely active discussions where the total
   data (topic data + comments) exceeds the 16MB limit of MongoDB
   documents.
Hybrid design
   Here, you store comments separately from their
   parent topic, but aggregate comments together into a few
   documents, each containing many comments.

Another decision that needs to be considered in designing a commenting
system is whether to support threaded commenting (explicit replies to a
parent comment). This threaded comment support
decision will also be discussed below.

Schema design: One Document Per Comment
=======================================

A comment in the one document per comment format might have a structure
similar to the following:

.. code-block:: javascript

    {
        _id: ObjectId(...),
        discussion_id: ObjectId(...),
        slug: '34db',
        posted: ISODateTime(...),
        author: { id: ObjectId(...), name: 'Rick' },
        text: 'This is so bogus ... '
    }

The format above is really only suitable for chronological display of
commentary. It maintains a reference to the discussion in which this
comment participates, a url-friendly ``slug`` to identify it, ``posted`` time
and ``author``, and the comment's ``text``. If you want to support threading in
this format, you need to maintain some notion of hierarchy in the comment
model as well:

.. code-block:: javascript

    {
        _id: ObjectId(...),
        discussion_id: ObjectId(...),
        parent_id: ObjectId(...),
        slug: '34db/8bda',
        full_slug: '34db:2012.02.08.12.21.08/8bda:2012.02.09.22.19.16',
        posted: ISODateTime(...),
        author: { id: ObjectId(...), name: 'Rick' },
        text: 'This is so bogus ... '
    }

Here, the schema includes some extra information into the document that
represents this document's position in the hierarchy. In addition to
maintaining the ``parent_id`` for the comment, the slug format has been modified
and a new field ``full_slug`` has been added. The slug is now a path
consisting of the parent's slug plus the comment's unique slug portion.
The ``full_slug`` is also included to facilitate sorting documents in a
threaded discussion by posting date.

Operations: One Comment Per Document
====================================

Here, some common operations that you might need for your CMS are
described in the context of the single comment per document schema. All of the
following examples use the Python programming language and the ``pymongo``
MongoDB driver, but implementations would be similar in other languages as well.

Post a New Comment
------------------

In order to post a new comment in a chronologically ordered (unthreaded)
system, all you need to do is ``insert()``:

.. code-block:: python

    slug = generate_psuedorandom_slug()
    db.comments.insert({
        'discussion_id': discussion_id,
        'slug': slug,
        'posted': datetime.utcnow(),
        'author': author_info,
        'text': comment_text })

In the case of a threaded discussion, there is a bit more work to do in
order to generate a "pathed" ``slug`` and ``full_slug``:

.. code-block:: python

    posted = datetime.utcnow()

    # generate the unique portions of the slug and full_slug
    slug_part = generate_psuedorandom_slug()
    full_slug_part = slug_part + ':' + posted.strftime(
        '%Y.%m.%d.%H.%M.%S')

    # load the parent comment (if any)
    if parent_slug:
        parent = db.comments.find_one(
            {'discussion_id': discussion_id, 'slug': parent_slug })
        slug = parent['slug'] + '/' + slug_part
        full_slug = parent['full_slug'] + '/' + full_slug_part
    else:
        slug = slug_part
        full_slug = full_slug_part

    # actually insert the comment
    db.comments.insert({
        'discussion_id': discussion_id,
        'slug': slug, 'full_slug': full_slug,
        'posted': posted,
        'author': author_info,
        'text': comment_text })

View the (Paginated) Comments for a Discussion
----------------------------------------------

To actually view the comments in the non-threaded design, you need merely
to select all comments participating in a discussion, sorted by ``posted``:

.. code-block:: python

    cursor = db.comments.find({'discussion_id': discussion_id})
    cursor = cursor.sort('posted')
    cursor = cursor.skip(page_num * page_size)
    cursor = cursor.limit(page_size)

Since the ``full_slug`` embeds both hierarchical information via the path
and chronological information, you can use a simple sort on the
``full_slug`` property to retrieve a threaded view:

.. code-block:: python

    cursor = db.comments.find({'discussion_id': discussion_id})
    cursor = cursor.sort('full_slug')
    cursor = cursor.skip(page_num * page_size)
    cursor = cursor.limit(page_size)

Index Support
~~~~~~~~~~~~~

In order to efficiently support the queries above, you should maintain
two compound indexes, one on (``discussion_id``, ``posted``), and the other on
(``discussion_id``, ``full_slug``):

.. code-block:: python

    >>> db.comments.ensure_index([
    ...    ('discussion_id', 1), ('posted', 1)])
    >>> db.comments.ensure_index([
    ...    ('discussion_id', 1), ('full_slug', 1)])

Note that you must ensure that the final element in a compound index is
the field by which you are sorting to ensure efficient performance of
these queries.

Retrieve a Comment Via Slug ("Permalink")
-----------------------------------------

Suppose you wish to directly retrieve a comment (e.g. *not* requiring
paging through all preceeding pages of commentary). In this case, you'd
simply use the ``slug``:

.. code-block:: python

    comment = db.comments.find_one({
        'discussion_id': discussion_id,
        'slug': comment_slug})

You can also retrieve a sub-discussion (a comment and all of its
descendants recursively) by performing a prefix query on the ``full_slug``
field:

.. code-block:: python

    subdiscussion = db.comments.find_one({
        'discussion_id': discussion_id,
        'full_slug': re.compile('^' + re.escape(parent_slug)) })
    subdiscussion = subdiscussion.sort('full_slug')

Index Support
~~~~~~~~~~~~~

Since you already have indexes on (``discussion_id``, ``full_slug``) necessary to
support retrieval of subdiscussions, all you need to add here is an index on
(``discussion_id``, ``slug``) to efficiently support retrieval of a comment by
'permalink':

.. code-block:: python

    >>> db.comments.ensure_index([
    ...    ('discussion_id', 1), ('slug', 1)])

Schema Design: All Comments Embedded
====================================

In this design, you wish to embed an entire discussion within its topic
document, be it a blog article, news story, or discussion thread. A
topic document, then, might look something like the following:

.. code-block:: python

    {
        _id: ObjectId(...),
        ... lots of topic data ...
        comments: [
            { posted: ISODateTime(...),
              author: { id: ObjectId(...), name: 'Rick' },
              text: 'This is so bogus ... ' },
           ... ]
    }

The format above is really only suitable for chronological display of
commentary. The comments are embedded in chronological order, with their
posting date, author, and text. Note that, since you're storing the
comments in sorted order, there is no longer need to maintain a slug per
comment. If you wanted to support threading in the embedded format, you'd need
to embed comments within comments:

.. code-block:: python

    {
        _id: ObjectId(...),
        ... lots of topic data ...
        replies: [
            { posted: ISODateTime(...),
              author: { id: ObjectId(...), name: 'Rick' },


              text: 'This is so bogus ... ',
              replies: [
                  { author: { ... }, ... },
           ... ]
    }

Here, there is a ``replies`` property added to each comment which can hold
sub-comments and so on. One thing in particular to note about the
embedded document formats is you give up some flexibility when embedding
the comments, effectively "baking in" the decisions made about
the proper display format. If you (or your users) someday wish to switch
from chronological or vice-versa, this schema makes such a migration
quite expensive.

In popular discussions, you also might have an issue with document size.
If you have a particularly avid discussion, for example, it might
outgrow the 16MB limit that MongoDB places on document size. You can also
run into scaling issues, particularly in the threaded design, as
documents need to be frequently moved on disk as they outgrow the space
allocated to them.

Operations: All Comments Embedded
=================================

Here, some common operations that you might need for your CMS are
described in the context of embedded comment schema. Once again, the examples are
in Python. Note that, in all the cases below,
there is no need for additional indexes since all the operations are
intra-document, and the document itself (the "discussion") is retrieved
by its ``_id`` field, which is automatically indexed by MongoDB anyway.

Post a new comment
------------------

In order to post a new comment in a chronologically ordered (unthreaded)
system, you need the following ``update()``:

.. code-block:: python

    db.discussion.update(
        { 'discussion_id': discussion_id },
        { '$push': { 'comments': {
            'posted': datetime.utcnow(),
            'author': author_info,
            'text': comment_text } } } )

Note that since you used the ``$push`` operator, all the comments will be
inserted in their correct chronological order. In the case of a threaded
discussion, there si a good bit more work to do. In order to reply to a
comment, the code below assumes that it has access to the 'path' to the comment
you're replying to as a list of positions:

.. code-block:: python

    if path != []:
        str_path = '.'.join('replies.%d' % part for part in path)
        str_path += '.replies'
    else:
        str_path = 'replies'
    db.discussion.update(
        { 'discussion_id': discussion_id },
        { '$push': {
            str_path: {
                'posted': datetime.utcnow(),
                'author': author_info,
                'text': comment_text } } } )

Here, you first construct a field name of the form
``replies.0.replies.2...`` as ``str_path`` and then use that to ``$push`` the new
comment into its parent comment's ``replies`` property.

View the (Paginated) Comments for a Discussion
-----------------------------------------------

To actually view the comments in the non-threaded design, you need to use
the ``$slice`` operator:

.. code-block:: python

    discussion = db.discussion.find_one(
        {'discussion_id': discussion_id},
        { ... some fields relevant to your page from the root discussion ...,
          'comments': { '$slice': [ page_num * page_size, page_size ] }
        })

If you wish to view paginated comments for the threaded design, you need
to retrieve the whole document and paginate in your application:

.. code-block:: python

    discussion = db.discussion.find_one({'discussion_id': discussion_id})

    def iter_comments(obj):
        for reply in obj['replies']:
            yield reply
            for subreply in iter_comments(reply):
                yield subreply

    paginated_comments = itertools.slice(
        iter_comments(discussion),
        page_size * page_num,
        page_size * (page_num + 1))

Retrieve a Comment Via Position or Path ("Permalink")
-----------------------------------------------------

Instead of using slugs as above, this example retrieves comments by their
position in the comment list or tree. In the case of the chronological
(non-threaded) design, you need simply to use the ``$slice`` operator to
extract the correct comment:

.. code-block:: python

    discussion = db.discussion.find_one(
        {'discussion_id': discussion_id},
        {'comments': { '$slice': [ position, position ] } })
    comment = discussion['comments'][0]

In the case of the threaded design, you're faced with the task of
finding the correct path through the tree in your application:

.. code-block:: python

    discussion = db.discussion.find_one({'discussion_id': discussion_id})
    current = discussion
    for part in path:
        current = current.replies[part]
    comment = current

Note that, since the replies to comments are embedded in their parents,
you've have actually retrieved the entire sub-discussion rooted in the
comment you were looking for as well.

Schema Design: Hybrid
=====================

Comments in the hybrid format are stored in 'buckets' of about 100
comments each:

.. code-block:: python

    {
        _id: ObjectId(...),
        discussion_id: ObjectId(...),
        page: 1,
        count: 42,
        comments: [ {
            slug: '34db',
            posted: ISODateTime(...),
            author: { id: ObjectId(...), name: 'Rick' },
            text: 'This is so bogus ... ' },
        ... ]
    }

Here, you maintain a "page" of comment data, containing a bit of metadata
about the page (in particular, the page number and the comment count),
as well as the comment bodies themselves. Using a hybrid format actually
makes storing comments hierarchically quite complex, that approach is not covered
in this document.

Note that in this design, 100 comments is a 'soft' limit to the number
of comments per page, chosen mainly for performance reasons and to
ensure that the comment page never grows beyond the 16MB limit MongoDB
imposes on document size. There may be occasions when the number of
comments is slightly larger than 100, but this does not affect the
correctness of the design.

Operations: Hybrid
==================

Here, some common operations that you might need for your CMS are
described in the context of 100-comment "pages". Once again, the examples are
in Python.

Post a New Comment
------------------

In order to post a new comment, you need to ``$push`` the comment onto the
last page and ``$inc`` that page's  comment count. If the page has more than 100
comments, you then must will insert a new page as well. This operation starts
with a reference to the discussion document, and assumes that the discussion
document has a property that tracks the number of
pages:

.. code-block:: python

    page = db.comment_pages.find_and_modify(
        { 'discussion_id': discussion['_id'],
          'page': discussion['num_pages'] },
        { '$inc': { 'count': 1 },
          '$push': {
              'comments': { 'slug': slug, ... } } },
        fields={'count':1},
        upsert=True,
        new=True )

Note that the ``find_and_modify()`` above is written as an upsert
operation; if MongoDB doesn't findfind the page number, the ``find_and_modify()``
will create it for you, initialized with appropriate values for ``count`` and
``comments``. Since you're limiting the number of comments per page to around
100, you also need to create new pages as they become necessary:

.. code-block:: python

    if page['count'] > 100:
        db.discussion.update(
            { 'discussion_id: discussion['_id'],
              'num_pages': discussion['num_pages'] },
            { '$inc': { 'num_pages': 1 } } )

The update here includes the last known number of pages in the query in order to
ensure that you don't have a race condition where the number of pages is
double-incremented, resulting in a nearly or totally empty page. If some
other process has incremented the number of pages in the discussion,
then update above simply does nothing.

Index Support
~~~~~~~~~~~~~

In order to efficiently support the ``find_and_modify()`` and ``update()``
operations above, you need to maintain a compound index on
(``discussion_id``, ``page``) in the ``comment_pages`` collection:

.. code-block:: python

    >>> db.comment_pages.ensure_index([
    ...    ('discussion_id', 1), ('page', 1)])

View the (Paginated) Comments for a Discussion
----------------------------------------------

In order to paginate comments with a fixed page size (i.e. not with the 100-ish
number of comments on a database "page"), you need to do
a bit of extra work in Python:

.. code-block:: python

    def find_comments(discussion_id, skip, limit):
        result = []
        page_query = db.comment_pages.find(
            { 'discussion_id': discussion_id },
            { 'count': 1, 'comments': { '$slice': [ skip, limit ] } })
        page_query = page_query.sort('page')
        for page in page_query:
            result += page['comments']
            skip = max(0, skip - page['count'])
            limit -= len(page['comments'])
            if limit == 0: break
        return result

Here, the ``$slice`` operator is used to pull out comments from each page,
but *only* if the ``skip`` requirement is satisfied. An example helps illustrate
the logic here. Suppose you have 3 pages with 100, 102,
101, and 22 comments on each. respectively. YOu wish to retrieve comments
with skip=300 and limit=50. The algorithm proceeds as follows:

+-------+-------+-------------------------------------------------------+
| Skip  | Limit | Discussion                                            |
+=======+=======+=======================================================+
| 300   | 50    | ``{$slice: [ 300, 50 ] }`` matches nothing in page    |
|       |       | #1; subtract page #1's ``count`` from ``skip`` and    |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 200   | 50    | ``{$slice: [ 200, 50 ] }`` matches nothing in page    |
|       |       | #2; subtract page #2's ``count`` from ``skip`` and    |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 98    | 50    | ``{$slice: [ 98, 50 ] }`` matches 2 comments in page  |
|       |       | #3; subtract page #3's ``count`` from ``skip``        |
|       |       | (saturating at 0), subtract 2 from limit, and         |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 0     | 48    | ``{$slice: [ 0, 48 ] }`` matches all 22 comments in   |
|       |       | page #4; subtract 22 from ``limit`` and continue.     |
+-------+-------+-------------------------------------------------------+
| 0     | 26    | There are no more pages; terminate loop.              |
+-------+-------+-------------------------------------------------------+

Index Support
~~~~~~~~~~~~~

Since you already have an index on (``discussion_id``, ``page``) in your
``comment_pages`` collection, MongoDB can satisfy these queries
efficiently.

Retrieve a Comment Via Slug ("Permalink")
-----------------------------------------

Suppose you wish to directly retrieve a comment (e.g. *not* requiring
paging through all preceeding pages of commentary). In this case, you can
use the slug to find the correct page, and then use the application to
find the correct comment:

.. code-block:: python

    page = db.comment_pages.find_one(
        { 'discussion_id': discussion_id,
          'comments.slug': comment_slug},
        { 'comments': 1 })
    for comment in page['comments']:
        if comment['slug'] = comment_slug:
            break

Index Support
~~~~~~~~~~~~~

Here, you'll need a new index on (``discussion_id``, ``comments.slug``) to
efficiently support retrieving the page number of the comment by slug:

.. code-block:: python

    >>> db.comment_pages.ensure_index([
    ...    ('discussion_id', 1), ('comments.slug', 1)])

Sharding
========

In each of the cases above, it's likely that your ``discussion_id`` will at
least participate in the shard key if you should choose to shard.

In the case of the one document per comment approach, it would be nice
to use the ``slug`` (or ``full_slug``, in the case of threaded comments) as
part of the shard key to allow routing of requests by ``slug``:

.. code-block:: python

    >>> db.command('shardcollection', 'comments', {
    ...     key : { 'discussion_id' : 1, 'full_slug': 1 } })
    { "collectionsharded" : "comments", "ok" : 1 }

In the case of the fully-embedded comments, of course, the discussion is
the only thing needed to shard, and its shard key will probably be
determined by concerns outside the scope of this document.

In the case of hybrid documents, you'll want to use the page number of the
comment page in the shard key as well as the ``discussion_id`` to allow MongoDB
to split popular discussions among different shards:

.. code-block:: python

    >>> db.command('shardcollection', 'comment_pages', {
    ...     key : { 'discussion_id' : 1, 'page': 1 } })
    { "collectionsharded" : "comment_pages", "ok" : 1 }

