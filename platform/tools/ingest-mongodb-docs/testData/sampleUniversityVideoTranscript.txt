Now that we've covered the importance of internal authentication and what might happen if we don't enable it, we're going to cover how to implement it. So let's look at an example of a replica set. Currently, the members of this replica set don't have to authenticate to each other when joining the replica set or replicating data from the primary. This is dangerous, because if a bad actor gains admin access to the primary, they could potentially add their own rogue member to the replica set. So to mitigate this, we're going to implement SCRAM internal authentication. We've actually already looked at SCRAM authentication in chapter 1 when we discuss usernames and passwords as credentials for authentication. However, when SCRAM is used for internal authentication, it accepts keyfiles as credentials instead. A keyfile is a file with a very long password. The keyfile is copied over to each member of the replica set and it must be presented to other members during authentication. So now that we've seen a diagram of SCRAM internal authentication, let's move to the command line and start implementing it. All right, so to begin, I'm going to identify the keyfiles that each member will use to authenticate. So here's the keyfile for the first member, here's the keyfile for the second member, and here's the keyfile for the third member. So all these keyfiles have the same contents, but I just want to note that we have three copies of it. All right, so now that we know that our keyfiles are in place, we can modify the configuration files to include links to these keyfiles. I'm going to open this first configuration file using vi, but if you're doing this in the IDE later, you can use the file editor instead of opening this file from the command line. So I'm going to edit the first member's configuration to use the keyfile. And as a note, the keyfile configuration option implicitly turns on authentication for replica set members and MongoDB users. So instead of writing "authorization enabled" in addition to the keyfile option, we can just write "keyfile" to enforce both types of authentication. So now I'm going to edit the second member's configuration. And now I'll update the third member's configuration. OK, so at this stage, all three configuration files have been modified to use keyfiles for internal authentication. Now we just need to start each replica set member with the new configuration. So here's the first one, it looks OK. Here's the second one, it looks OK. And the third one, yep, looks OK. So now that all the members are up and running, I'm going to initiate the replica set. So first, I'll connect to one of the members of the replica set, and I will run rs.initiate to initiate the replica set. So it looks like the set has been initiated, so after a few seconds it should tell me that I'm connected to the primary node. So now, because we connected to this member over localhost, I can create the first user using the localhost exception. So I'm going to switch to the admin database, and I'll create our user administrator on the admin database. And it looks like it was successful. So that's our first user. Let's just authenticate as that user now. And it was successful. So at this point, the user administrator can do their job and create other users. So, we're done. So let's recap what we learned. To implement internal authentication in a three-member replica set using keyfiles, you must have three copies of the keyfile, with one available to each member, modify all three configuration files to link each keyfile, and then restart MongoDB with the new configuration, and lastly, create the first user using the localhost exception.