==============================
Aggregation Framework Examples
==============================

.. default-domain:: mongodb

MongoDB provides flexible data aggregation functionality with the
:dbcommand:`aggregate` command. For additional information about
aggregation consider the following resources:

- :doc:`/applications/aggregation`
- :doc:`/reference/aggregation`
- :wiki:`SQL+to+Aggregation+Framework+Mapping+Chart`

This document provides a number of practical examples that display the
capabilities of the aggregation framework. All examples use a publicly
available data set of all zipcodes and populations in the United
States.

Requirements
------------

:program:`mongod` and :program:`mongo`, version 2.2 or later.

Aggregations using the Zip Code Data Set
----------------------------------------

To run you will need the zipcode data set. These data are available at:
`media.mongodb.org/zips.json <http://media.mongodb.org/zips.json>`_.
Use :program:`mongoimport` to load this data set into your
:program:`mongod` instance.

Data Model
~~~~~~~~~~

Each document in this collection has the following form:

.. code-block:: javascript

   {
     "_id": "10280",
     "city": "NEW YORK",
     "state": "NY",
     "pop": 5574,
     "loc": [
       -74.016323,
       40.710537
     ]
   }

In these documents:

- The ``_id`` field holds the zipcode as a string.

- The ``city`` field holds the city.

- The ``state`` field holds the two letter state abbreviation.

- The ``pop`` field holds the population.

- The ``loc`` field holds the location as a latitude longitude pair.

All of the following examples use the :method:`aggregate()
<db.collection.aggregate()>` helper in the :program:`mongo`
shell. :method:`aggregate() <db.collection.aggregate()>` provides a
wrapper around the :dbcommand:`aggregate` database command. See the
documentation for your :doc:`driver </applications/drivers>` for a
more idiomatic interface for data aggregation operations.

States with Populations Over 10 Million
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return all states with a population greater than 10 million, use
the following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group :
                            { _id : "$state",
                              totalPop : { $sum : "$pop" } } },
                          { $match : {totalPop : { $gte : 10*1000*1000 } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates documents for each state.

  These new per-state documents have one field in addition the
  ``_id`` field: ``totalpop`` which is a generated field using the
  :agg:expression:`$sum` operation to calculate the total value of all
  ``pop`` fields in the source documents.

  After the :agg:pipeline:`$group` operation the document in the
  pipeline resemble the following:

  .. code-block:: javascript

     {
       "_id" : "AK",
       "totalPop" : 550043
     }

- the :agg:pipeline:`$match` operation filters these documents so that
  the only documents that remain are those where the value of
  ``totalpop`` is greater than or equal to 10 million.

  The :agg:pipeline:`$match` operation does not alter the documents,
  which have the same format as the documents output by
  :agg:pipeline:`$group`.

The equivalent :term:`SQL` for this operation is:

.. code-block:: sql

   SELECT state, SUM(pop) AS pop
          FROM zips
          GROUP BY state
          HAVING pop > (10*1000*1000)

Average City Population by State
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return the average populations for cities in each state, use the
following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group :
                            { _id : { state : "$state", city : "$city" },
                              pop : { $sum : "$pop" } } },
                          { $group :
                          { _id : "$_id.state",
                            avgCityPop : { $avg : "$pop" } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates new documents for every combination of the ``city`` and
  ``state`` fields in the source document.

  After this stage in the pipeline, the documents resemble the
  following:

  .. code-block:: javascript

     {
       "_id" : {
         "state" : "CO",
         "city" : "EDGEWATER"
       },
       "pop" : 13154
     }

- the second :agg:pipeline:`$group` operator collects documents by the
  ``state`` field and use the :agg:expression:`$avg` expression to
  compute a value for the ``avgCityPop`` field.

The final output of this aggregation operation is:

.. code-block:: javascript

   {
     "_id" : "MN",
     "avgCityPop" : 5335
   },

.. Will uncomment this section when we get the SQL
   The equivalent :term:`SQL` for this operation is:

   .. code-block:: sql

Largest and Smallest Cities by State
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return the smallest and largest cities by population for each
state, use the following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group:
                            { _id: { state: "$state", city: "$city" },
                              pop: { $sum: "$pop" } } },
                          { $sort: { pop: 1 } },
                          { $group:
                            { _id : "$_id.state",
                              biggestCity:  { $last: "$_id.city" },
                              biggestPop:   { $last: "$pop" },
                              smallestCity: { $first: "$_id.city" },
                              smallestPop:  { $first: "$pop" } } },

                          // the following $project is optional, and
                          // modifies the output format.

                          { $project:
                            { _id: 0,
                              state: "$_id",
                              biggestCity:  { name: "$biggestCity",  pop: "$biggestPop" },
                              smallestCity: { name: "$smallestCity", pop: "$smallestPop" } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates new documents for every combination of the ``city`` and
  ``state`` fields in the source documents.

  By specifying the value of ``_id`` as a sub-document that contains
  both fields, the operation preserves the ``state`` field for use
  later in the pipeline. The documents produced by this stage of the
  pipeline have a second field, ``pop``, which uses the
  :agg:expression:`$sum` operator to provide the total of the ``pop``
  fields in the source document.

  At this stage in the pipeline, the documents resemble the following:

  .. code-block:: javascript

     {
       "_id" : {
         "state" : "CO",
         "city" : "EDGEWATER"
       },
       "pop" : 13154
     }

- :agg:pipeline:`$sort` operator orders the documents in the pipeline
  based on the vale of the ``pop`` field from largest to
  smallest. This operation does not alter the documents.

- the second :agg:pipeline:`$group` operator collects the documents in
  the pipeline by the ``state`` field, which is a field inside the
  nested ``_id`` document.

  Within each per-state document this :agg:pipeline:`$group` operator
  specifies four fields: Using the :agg:expression:`$last` expression,
  the :agg:pipeline:`$group` operator creates the ``biggestcity`` and
  ``biggestpop`` fields that store the city with the largest
  population and that population. Using the :agg:expression:`$first`
  expression, the :agg:pipeline:`$group` operator creates the
  ``smallestcity`` and ``smallestpop`` fields that store the city with
  the smallest population and that population.

  The documents, at this stage in the pipeline resemble the following:

  .. code-block:: javascript

     {
       "_id" : "WA",
       "biggestCity" : "SEATTLE",
       "biggestPop" : 520096,
       "smallestCity" : "BENGE",
       "smallestPop" : 2
     }

- The final operation is :agg:pipeline:`$project`, which renames the
  ``_id`` field to ``state`` and moves the ``biggestCity``,
  ``biggestPop``, ``smallestCity``, and ``smallestPop`` into
  ``biggestCity`` and ``smallestCity`` sub-documents.

The final output of this aggregation operation is:

.. code-block:: javascript

   {
     "state" : "RI",
     "biggestCity" : {
       "name" : "CRANSTON",
       "pop" : 176404
     },
     "smallestCity" : {
       "name" : "CLAYVILLE",
       "pop" : 45
     }
   }

.. will uncomment this block when we get the SQL

   The equivalent :term:`SQL` for this operation is:

   .. code-block:: sql

Aggregation with User Preference Data
-------------------------------------

Data Model
~~~~~~~~~~

Consider a hypothetical data set of user preferences that that contains
sports information, with documents that resemble the following

.. code-block:: javascript

   {
     _id : "joe",
     joined : ISODate("2012-07-02"),
     likes : ["tennis", "golf", "fishing"]
   }
   {
     _id : "jane",
     joined : ISODate("2011-03-02"),
     likes : ["golf"]
   }


Return a Single Field
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // fetch just the user names
   // this alone would be better done as a query with find(), but we will
   // build up from here.
   db.users.find.aggregate(
      [
       { $project : { _id:1 } }
      ]
   )

Normalize and Sort Documents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // uppercase names with $toUpper operator to normalize their
   // case.  Then show all names in sorted order.
   db.users.aggregate(
     [
       { $project : { name:{$toUpper:"$_id"} , _id:0 } },
       { $sort : { name : 1 } }
     ]
   )

Determine Most Common Join Month in Collection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // show the top 4 months that people tend to join the club
   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" } } },
       { $sort : { month_joined : 1 } },
       { $limit : 4 }
     ]
   )

Return Usernames Ordered by Join Month
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // show user names ordered by the month they joined.
   // rename the "_id" field to the mnore descriptive fieldname "name"
   // while we are at it.
   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" }, name : "$_id", _id : 0 } },
       { $sort : { month_joined : 1 } }
     ]
   )

Return Total Number of Joins per Month
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // show for each month of the year, how many people joined in that month
   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" } } } ,
       { $group : { _id : {month_joined:"$month_joined"} , n : { $sum : 1 } } },
       { $sort : { "_id.month_joined" : 1 } }
     ]
   )

Return the Five Most Common "Likes"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

   // show the top five most liked activities, in ranked order
   db.users.aggregate(
     [
       { $unwind : "$likes" },
       { $group : { _id : "$likes" , n : { $sum : 1 } } },
       { $sort : { n : -1 } },
       { $limit : 5 }
     ]
   )
