=========================================
Best Practices Connecting from AWS Lambda
=========================================

.. default-domain:: mongodb

.. meta::
   :keywords: aws lambda connection

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Use the following best practices to improve connections
between :aws:`AWS Lambda </lambda/latest/dg/welcome.html>`
and |service|:

- Define and cache the client connection to the MongoDB server outside 
  the :aws:`AWS Lambda handler function </lambda/latest/dg/nodejs-prog-model-handler.html>`.

  Don't define a new MongoClient object each time you invoke your
  function. Doing so causes the driver to create a new database
  connection with each function call. This can be expensive. As an
  alternative, do the following:

  1. Create the MongoClient object once.
  2. Store the object so your function can reuse the MongoClient while
     it runs.

  The :ref:`Connection Example <lambda-aws-example>` reuses existing 
  database connections to:
  
  1. Speed up communication with the database.
  2. Keep connection counts on the database at a reasonable level with 
     respect to application traffic.

- If your handler takes a callback as its last argument, set the 
  ``callbackWaitsForEmptyEventLoop`` property on the :aws:`AWS Lambda
  Context
  </lambda/latest/dg/nodejs-context.html#nodejs-prog-model-context-properties>`
  object to **false**.

  .. code-block:: java
      
     context.callbackWaitsForEmptyEventLoop = false;

  This allows a Lambda function to return its result to the caller
  without requiring that the MongoDB database connection be closed.
  Setting this property is not applicable for `async handlers
  <https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html>`_.

- Set up a :doc:`Network Peering Connection </security-vpc-peering>` 
  between your |service| cluster and your |aws| Lambda function.

  .. note::

     If you don't :doc:`set up a Network Peering connection
     </security-vpc-peering>`, :doc:`add </security/ip-access-list>`
     ``0.0.0.0/0`` to the access list for your |service| cluster.

.. _lambda-aws-example:

Connection Example
------------------

The following Node.js example files, ``index.js`` and
``connect-to-mongodb.js``, display these best practices:

.. code-block:: javascript
   :caption: index.js
   :linenos:

   // Import dependency.
   const { connectToDatabase } = require('./connect-to-mongodb');

   // Handler
   module.exports.handler = async function(event, context) {

     // Get a MongoClient.
     const client = await connectToDatabase();

     // Use the connection to return the name of the connected database.
     return client.db().databaseName;
   }

.. code-block:: javascript
   :caption: connect-to-mongodb.js
   :linenos:

   "use strict";

   // Import dependency.
   const { MongoClient } = require('mongodb');

   // Connection string to the database
   const uri = process.env.MONGODB_URI;

   // Validate that the database connection string has been configured.
   if (!uri) {
     throw new Error(
       'The MONGODB_URI environment variable must be configured with the connection string ' +
         'to the database.'
     );
   }

   // Cached connection promise
   let cachedPromise = null;

   // Function for connecting to MongoDB, returning a new or cached database connection
   module.exports.connectToDatabase = async function connectToDatabase() {

     if (!cachedPromise) {
       // If no connection promise is cached, create a new one. We cache the promise instead
       // of the connection itself to prevent race conditions where connect is called more than
       // once. The promise will resolve only once.

       // Node.js driver docs can be found at http://mongodb.github.io/node-mongodb-native/.
       cachedPromise =
         MongoClient.connect(uri, { useNewUrlParser: true,  useUnifiedTopology: true });
     }

     // await on the promise. This resolves only once.
     const client = await cachedPromise;

     return client;
   }
