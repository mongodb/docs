.. _ref-index-definitions:

====================
Define |fts| Indexes 
====================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 3
   :class: singlecol

|fts| can index data in different ways. When you define an |fts| index, 
you can specify a particular analyzer or multiple analyzers to index  
certain fields. You can also index certain fields and omit others, or 
you can dynamically index all the fields in a collection. You can 
define |fts| indexes through the |service| :ref:`User Interface 
<ref-create-index>` and |fts| :doc:`API 
</reference/api/fts-indexes-create-one>`.

.. include:: /includes/atlas-search-out-agg.rst

.. note::

   |fts| indexes are eventually consistent.

Limitation
----------

.. include:: /includes/fact-fts-index-limitation.rst

.. _index-definition-syntax:

Syntax 
------

.. literalinclude:: /includes/fts-index-definition-syntax.json
   :language: json
   :linenos:
   :copyable: false

.. _index-definition-options:

Options 
-------

.. list-table::
   :header-rows: 1
   :widths: 20 15 15 50

   * - Field
     - Type
     - Necessity
     - Description

   * - ``analyzer``
     - string 
     - Optional 
     - Specifies the :ref:`analyzer <analyzers-ref>` to apply to 
       string fields when indexing. If you set this only at the top and 
       do not specify an analyzer for the fields in the index 
       definition, |fts| applies this analyzer to all the fields. To 
       use a different analyzer for each field, you must specify a 
       different analyzer for the field. If omitted, defaults to 
       :ref:`ref-standard-analyzer`.

   * - ``analyzers``
     - array of :ref:`custom-analyzers` 
     - Optional 
     - Specifies the :ref:`custom-analyzers` to use in this index.

   * - ``mappings``
     - :ref:`Document Field Definition <bson-data-types-document>`
     - Required
     - Specifies how to index fields at different paths for this 
       index.

   * - ``mappings.dynamic``
     - boolean
     - Optional
     - Enables or disables dynamic mapping of fields for this index.
     
       If set to ``true``, 
       |fts| recursively indexes all fields and embedded documents in the ``document`` except:

       - Fields of certain data types. To learn more, see 
         :ref:`bson-data-chart`.
       - Any fields explicitly excluded by the ``mappings.fields`` 
         parameter.

       If set to ``false``, you must specify individual fields to index 
       using ``mappings.fields``.

       If omitted, defaults to ``false``.

       .. include:: /includes/admonitions/importants/dynamic-flag-considerations.rst
       
          Admonition content
       

       See :ref:`index configuration example <index-config-example>` on 
       this page.

   * - ``mappings.fields``
     - document
     - Conditional
     - Required only if dynamic mapping is disabled. 
     
       Specifies the fields that you would like to index. See the 
       :ref:`example <index-config-example>` on this page. 

   * - ``name``
     - string 
     - Optional 
     - Specifies a name for the index. In each :manual:`namespace 
       </reference/limits/#faq-dev-namespace>`, names of all indexes in 
       the namespace must be unique. If omitted, defaults to 
       ``default``.

   * - ``searchAnalyzer``
     - string 
     - Optional
     - Specifies the :ref:`analyzer <analyzers-ref>` to apply to query 
       text before searching with it. If omitted, defaults to 
       :ref:`ref-standard-analyzer`.

   * - ``synonyms`` 
     - array of :ref:`Synonym Mapping Definition <synonyms-ref>`
     - Optional 
     - Synonym mappings to use in your index. To learn more, see 
       :ref:`synonyms-ref`.

.. _static-dynamic-mappings:

Static and Dynamic Mappings 
---------------------------

For **Static mappings**, set ``mappings.dynamic`` to ``false`` and 
specify the fields to index using ``mappings.fields``. |fts| only 
indexes the specified fields with specific options. 

Use static mappings to configure index options for fields that should 
not be indexed dynamically, or to configure a single field 
independently from others in an index.

.. note:: 

   You must specify static mappings when ``mappings.dynamic`` is 
   ``false``.

For **Dynamic mappings**, set ``mappings.dynamic`` to ``true``. |fts| 
automatically indexes the fields of :ref:`supported types 
<bson-data-chart>` in each document. 

Use dynamic mappings if your schema changes regularly or is unknown, or 
when experimenting with |fts|. You can configure an entire index to use 
dynamic mappings, or specify individual fields, such as fields of type 
``document``, to be dynamically mapped.

.. note::

   Dynamically mapped indexes occupy more disk space than statically 
   mapped indexes and may be less performant.

.. _bson-data-chart:

BSON Data Types
~~~~~~~~~~~~~~~

The table below enumerates all the :manual:`BSON data types
</reference/bson-types/>` and indicates whether they are included in an 
|fts| index with :ref:`dynamic mappings <static-dynamic-mappings>`. 

.. list-table::
   :header-rows: 1

   * - BSON Type
     - Included in Dynamic Index?
     - Atlas Search Field Type

   * - Double
     - yes
     - :ref:`number <bson-data-types-number>`

   * - 32-bit integer
     - yes
     - :ref:`number <bson-data-types-number>`

   * - 64-bit integer
     - yes
     - :ref:`number <bson-data-types-number>`

   * - String 
     - yes :sup:`*`
     - - :ref:`string <bson-data-types-string>`
       - :ref:`stringFacet <bson-data-types-string-facet>`
  
   * - Date
     - yes
     - :ref:`date <bson-data-types-date>`

   * - Object
     - yes
     - :ref:`document <bson-data-types-document>`

   * - ObjectId
     - no
     - :ref:`objectId <objectId-ref>`

   * - Boolean
     - no
     - :ref:`boolean <boolean-ref>`

   * - Timestamp
     - no
     - 

   * - Array
     - yes
     - 

   * - Binary Data
     - no
     - 

   * - Null
     - no
     - 

   * - Regular Expression
     - no
     - 

   * - JavaScript
     - no
     - 

   * - Decimal128
     - no
     - 

   * - Min key
     - no
     - 

   * - Max key
     - no
     - 

:sup:`*` You can't use :ref:`dynamic mapping <static-dynamic-mappings>` 
to automatically index ``string`` fields for faceting. You must index 
fields using :ref:`bson-data-types-string-facet` to run a facet query 
on ``string`` fields.

.. _fts-array-ref:

array
`````

For indexing arrays, |fts| only requires the data type of the array 
elements. You don't have to specify that the data is contained in an 
array in the index definition. 

.. note:: 

   |fts| doesn't index documents inside an array.

.. _fts-array-example:

.. example::

   The following index definition for the ``sample_mflix.movies`` 
   collection in the :ref:`sample dataset <available-sample-datasets>` 
   indexes the ``genres`` field, which contains an array of string 
   values. 

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "genres": {
              "type": "string"
            }
          }
        }
      }

.. _bson-data-types:

|fts| Field Types
~~~~~~~~~~~~~~~~~

.. _bson-data-types-autocomplete:

autocomplete
````````````
.. include:: /includes/fact-autocomplete-field-type.rst

The ``autocomplete`` type takes the following options: 

.. list-table::
   :widths: 18 9 8 54 11
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string 
     - required
     - The type of field. Value must be ``autocomplete``.
     - 

   * - ``analyzer``
     - string
     - optional
     - Name of the :ref:`analyzer <analyzers-ref>` to use with this 
       autocomplete mapping. You can use any |fts| analyzer except the 
       ``lucene.kuromoji`` :ref:`language analyzer 
       <ref-language-analyzers>` and the following :ref:`custom 
       analyzer <custom-analyzers>` tokenizers and token filters: 

       - :ref:`nGram <ngram-tokenizer-ref>` Tokenizer
       - :ref:`edgeGram <edgegram-tokenizer-ref>` Tokenizer
       - :ref:`daitchMokotoffSoundex <daitchmokotoffsoundex-tf-ref>` 
         Token Filter
       - :ref:`nGram <ngram-tf-ref>` Token Filter 
       - :ref:`edgeGram <edgegram-tf-ref>` Token Filter 
       - :ref:`shingle <shingle-tf-ref>` Token Filter

     - ``lucene.standard``
      
   * - ``maxGrams``
     - int
     - optional
     - The maximum number of characters per indexed sequence. The 
       value limits the character length of indexed tokens. When you 
       search for terms longer than the ``maxGrams`` value, |fts| 
       truncates the tokens to the ``maxGrams`` length.
     - ``15``

   * - ``minGrams``
     - int
     - optional
     - The minimum number of characters per indexed sequence. We 
       recommend ``4`` for the minimum value. A value that is less 
       than ``4`` could impact performance because the size of the 
       index can become very large. We recommend the default value of 
       ``2`` for ``edgeGram`` only.
     - ``2``

   * - ``tokenization``
     - enum
     - optional
     - The tokenization strategy to use when indexing the field for 
       autocompletion. Value can be one of the following: 

       - ``edgeGram`` - to create indexable tokens, referred to as 
         ``grams``, from variable-length character sequences starting 
         at the left side of the words as delimited by the analyzer 
         used with this autocomplete mapping.

       - ``rightEdgeGram`` -  to create indexable tokens, referred to 
         as ``grams``, from variable-length character sequences 
         starting at the right side of the words as delimited by the 
         analyzer used with this autocomplete mapping.

         .. include:: /includes/fact-rightEdgeGram-json-only.rst

       - ``nGram`` - to create indexable tokens, referred to as 
         ``grams``, by sliding a variable-length character window over 
         a word. |fts| creates more tokens for ``nGram`` than 
         ``edgeGram`` or ``rightEdgeGram``. Therefore, ``nGram`` takes 
         more space and time to index the field. ``nGram`` is better 
         suited for querying languages with long, compound words or 
         languages that don't use spaces.

       For example, consider the following sentence: 
         
       .. code-block:: none
          :copyable: false 

          The quick brown fox jumps over the lazy dog. 

       When tokenized with ``minGrams`` value of ``2`` and ``maxGrams`` 
       value of ``5``, |fts| indexes the following sequence of 
       characters based on the ``tokenization`` value you choose: 

       **edgeGram**

       .. code-block:: none
          :copyable: false 

          Th
          The
          The{SPACE}
          The q 
          qu
          qui
          quic
          quick
          ...

       **rightEdgeGram**

       .. code-block:: none
          :copyable: false 

          og
          dog
          {SPACE}dog
          y dog
          zy
          azy
          lazy
          {SPACE}lazy
          he
          the
          {SPACE}the
          r the
          er
          ver
          over
          {SPACE}over
          ...

       **nGram**

       .. code-block:: none 
          :copyable: false 

          Th
          The 
          The{SPACE}  
          The q
          he 
          he{SPACE}   
          he q
          he qu
          e{SPACE} 
          e q
          e qu
          e qui
          {SPACE}q
          {SPACE}qu
          {SPACE}qui
          {SPACE}quic
          qu
          qui
          quic
          quick
          ...

       .. note:: 

          Indexing a field for autocomplete with an ``edgeGram``, 
          ``rightEdgeGram``, or ``nGram`` tokenization strategy is more 
          computationally expensive than indexing a string field. The 
          index takes more space than an index with regular string 
          fields.

     - ``edgeGram``

   * - ``foldDiacritics``
     - boolean
     - optional
     - The setting to indicate whether diacritics should be 
       included or removed from the indexed text. Value can be 
       one of the following: 

       - ``true`` - to ignore diacritic marks in the index and query 
         text. Returns results with and without diacritic marks. For 
         example, a search for ``cafè`` returns results with the 
         characters ``cafè`` and ``cafe``.
       - ``false`` - to include diacritic marks in the index and query 
         text. Returns only results that match the strings with or 
         without diacritics in the query. For example, a search for 
         ``cafè`` returns results only with the characters ``cafè``. A 
         search for ``cafe`` returns results only with the characters 
         ``cafe``.

     - ``true``

.. example::

   .. code-block:: json 
      :emphasize-lines: 7-12

      {
        "mappings": {
          "dynamic": true|false,
          "fields": {
            "<field-name>": [
              {
                "type": "autocomplete",
                "analyzer": "lucene.standard",
                "tokenization": "edgeGram|rightEdgeGram|nGram",
                "minGrams": <2>,
                "maxGrams": <15>,
                "foldDiacritics": true|false
              }
            ]
          }
        }
      }

.. _boolean-ref:

boolean
```````

The ``boolean`` data type is used for indexing ``true`` and ``false`` 
values. It works in conjunction with the :ref:`equals <equals-ref>` 
operator.

.. note::

   Fields of type ``boolean`` cannot be dynamically indexed. You must 
   index fields of type ``boolean`` using :ref:`static mappings 
   <static-dynamic-mappings>`.

.. _boolean-objectid-example:

.. example::

   The following example index definition maps a field named 
   ``verified_user`` to the ``boolean`` data type and a field named 
   ``teammates`` to the ``objectId`` data type.

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "verified_user": {
              "type": "boolean"
            },
            "teammates": {
              "type": "objectId"
            }
          }
        }
      }

.. _bson-data-types-date:

date
````

The ``date`` type is used for indexing date values. It takes the 
``type`` option. The value of ``type`` must be ``date``. A  date can't 
be indexed if it is part of an array.

.. _bson-data-types-document:

document
````````

The ``document`` data type is used for fields with embedded documents.
It takes the following parameters:

.. list-table::
   :widths: 15 10 15 50 10
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string
     - Required
     - The type of field. Value must be ``document``.
     - 

   * - ``dynamic``
     - boolean
     - Conditional
     - If set to ``true``, 
       |fts| recursively indexes all fields and embedded documents in the ``document``
       except:

       - Fields of certain data types. To learn more, see 
         :ref:`bson-data-chart`.
       - Any fields that you explicitly exclude using the ``fields`` 
         parameter.

       If omitted or set to ``false``, you must specify individual 
       fields to index.

       .. include:: /includes/admonitions/importants/dynamic-flag-considerations.rst

     - false

   * - ``fields``
     - document
     - Conditional
     - Maps document field names to field definitions. To learn more, 
       see an :ref:`example <index-config-example>`. This is required 
       if ``dynamic`` is omitted or set to ``false``. 
     - 

.. _bson-data-types-geo:

geo
```

The ``geo`` type is used for indexing geographic point and shape 
coordinates. For this type, the indexed field must be a 
:manual:`GeoJSON </reference/geojson/>` object.

.. list-table::
   :widths: 20 10 10 50 10
   :header-rows: 1

   * - Option
     - Type 
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string 
     - Required
     - The type of field. Value must be ``geo``.
     - 

   * - ``indexShapes`` 
     - boolean 
     - Optional
     - Specifies whether or not to index shapes. By default, |fts|: 

       - Indexes points, even when nested.
       - Does not index shape geometries such as lines and polygons.

       Value can be: 

       - ``true`` to index shapes and points 
       - ``false`` to index only points

     - ``false``

.. example:: 

   .. code-block:: json 
      :emphasize-lines: 7-8

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "type": "document",
            "<field-name>": {
              "indexShapes": true|false,
              "type": "geo"
            }
          }
        }
      }

.. _bson-data-types-number:

number
``````

The ``number`` type is used for fields with numeric values of 
``int32``, ``int64``, and ``double`` data types. The ``number`` type 
has the following options: 

.. list-table::
   :widths: 20 10 10 50 10
   :header-rows: 1

   * - Option
     - Type 
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string 
     - Required
     - The type of field. Value must be ``number``.
     - 

   * - ``representation``
     - string 
     - Optional
     - The data type of the field to index. Values are:

       - ``int64`` - for indexing large integers without loss of 
         precision and for rounding double values to integers. You 
         can't use this type to index large double values.
       - ``double`` - for indexing large double values without rounding.

       To learn more, see :ref:`example <number-egs>` below.

     - ``double``

   * - ``indexIntegers``
     - boolean 
     - Optional
     - Indicates whether to index or omit indexing ``int32`` and 
       ``int64`` type values. Value can be ``true`` or ``false``.
       To learn more, see :ref:`example <number-egs>` below.

     - ``true``

   * - ``indexDoubles``
     - boolean 
     - Optional
     - Indicates whether to index or omit indexing ``double`` type 
       values. Value can be ``true`` or ``false``. To learn more, 
       see :ref:`example <number-egs>` below.

     - ``true``

.. _number-egs:

``representation`` Example
++++++++++++++++++++++++++

.. example::

   The following index definition for the 
   ``sample_analytics.accounts`` collection in the :ref:`sample 
   dataset <available-sample-datasets>` indexes the 
   ``account_id`` field with 64-bit integer values. The 
   following example also: 
    
   - Indexes all other integer values in the ``account_id`` field
   - Rounds any decimal values and indexes small double type 
     values in the ``account_id`` field

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
                "account_id": {
                  "type": "number",
                  "representation": "int64"
                }
            }
        }
      }

``indexIntegers`` Example
+++++++++++++++++++++++++

.. example::

   The following index definition for the 
   ``sample_airbnb.listingsAndReviews`` collection in the 
   :ref:`sample dataset <available-sample-datasets>` omits the 
   ``bathrooms`` field with 32-bit and 64-bit integer values. 
   The following example will index the ``bathrooms`` field with 
   ``double`` type values.

   .. code-block:: json 
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
              "bathrooms": {
                  "type": "number",
                  "indexIntegers": false
              }
            }
        }
      }

``indexDoubles`` Example
++++++++++++++++++++++++

.. example::

   The following index definition for the
   ``sample_analytics.accounts`` collection in the 
   :ref:`sample dataset <available-sample-datasets>`:
  
   - Indexes the ``account_id`` field with integer values.
   - Omits the ``account_id`` field with doubles values.

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
              "account_id": {
                  "type": "number",
                  "representation": "int64",
                  "indexDoubles": false
              }
            }
        }
      }

.. _objectId-ref:

objectId
````````

The ``objectId`` data type is used for indexing :manual:`ObjectId
</reference/bson-types/#objectid>` fields. It works in conjunction with 
the :ref:`equals <equals-ref>` operator.

.. note::

   Fields of type ``objectId`` can't be dynamically indexed. You must  
   index fields of type ``objectId`` using :ref:`static mappings 
   <static-dynamic-mappings>`. To learn more, see the :ref:`example
   <boolean-objectid-example>` in the :ref:`boolean <boolean-ref>` 
   section on this page.

.. _bson-data-types-string:

string
``````

.. note:: 

   You can't use :ref:`dynamic mapping <static-dynamic-mappings>` to 
   automatically index ``string`` fields for faceting. You must index 
   the fields using :ref:`bson-data-types-string-facet` to run a facet 
   query on ``string`` fields.

The ``string`` data type takes the following parameters:

.. list-table::
   :widths: 20 10 10 40 20
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string
     - Required
     - The type of field. Value must be ``string``.
     - 

   * - ``analyzer``
     - string
     - Optional
     - The name of a built-in or overridden :ref:`analyzer 
       <analyzers-ref>` to use for indexing the field.
     - ``lucene.standard``

   * - ``searchAnalyzer``
     - string
     - Optional
     - The analyzer to use when querying the field.
     - ``lucene.standard``

   * - ``indexOptions``
     - string
     - Optional 
     - Specifies the amount of information to store for the indexed 
       field. Value can be one of the following:

       - ``docs`` - Only indexes documents. The frequency and position 
         of the indexed term are ignored. Only a single occurence of 
         the term is reflected in the :ref:`score <scoring-ref>`.
       - ``freqs`` - Only indexes documents and term frequency. The 
         position of the indexed term is ignored. 
       - ``positions`` - Indexes documents, term frequency, and term 
         positions. 
       - ``offsets`` - (Default) Indexes documents, term frequency, 
         term positions, and term offsets. This option is required for 
         :ref:`highlight-ref`.

     - ``offsets``

   * - ``store``
     - boolean
     - Optional
     - Specifies whether or not to store the exact document text as 
       well as the analyzed values in the index. Value can be ``true`` 
       or ``false``. The value for this option must be ``true`` for 
       :ref:`highlight-ref`.
     - ``true``

   * - ``ignoreAbove``
     - int
     - Optional
     - The maximum number of characters in the value of the field to 
       index. |fts| doesn't index if the field value is greater than 
       the specified number of characters.
     - 

   * - ``multi``
     - String Field Definition
     - Optional 
     - The string field to index with the name of the alternate 
       analyzer specified in the ``multi`` object. To learn more about 
       specifying the ``multi`` object, see :ref:`example <multi-eg>` 
       below.

     - 

   * - ``norms``
     - string
     - Optional
     - Specifies whether to include or omit the field length in 
       the result when scoring. The length of the field is determined 
       by the number of tokens produced by the analyzer for the field. 
       Value can be one of the following: 
 
       - ``include`` - to include the field length when scoring.
       - ``omit`` - to omit the field length when scoring.
      
       If value is ``include``, |fts| uses the length of the field to 
       determine the higher score when scoring. For example, if two 
       documents match an |fts| query, the document with the shorter 
       field length scores higher than the document with the longer 
       field length.

       If value is ``omit``, |fts| ignores the field length when 
       scoring. 

     - ``include``

.. _multi-eg:

``multi`` Example 
+++++++++++++++++

.. example:: 
       
   The following index definition for a ``library.books`` collection 
   indexes string values in the field ``text`` with the 
   ``lucene.english`` and ``lucene.french`` analyzers in addition to 
   the default ``lucene.standard`` analyzer:

   .. code-block:: json 
      :copyable: false

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "text": {
              "type": "string",
              "multi": {
                "english": {
                  "type": "string",
                  "analyzer": "lucene.english"
                },
                "french": {
                  "type": "string",
                  "analyzer": "lucene.french"
                }
              }
            }
          }
        }
      }

.. _bson-data-types-string-facet:

stringFacet
```````````

.. note:: Preview

   .. include:: /includes/fact-fts-facets-preview.rst

The ``stringFacet`` data type is used for indexing :manual:`string 
</reference/bson-types/#string>` fields for faceting, which allows you 
to run a facet query on that field. |fts| doesn't apply the analyzer 
when indexing ``string`` fields for faceting. The ``stringFacet`` data 
type takes the following parameter:

.. list-table::
   :widths: 20 10 10 40 20
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Purpose
     - Default

   * - ``type``
     - string
     - Required
     - The type of field. Value must be ``stringFacet``.
     - 

.. _string-facet-egs:

Example
+++++++

The following index definition for the ``sample_mflix.movies`` 
collection in the :ref:`sample dataset <available-sample-datasets>` 
indexes the ``genres`` field as ``string`` for faceting.

.. code-block:: json
   :copyable: false

   {
     "mappings": {
       "dynamic": false,
       "fields": {
         "genres": {
           "type": "stringFacet"
         }
       }
     }
   }

.. _index-config-example:

Examples
--------

Static Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~

The following example index definition uses static mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that are not explicitly 
  mentioned are not indexed. So, the index definition includes:

  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``.
    
    The ``city`` sub-field uses the :ref:`lucene.simple
    <ref-simple-analyzer>` analyzer by default for queries.
    It uses the ``ignoreAbove`` option to ignore any string of
    more than 255 bytes in length.
    
    The ``state`` sub-field uses the :ref:`lucene.english
    <ref-language-analyzers>` analyzer by default for queries.

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries.

    For more information on ``multi`` analyzers, see :ref:`Path 
    Construction <ref-path>`.

  - The ``employees`` field, which is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. For indexing arrays, |fts| 
    only requires the data type of the array elements. You don't 
    have to specify that the data is contained in an array in the 
    index definition.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "address": {
           "type": "document",
           "fields": {
             "city": {
               "type": "string",
               "analyzer": "lucene.simple",
               "ignoreAbove": 255
             },
             "state": {
               "type": "string",
               "analyzer": "lucene.english"
             }
           }
         },
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string", 
           "analyzer": "lucene.standard"
         }
       }
     }
   }

Combined Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~~~

The following example index definition uses both static 
and dynamic mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that are not explicitly 
  mentioned are not indexed. So, the index definition includes:

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries. For more information on ``multi`` 
    analyzers, see :ref:`Path Construction <ref-path>`.
  - The ``employees`` field, which  is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. 
  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``. Instead of 
    explicitly mentioning each nested field in the document, the 
    index definition enables dynamic mapping for all the 
    sub-fields in the document. It uses the :ref:`lucene.standard 
    <ref-keyword-analyzer>` analyzer by default for queries.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "address": {
           "type": "document",
           "dynamic": true,
           "analyzer": "lucene.standard"
         }
       }
     }
   }

.. toctree::
   :titlesonly:

   /atlas-search/synonyms
   