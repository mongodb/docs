.. _perf-ref:

==========================
Performance Considerations
==========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

|fts| runs a new process, called ``mongot``, alongside
the :binary:`mongod <bin.mongod>` process on each host in your
|service| cluster. ``mongot`` maintains all
|fts| indexes on collections in your |service| databases.
The amount of CPU, memory, and disk resources ``mongot`` consumes
depends on several factors, including your index configuration
and the complexity of your queries. :ref:`Atlas Search alerts 
<atlas-search-alerts>` measure the amount of CPU and memory
used by |fts| processes.

|fts| Upgrade 
-------------

|fts| is deployed on your |service| cluster. When a new version of 
|fts| is deployed, your |service| cluster might experience brief 
network failures in returning query results. To mitigate issues during 
deployment and minimize impact to your application, consider the 
following: 

- Implement retry logic in your application.
- Configure |service| :ref:`maintenance windows 
  <configure-maintenance-window>`.

To learn more about the changes in each release, see :doc:`Atlas 
Search Changelog </atlas-search/changelog/>`.

Index Size and Configuration
----------------------------

.. important::
   
   If you create an |fts| index for a collection that has or will soon 
   have more than two billion documents, you must 
   :doc:`shard your cluster </cluster-config/sharded-cluster/>`.

When you :ref:`create <ref-create-index>` an |fts| index, the default
configuration sets field mapping to :ref:`dynamic
<static-dynamic-mappings>`, which means that all the data in your
collection is actively added to your |fts| index. Other options
such as enabling highlights can also result in your index taking up more
disk space. You can reduce the size and performance footprint of your
|fts| index by:

- Specifying a custom :ref:`index definition
  <ref-index-definitions>` to narrow the amount and type of data that is
  indexed.

- Setting the ``store`` option to ``false`` when specifying a 
  :ref:`string <bson-data-types-string>` type in an index definition.

.. note::

   Some limitations apply to |fts| on ``M0``, ``M2``, and ``M5``
   clusters only. To learn more, see 
   :ref:`Atlas Search Free and Shared Tier Limitations 
   <atlas-fts-shared-tier-limitations>`.

Considerations
~~~~~~~~~~~~~~

Some index configuration options can lead to indexes that take up a 
significant proportion of your disk space. In some cases, your index 
could be many times larger than the size of your data. Although this is 
expected behavior, it's important to be aware of the following 
indexing-intensive features:

Autocomplete
````````````

The :ref:`bson-data-types-autocomplete` |fts| field type can cause 
large indexes, especially in the following cases:

- Using ``nGram`` tokenization.
- Setting a wide ``minGrams`` to ``maxGrams``  range.
- Setting a ``minGram`` value of ``1`` on a collection with millions of 
  documents.

``multi`` Analyzers
```````````````````

Using a ``multi`` analyzer to analyze the same field multiple 
different ways can cause large indexes, especially when analyzing 
fields with very long values.

Synonym Collections
```````````````````

A large :ref:`synonyms <synonyms-ref>` source collection can cause 
large indexes.

Creating and Updating an Atlas Search Index
-------------------------------------------

Creating an |fts| index is resource-intensive. The performance of your
|service| cluster may be impacted while the index builds. 

|service| replicates all writes on the collection. This means that for 
each collection with |fts| indexes, the writes are amplified to the 
amount of |fts| indexes defined for that collection. 

In some instances, your |fts| index must be rebuilt. Rebuilding the 
|fts| index also consumes resources and may affect database 
performance. |fts| automatically rebuilds the index only in the event 
of:

- :ref:`Changes <ref-edit-index>` to the index definition
- |fts| version updates that include breaking changes
- Hardware-related problems such as index corruption

.. note:: 

   |fts| supports no-downtime indexing, which means you can continue to 
   read and write to your cluster while your index is being rebuilt. 
   |fts| keeps your old index up-to-date while the new index is being
   built. Once |fts| rebuilds the index, the old index is automatically 
   replaced without any further action from your side.

Scaling Up Indexing Performance 
-------------------------------

You can scale up your initial sync and steady state indexing for an 
|fts| index by upgrading your cluster to a higher :ref:`tier 
<create-cluster-instance>` with more cores. |fts| uses a percentage of 
all available cores to run both initial sync and steady state indexing 
and performance improves as new cores are made available by upgrading 
your cluster.

Eventual Consistency and Indexing Latency 
-----------------------------------------

|fts| supports eventual consistency and does not provide any stronger 
consistency guarantees. This means that data inserted into a MongoDB 
collection and indexed by |fts| will not be available immediately for 
``$search`` queries.

|fts| reads data from MongoDB :manual:`change streams 
</changeStreams/>` and indexes that data in an asynchronous process. 
This process is typically very fast, but may sometimes be impacted by 
replication latency, system resource availability, and index definition 
complexity.

Document Mapping Explosions
---------------------------

`Mapping explosions <https://en.wikipedia.org/wiki/Combinatorial_explosion#:~:text=In%20mathematics%2C%20a%20combinatorial%20explosion,the%20intractability%20of%20certain%20problems>`__
occur when |fts| indexes a document with arbitrary 
keys and you have a :ref:`dynamic mapping <static-dynamic-mappings>`. The 
``mongot`` process might consume increasing amounts of memory and could 
crash. If you add too many fields to an index, mapping explosions can 
occur. To address this issue, you can upgrade your cluster or use a 
:ref:`static mapping <static-dynamic-mappings>` that does not index all 
fields in your data.

Query Operators and Query Complexity
------------------------------------

The complexity level of |fts| queries and the type of :ref:`operators
<fts-operators>` used can affect database performance. Highly
complex queries with :ref:`multiple clauses <compound-ref>` are
resource-intensive, as are queries which use the :ref:`regex
<term-ref>` (regular expression) operator.

|fts| queries are ranked by :ref:`score <scoring-ref>`. Queries that
return a large number of results are more computationally intensive
because they must keep track of all the scores for the result set.

Performance Monitoring
----------------------

You can :ref:`monitor <monitor-cluster-metrics>` your |service|
cluster and view charts with performance statistics on the |service|
:guilabel:`Metrics` tab. These metrics can help you see how |fts|
queries and index building affect your cluster's performance.

.. note::

   If your cluster's resources are stretched or near the
   limits of acceptable performance, consider :doc:`upgrading
   </scale-cluster>` to a larger cluster tier before implementing
   |fts| functionality.

``$match`` Aggregation Stage Usage
----------------------------------

Using a :manual:`$match </reference/operator/aggregation/match/>`
aggregation pipeline stage after a :ref:`$search <query-syntax-ref>`
stage can drastically slow down query results. If possible, design
your ``$search`` query so that all necessary filtering occurs in the
``$search`` stage to remove the need for a ``$match`` stage. The
:ref:`$compound <compound-ref>` |fts| operator is helpful for queries
that require multiple filtering operations.

``$sort`` Aggregation Stage Usage 
---------------------------------

Using a :manual:`$sort </reference/operator/aggregation/sort/>`
aggregation pipeline stage after a :ref:`$search <query-syntax-ref>` 
stage can drastically slow down query results. If possible, design
your ``$search`` query so that all necessary sorting occurs in the 
``$search`` stage to remove the need for a ``$sort`` stage. In 
general, the |fts| :ref:`$compound <compound-ref>` operator is helpful 
for queries that require multiple sorting operations. To sort 
documents based on a numeric, date, or geo field, consider using 
the |fts| :ref:`$near <near-ref>` operator. 
