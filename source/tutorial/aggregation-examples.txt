==============================
Aggregation Framework Examples
==============================

.. default-domain:: mongodb

MongoDB provides flexible data aggregation functionality with the
:dbcommand:`aggregate` command. For additional information about
aggregation consider the following resources:

- :doc:`/applications/aggregation`
- :doc:`/reference/aggregation`
- :wiki:`SQL+to+Aggregation+Framework+Mapping+Chart`

This document provides a number of practical examples that display the
capabilities of the aggregation framework. All examples use a publicly
available data set of all zipcodes and populations in the United
States.

Requirements
------------

:program:`mongod` and :program:`mongo`, version 2.2 or later.

Aggregations using the Zip Code Data Set
----------------------------------------

To run you will need the zipcode data set. These data are available at:
`media.mongodb.org/zips.json <http://media.mongodb.org/zips.json>`_.
Use :program:`mongoimport` to load this data set into your
:program:`mongod` instance.

Data Model
~~~~~~~~~~

Each document in this collection has the following form:

.. code-block:: javascript

   {
     "_id": "10280",
     "city": "NEW YORK",
     "state": "NY",
     "pop": 5574,
     "loc": [
       -74.016323,
       40.710537
     ]
   }

In these documents:

- The ``_id`` field holds the zipcode as a string.

- The ``city`` field holds the city.

- The ``state`` field holds the two letter state abbreviation.

- The ``pop`` field holds the population.

- The ``loc`` field holds the location as a latitude longitude pair.

All of the following examples use the :method:`aggregate()
<db.collection.aggregate()>` helper in the :program:`mongo`
shell. :method:`aggregate() <db.collection.aggregate()>` provides a
wrapper around the :dbcommand:`aggregate` database command. See the
documentation for your :doc:`driver </applications/drivers>` for a
more idiomatic interface for data aggregation operations.

States with Populations Over 10 Million
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return all states with a population greater than 10 million, use
the following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group :
                            { _id : "$state",
                              totalPop : { $sum : "$pop" } } },
                          { $match : {totalPop : { $gte : 10*1000*1000 } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates documents for each state.

  These new per-state documents have one field in addition the
  ``_id`` field: ``totalpop`` which is a generated field using the
  :agg:expression:`$sum` operation to calculate the total value of all
  ``pop`` fields in the source documents.

  After the :agg:pipeline:`$group` operation the documents in the
  pipeline resemble the following:

  .. code-block:: javascript

     {
       "_id" : "AK",
       "totalPop" : 550043
     }

- the :agg:pipeline:`$match` operation filters these documents so that
  the only documents that remain are those where the value of
  ``totalpop`` is greater than or equal to 10 million.

  The :agg:pipeline:`$match` operation does not alter the documents,
  which have the same format as the documents output by
  :agg:pipeline:`$group`.

The equivalent :term:`SQL` for this operation is:

.. code-block:: sql

   SELECT state, SUM(pop) AS pop
          FROM zips
          GROUP BY state
          HAVING pop > (10*1000*1000)

Average City Population by State
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return the average populations for cities in each state, use the
following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group :
                            { _id : { state : "$state", city : "$city" },
                              pop : { $sum : "$pop" } } },
                          { $group :
                          { _id : "$_id.state",
                            avgCityPop : { $avg : "$pop" } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates new documents for every combination of the ``city`` and
  ``state`` fields in the source document.

  After this stage in the pipeline, the documents resemble the
  following:

  .. code-block:: javascript

     {
       "_id" : {
         "state" : "CO",
         "city" : "EDGEWATER"
       },
       "pop" : 13154
     }

- the second :agg:pipeline:`$group` operator collects documents by the
  ``state`` field and use the :agg:expression:`$avg` expression to
  compute a value for the ``avgCityPop`` field.

The final output of this aggregation operation is:

.. code-block:: javascript

   {
     "_id" : "MN",
     "avgCityPop" : 5335
   },

.. Will uncomment this section when we get the SQL
   The equivalent :term:`SQL` for this operation is:

   .. code-block:: sql

Largest and Smallest Cities by State
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To return the smallest and largest cities by population for each
state, use the following aggregation operation:

.. code-block:: javascript

   db.zipcodes.aggregate( { $group:
                            { _id: { state: "$state", city: "$city" },
                              pop: { $sum: "$pop" } } },
                          { $sort: { pop: 1 } },
                          { $group:
                            { _id : "$_id.state",
                              biggestCity:  { $last: "$_id.city" },
                              biggestPop:   { $last: "$pop" },
                              smallestCity: { $first: "$_id.city" },
                              smallestPop:  { $first: "$pop" } } },

                          // the following $project is optional, and
                          // modifies the output format.

                          { $project:
                            { _id: 0,
                              state: "$_id",
                              biggestCity:  { name: "$biggestCity",  pop: "$biggestPop" },
                              smallestCity: { name: "$smallestCity", pop: "$smallestPop" } } } )

Aggregations operations using the :method:`aggregate()
<db.collection.aggregate()>` helper, process all documents on the
``zipcodes`` collection. :method:`aggregate()
<db.collection.aggregate()>` a number of :ref:`pipeline
<aggregation-pipelines>` operators that define the aggregation
process.

In the above example, the pipeline passes all documents in the
``zipcodes`` collection through the following steps:

- the :agg:pipeline:`$group` operator collects all documents and
  creates new documents for every combination of the ``city`` and
  ``state`` fields in the source documents.

  By specifying the value of ``_id`` as a sub-document that contains
  both fields, the operation preserves the ``state`` field for use
  later in the pipeline. The documents produced by this stage of the
  pipeline have a second field, ``pop``, which uses the
  :agg:expression:`$sum` operator to provide the total of the ``pop``
  fields in the source document.

  At this stage in the pipeline, the documents resemble the following:

  .. code-block:: javascript

     {
       "_id" : {
         "state" : "CO",
         "city" : "EDGEWATER"
       },
       "pop" : 13154
     }

- :agg:pipeline:`$sort` operator orders the documents in the pipeline
  based on the vale of the ``pop`` field from largest to
  smallest. This operation does not alter the documents.

- the second :agg:pipeline:`$group` operator collects the documents in
  the pipeline by the ``state`` field, which is a field inside the
  nested ``_id`` document.

  Within each per-state document this :agg:pipeline:`$group` operator
  specifies four fields: Using the :agg:expression:`$last` expression,
  the :agg:pipeline:`$group` operator creates the ``biggestcity`` and
  ``biggestpop`` fields that store the city with the largest
  population and that population. Using the :agg:expression:`$first`
  expression, the :agg:pipeline:`$group` operator creates the
  ``smallestcity`` and ``smallestpop`` fields that store the city with
  the smallest population and that population.

  The documents, at this stage in the pipeline resemble the following:

  .. code-block:: javascript

     {
       "_id" : "WA",
       "biggestCity" : "SEATTLE",
       "biggestPop" : 520096,
       "smallestCity" : "BENGE",
       "smallestPop" : 2
     }

- The final operation is :agg:pipeline:`$project`, which renames the
  ``_id`` field to ``state`` and moves the ``biggestCity``,
  ``biggestPop``, ``smallestCity``, and ``smallestPop`` into
  ``biggestCity`` and ``smallestCity`` sub-documents.

The final output of this aggregation operation is:

.. code-block:: javascript

   {
     "state" : "RI",
     "biggestCity" : {
       "name" : "CRANSTON",
       "pop" : 176404
     },
     "smallestCity" : {
       "name" : "CLAYVILLE",
       "pop" : 45
     }
   }

.. will uncomment this block when we get the SQL

   The equivalent :term:`SQL` for this operation is:

   .. code-block:: sql

Aggregation with User Preference Data
-------------------------------------

Data Model
~~~~~~~~~~

Consider a hypothetical ``user`` collection that contains
sport preferences stored in documents that resemble the following:

.. code-block:: javascript

   {
     _id : "joe",
     joined : ISODate("2012-07-02"),
     likes : ["tennis", "golf", "fishing"]
   }
   {
     _id : "jane",
     joined : ISODate("2011-03-02"),
     likes : ["golf"]
   }

Return a Single Field
~~~~~~~~~~~~~~~~~~~~~

The following command uses :pipeline:`$project` to return only the
``_id`` field and to return it for all documents in the ``users``
collection.

Note that in an actual situation you would likely use :method:`find()
<db.collection.find()>` to return such a list. This example uses
:method:`aggregate() <db.collection.aggregate()>` for demonstration
purposes.

.. code-block:: javascript

   db.users.aggregate(
     [
       { $project : { _id:1 } }
     ]
   )

The command returns results that resemble the following:

.. code-block:: javascript

   {
     "result" : [
       {
         "_id" : "joe"
       },
       {
         "_id" : "jane"
       }
       {
         "_id" : "jill"
       }
     ],
     "ok" : 1
   }

Normalize and Sort Documents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following command returns user names in upper case and in
alphabetical order. The command returns user names for all documents in
the ``users`` collection. You might do this to normalize user names for
processing.

.. code-block:: javascript

   db.users.aggregate(
     [
       { $project : { name:{$toUpper:"$_id"} , _id:0 } },
       { $sort : { name : 1 } }
     ]
   )

The pipeline passes all documents in the ``users`` collection through
the following operations:

- The :agg:pipeline:`$project` operator:

  - Creates a new field called ``name``.

  - Specifies that the ``id`` field not be displayed. The
    :method:`aggregate() <db.collection.aggregate()>` method displays
    the ``_id`` field by default, unless you specify otherwise, as here.

- The :agg:expression:`$toUpper` operator populates the ``name`` field with
  the values of the ``_id`` field, converted to upper case.

- The :agg:pipeline:`$sort` operator sorts the ``name`` field.

The command returns results that resemble the following:

.. code-block:: javascript

   {
     "result" : [
       {
         "name" : "JANE"
       },
       {
         "name" : "JILL"
       },
       {
         "name" : "JOE"
       }
     ],
     "ok" : 1
   }

Determine Most Common Join Month in Collection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. todo I think this example needs reworking. I don't think it
   returns the top 4 months that people tend to join the club, just the first four in the
   calendar year. For example, if people joined as follows: Jan 1 person, Feb 2, Mar 2, Apr 1, June 100,
   the query would still return Jan, Feb, Mar, Apr.

.. code-block:: javascript

   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" } } },
       { $sort : { month_joined : 1 } },
       { $limit : 4 }
     ]
   )

The pipeline passes all documents in the ``users`` collection through
the following operations:

- The :agg:pipeline:`$project` operator creates a new field called ``month_joined``.

- The :agg:expression:`$month` operator populates the ``month_joined``
  field with the values of the ``joined`` field, converted to integer
  representations of the month.

- The :agg:pipeline:`$sort` operator sorts the ``month_joined`` field.

- The :agg:pipeline:`$limit` operator displays only the first 4
  documents, sorted by ``month_joined`` field.

The command returns results that resemble the following:

.. code-block:: javascript

   {
     "result" : [
       {
         "_id" : "ruth",
         "month_joined" : 1
       },
       {
         "_id" : "harold",
         "month_joined" : 1
       },
       {
         "_id" : "kate",
         "month_joined" : 1
       },
       {
         "_id" : "jill",
         "month_joined" : 2
       }
     ],
     "ok" : 1
   }


Return Usernames Ordered by Join Month
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following command returns user names sorted by the month they joined.

.. code-block:: javascript

   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" }, name : "$_id", _id : 0 } },
       { $sort : { month_joined : 1 } }
     ]
   )

The pipeline passes all documents in the ``users`` collection through
the following operations:

- The :agg:pipeline:`$project` operator:

  - Creates two new fields: ``month_joined`` and ``name``.

  - Specifies that the ``id`` field not be displayed. The
    :method:`aggregate() <db.collection.aggregate()>` method displays
    the ``_id`` field by default, unless you specify otherwise, as here.

- The :agg:expression:`$month` operator populates the ``month_joined``
  field with the values of the ``joined`` field, converted to integer
  representations of the month.

- The :agg:pipeline:`$sort` operator sorts the ``month_joined`` field.

The command returns results that resemble the following:

.. code-block:: javascript

   {
     "result" : [
       {
         "month_joined" : 1,
         "name" : "ruth"
       },
       {
         "month_joined" : 1,
         "name" : "harold"
       },
       {
         "month_joined" : 1,
         "name" : "kate"
       }
       {
         "month_joined" : 2,
         "name" : "jill"
       }
     ],
     "ok" : 1
   }


Return Total Number of Joins per Month
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following command shows how many people joined each month of the year.

.. code-block:: javascript

   db.users.aggregate(
     [
       { $project : { month_joined : { $month : "$joined" } } } ,
       { $group : { _id : {month_joined:"$month_joined"} , number : { $sum : 1 } } },
       { $sort : { "_id.month_joined" : 1 } }
     ]
   )

The pipeline passes all documents in the ``users`` collection through
the following operations:

- The :agg:pipeline:`$project` operator creates a new field called
  ``month_joined``.

- The :agg:expression:`$month` operator populates the ``month_joined``
  field with the values of the ``joined`` field, converted to integer
  representations of the month.

- The :agg:pipeline:`$group` operator creates a separate document for
  each value found in the ``month_joined`` field. :agg:pipeline:`$group`
  collects instances of ``month_joined`` that have the same value into
  the same document. Each document contains two fields:

  - ``_id``, which contains a nested document with the ``month_joined`` field and its value.

  - ``number``

- The :agg:expression:`$sum` operator increments the ``number`` field
  every time an instance of ``month_joined`` is encountered. This
  counts the number of documents with that value.

- The :agg:pipeline:`$sort` operator sorts the documents created by :agg:pipeline:`$group`
   according to their ``month_joined`` fields.

The command returns results that resemble the following:

.. code-block:: javascript

   {
     "result" : [
       {
         "_id" : {
           "month_joined" : 1
         },
         "number" : 3
       },
       {
         "_id" : {
           "month_joined" : 2
         },
         "number" : 9
       },
       {
         "_id" : {
           "month_joined" : 3
         },
         "number" : 5
       }
     ],
     "ok" : 1
   }

Return the Five Most Common "Likes"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. todo - show the top five most liked activities, in ranked order

.. code-block:: javascript

   db.users.aggregate(
     [
       { $unwind : "$likes" },
       { $group : { _id : "$likes" , n : { $sum : 1 } } },
       { $sort : { n : -1 } },
       { $limit : 5 }
     ]
   )

.. todo
   The pipeline passes all documents in the ``users`` collection through
   the following operations:

The command returns results that resemble the following:

.. code-block:: javascript

  {
    "result" : [
      {
        "_id" : "golf",
        "n" : 2
      },
      {
        "_id" : "fishing",
        "n" : 2
      },
      {
        "_id" : "football",
        "n" : 1
      },
      {
        "_id" : "tennis",
        "n" : 1
      }
    ],
    "ok" : 1
  }
