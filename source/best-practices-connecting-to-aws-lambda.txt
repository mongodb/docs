=========================================
Best Practices Connecting from AWS Lambda
=========================================

.. default-domain:: mongodb

.. meta::
   :keywords: aws lambda connection

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Use the following best practices to manage connections
between :aws:`AWS Lambda </lambda/latest/dg/welcome.html>`
and |service|:

- Define the client to the MongoDB server outside 
  the :aws:`AWS Lambda handler function </lambda/latest/dg/nodejs-prog-model-handler.html>`.

  Don't define a new MongoClient object each time you invoke your
  function. Doing so causes the driver to create a new database
  connection with each function call. This can be expensive and
  can result in your application exceeding database connection limits.
  As an alternative, do the following:

  1. Create the MongoClient object once.
  2. Store the object so your function can reuse the MongoClient for all
     function invocations.

  The :ref:`Connection Example <lambda-aws-example>` reuses existing
  database connections to speed up communication with the database and
  keep connection counts to the database at a reasonable level with
  respect to application traffic.

- If your handler takes a callback as its last argument, set the
  ``callbackWaitsForEmptyEventLoop`` property on the
  :aws:`AWS Lambda Context </lambda/latest/dg/nodejs-context.html#nodejs-prog-model-context-properties>`
  object to **false**.

  .. code-block:: java
      
     context.callbackWaitsForEmptyEventLoop = false;

  This allows a Lambda function to return its result to the caller
  without requiring that the MongoDB database connection be closed.
  Setting this property is not applicable for `async handlers
  <https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html>`_.

- Restrict network access to your |service| cluster. Connect to your
  |service| cluster over private networking using a
  :doc:`Network Peering connection </security-vpc-peering>` 
  between your |service| cluster and your |aws| Lambda function, or
  a :doc:`VPC endpoint </security-private-endpoint/>`,
  so that you can allow only private IP addresses to your
  :doc:`IP access list </security/ip-access-list/>`.

.. _lambda-aws-example:

Connection Examples
-------------------

This section includes examples for two approaches:

- In the first example, the Node.js file shows how to reuse ``Mongoclient.connect``
  across many function invocations.
- In the second example, two Node.js files, index.js and mongodb-client.js,
  show how to isolate the call to ``MongoClient.connect`` into its own
  module so that the connections can be reused across functions. Use
  this approach if you package multiple logical functions together
  in a single Lambda handler function.


The following example shows the best practice of defining the
``MongoClient.connect`` function in your application's Node.js code
outside the handler so it can be reused across function invocations.

.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";

   // Import dependency.
   const { MongoClient } = require('mongodb');

   // Create a module-scoped connection promise.
   // CRITICAL: You must call the connect function outside the handler
   // so that the client can be reused across function invocations.
   // Use the constructor when using the driver. Before connecting,
   // enable monitoring by attaching the event listeners to the client.
   // This will allow you to get all the events if you run into issues.

   const client = new MongoClient(process.env.MONGODB_URI,
      { useNewUrlParser: true,  useUnifiedTopology: true });
   const clientPromise = client.connect();
   
   // Handler
   module.exports.handler = async function(event, context) {

     // Get the MongoClient by calling await on the connection promise. Because
     // this is a promise, it will only resolve once.
     const client = await clientPromise;

     // Use the client to return the name of the connected database.
     return client.db().databaseName;
   }

Some serverless frameworks that run on top of Lambda allow for
multiple logical functions to be packaged together in a single
Lambda handler function. If your application runs multiple functions
within the same Lambda process, we recommend isolating the call to
the ``MongoClient.connect`` function into its own module so that
the connections can be reused across functions.

In the following code examples:

- ``mongo-client.js`` organizes the ``MongoClient.connect`` function
  into its own module (mongo-client).
- ``index.js`` imports that module and uses it to connect.

.. code-block:: javascript
   :caption: mongodb-client.js
   :linenos:


   "use strict";

   // Import dependency.
   const { MongoClient } = require('mongodb');

   // Export a module-scoped connection promise. By doing this in a separate
   // module, the client can be shared across functions. Use the constructor
   // when using the driver.

   const client = new MongoClient(process.env.MONGODB_URI,
      { useNewUrlParser: true,  useUnifiedTopology: true });
   module.exports = client.connect();

.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";
   // Import dependency.
   const clientPromise = require('./mongodb-client');
   
   // Handler
   module.exports.handler = async function(event, context) {
   
     // Get the MongoClient by calling await on the connection promise. Because
     // this is a promise, it will only resolve once.
     const client = await clientPromise;
   
     // Use the connection to return the name of the connected database.
     return client.db().databaseName;
   }
   