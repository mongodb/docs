.. _arch-center-is-search-enterprise-server:

======================================
Advanced Search with Enterprise Server
======================================

.. facet::
   :name: genre
   :values: tutorial

.. meta:: 
   :keywords: MongoDB Enterprise Server, retail, unified commerce, semantic search, full-text search, on-prem, search 
   :description: Learn how to use MongoDB Search and Vector Search for enterprise self-managed infrastructure.
   
.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

MongoDB enables AI-driven applications with enterprise-level search
capabilities on self-managed infrastructures.

**Use cases:** `Artificial Intelligence <https://www.mongodb.com/solutions/use-cases/artificial-intelligence>`__,
`Intelligent Search <https://www.mongodb.com/solutions/use-cases/intelligent-search>`__

**Industries:** `Retail <https://www.mongodb.com/solutions/industries/retail>`__

**Products:** `MongoDB Search with Enterprise Server <https://www.mongodb.com/press/mongodb-extends-search-and-vector-search-capabilities-to-self-managed-offerings>`__, 
`MongoDB Vector Search with Enterprise Server <https://www.mongodb.com/press/mongodb-extends-search-and-vector-search-capabilities-to-self-managed-offerings>`__, 
`MongoDB Enterprise Server <https://www.mongodb.com/try/download/enterprise>`__

Solution Overview
-----------------

Even as cloud adoption accelerates, many customers opt for self-managed
infrastructure and `on-prem deployments
<https://www.brightpattern.com/what-is-on-premises-deployment-of-software/>`__,
particularly in highly regulated industries. For instance, according to
`this survey
<https://www.techradar.com/pro/in-the-shadow-of-ai-has-cloud-peaked-a-survey-shows-that-more-businesses-are-moving-away-from-cloud-computing-to-dedicated-servers>`__,
93% of government bodies use on-prem deployments, followed by 91% of
organizations in the IT industry and 90% in the finance industry.
Moreover, many :abbr:`SMEs (Small and Medium Enterprises)`, such as
boutique retailers or regional grocery chains, use on-prem deployments
as the high cost to adopt cloud architecture is a financial barrier.

While self-managed infrastructure provides flexibility, compliance
control, and data sovereignty, it introduces challenges for
organizations that are looking to implement AI-powered solutions. Some
of these challenges include: 

- **Architectural complexity:** Companies often combine separate search
  engines and vector databases to achieve advanced search capabilities
  like vector search. 

- **Operational overwhelm:** Teams can struggle to synchronize separate
  technologies, manage varied resources, and maintain consistent
  workflows across multiple systems.

To address these hurdles, MongoDB introduced the `Search and Vector
Search with MongoDB Enterprise Server
<https://www.mongodb.com/press/mongodb-extends-search-and-vector-search-capabilities-to-self-managed-offerings>`__.
These search capabilities enable you to: 

- **Build next generation AI apps on any infrastructure:** Reduce
  architectural complexity, which makes it easier to develop AI-powered
  solutions and eliminates the need for multiple single-purpose
  technologies. 

- **Enjoy a consistent experience everywhere:** Use the same :abbr:`MQL
  (MongoDB Query Language )` API regardless of where the application is
  connected. This reduces friction and provides flexibility when moving
  between production and development environments.

This solution presents a demo which uses MongoDB Search and Vector
Search to help users discover products in a grocery store using either
full-text search or semantic search powered by vector embeddings. It
includes pre-requisites, architecture requirements, and step-by-step
instructions to run the demo in an environment with MongoDB Enterprise
Server and search nodes.

.. figure:: /includes/images/industry-solutions/enterprise-server-landing.svg
   :alt: Landing page of the grocery store with search capabilities

   Figure 1. The demo's landing page

Reference Architecture
----------------------

To use advanced search capabilities with Enterprise Server, you must
deploy MongoDB Search and Vector Search nodes in a Kubernetes cluster.
This enables full-text and semantic search powered by vector embeddings,
allowing users to find items based on descriptions or semantic
similarity.

You don’t need to migrate your existing database. Use MongoDB Enterprise
Edition running MongoDB 8.0.10 version or later, either inside or
outside a Kubernetes cluster. The Kubernetes operator manages these
search nodes and connects them securely to your database cluster,
regardless of its deployment location. 

In summary, you can use the following approaches to integrate MongoDB
Search and Vector Search with Enterprise Server:

1. MongoDB Enterprise Edition deployed inside Kubernetes

2. MongoDB Enterprise Edition deployed outside Kubernetes

Both deployment architectures require MongoDB Search and Vector Search
nodes deployed within Kubernetes. The following sections describe each
approach.

Install Search With MongoDB Enterprise Edition Inside Kubernetes
````````````````````````````````````````````````````````````````

This deployment option sets up MongoDB Search and Vector Search nodes
directly within the Kubernetes cluster alongside MongoDB Enterprise
Server instances, as used in the demo. This deployment ensures
integrated operations and simplifies management by maintaining all
components in the same environment. The image below illustrates this
deployment. 

.. figure:: /includes/images/industry-solutions/enterprise-server-inside.svg
   :alt: System diagram of store associate app with MongoDB and Voyage AI

   Figure 2. MongoDB Enterprise Server inside of Kubernetes

In this solution, the Kubernetes cluster hosts Enterprise Server, the
search nodes, and the inventory application. This architecture
simplifies management and ensures efficient data exchange between
components.

For step-by-step instructions on how to set up search nodes with an
internal Enterprise Server configuration, refer to :ref:`Install and
Use Search With MongoDB Enterprise Edition
<k8s-fts-vs-install-enterprise>`.

Install Search With MongoDB Enterprise Edition Outside Kubernetes 
`````````````````````````````````````````````````````````````````

This deployment option configures MongoDB Search and Vector Search nodes
inside Kubernetes, which connect to an Enterprise Server replica set
deployed outside the Kubernetes cluster. You can use this approach if
you have infrastructure requirements or operational preferences outside
Kubernetes. The image below illustrates this deployment.

.. figure:: /includes/images/industry-solutions/enterprise-server-outside.svg
   :alt: System diagram of store associate app with MongoDB and Voyage AI

   Figure 3. MongoDB Enterprise Server outside of Kubernetes

This configuration allows you to integrate advanced search capabilities
without changing your existing Enterprise Server infrastructure. 

For step-by-step instructions on how to install MongoDB Search and
Vector Search nodes with an external Enterprise Server configuration,
refer to :ref:`Install and Use MongoDB Search and Vector Search With
External MongoDB Enterprise Edition <k8s-fts-vs-install-external-enterprise>`.

Build the Solution
------------------

Follow the steps below to set up and run the solution. 

.. procedure::
   :style: normal
   
   .. step:: Deploy MongoDB Search and Vector Search nodes

      Follow the steps in the :ref:`<k8s-fts-vs-install-enterprise>`
      tutorial to deploy MongoDB Search and Vector Search nodes.

   .. step:: Clone the repository

      For the necessary data dump and application configuration,
      download the `demo repository
      <https://github.com/mongodb-industry-solutions/retail-unified-commerce>`__:

      .. code-block:: sh
      
         git clone https://github.com/mongodb-industry-solutions/retail-unified-commerce

      Go to the dump file directory:

      .. code-block:: sh
      
         cd ./retail-unified-commerce/docs/setup    

   .. step:: Import the demo data

      Import the sample grocery store inventory data into your MongoDB
      deployment.

      Run the following command to retrieve the connection string.
      Replace ``<SECRET_NAME>`` with the appropriate Kubernetes secret name
      generated during deployment:

      .. code-block:: sh
      
         kubectl get secret -n ${MDB_NS} <SECRET_NAME> -o yaml

      This command prints the secret metadata and its encoded contents.
      Copy the ``connectionStringStandard`` value and execute the
      following command to get the connection string:

      .. code-block:: sh
      
         echo "<Base64EncodedConnectionString>" | base64 --decode

      Run the following command to restore the database from the
      ``collections`` dump folder:

      .. code-block:: sh
      
         mongorestore --uri "<CONNECTION_STRING>" ./collections

   .. step:: Create MongoDB Search and Vector Search indexes
      
      Open ``mongosh`` with your connection string to connect to your
      cluster:

      .. code-block:: sh
      
         mongosh "<CONNECTION_STRING>"
         use retail-unified-commerce

      Run the following command to create the MongoDB Search index:

      .. code-block:: javascript
      
         db.products.createSearchIndex("product_atlas_search", {
            "mappings": {
               "dynamic": false,
               "fields": {
                  "brand": {
                     "type": "string"
                  },
                  "category": {
                     "type": "string"
                  },
                  "inventorySummary": {
                     "fields": {
                        "storeObjectId": {
                           "type": "objectId"
                        }
                     },
                     "type": "document"
                  },
                  "productName": {
                     "type": "string"
                  },
                  "subCategory": {
                     "type": "string"
                  }
               }
            }
         })

      Run the following command to create the MongoDB Vector Search
      index:

      .. code-block:: javascript
      
         db.products.createSearchIndex({
            name: "product_text_vector_index",
            type: "vectorSearch",
            definition: {
               fields: [
                  {
                     type: "vector",
                     path: "textEmbeddingVector",
                     numDimensions: 1024,
                     similarity: "cosine"
                  },
                  {
                     type: "filter",
                     path: "inventorySummary.storeObjectId"
                  },
                  {
                     type: "filter",
                     path: "inventorySummary.inStock"
                  }
               ]
            }
         })

      Run the following command to confirm that both indexes were
      created correctly. If successful, the command returns metadata for
      ``product_atlas_search`` and ``product_text_vector_index``.

      .. code-block:: javascript
      
         JSON.stringify(db.runCommand({listSearchIndexes: "products"}), null, 2)  
      
      Test your indexes using the following query:

      .. code-block:: javascript
      
         db.products.aggregate([
            {
               "$search": {
                  "index": "product_atlas_search",
                  "compound": {
                     "should": [
                        {
                           "text": {
                              "query": "Chicken Masala",
                              "path": ["productName", "brand", "category", "subCategory"],
                              "fuzzy": { "maxEdits": 2 },
                           }
                        }
                     ]
                  },
               }
            },
            {
               $project: {
                  productName: 1,
                  score: { $meta: "searchScore" }
               }
            },
            {
               $limit: 2
            }
         ])

      The query returns a list of product names and their search score:   

      .. code-block:: javascript

         [
            {
               _id: ObjectId("685bfe2d3d832cf7e1614edc"),
               productName: "Chicken Masala",
               score: 8.192384719848633,
            },
            {
               _id: ObjectId("685bfe2e3d832cf7e16159fe"),
               productName: "Shahi Chicken Masala",
               score: 7.7956156730651855,
            },
         ];
         
   .. step:: Configure and run the demo

      Create a ``.env`` file in the ``backend/advanced-search-ms``
      directory and another in the ``frontend`` directory. You can find
      a ``.env.template`` file in these directories. Update the
      placeholders with the connection string that you retrieved
      earlier.
      
      Refer to the GitHub repository's ``README`` for additional context
      and optional setup configurations.
      
      You can deploy the demo locally or on Kubernetes.

      .. tabs::

         .. tab:: Run locally
            :tabid: run-local
            
            Run the following code:
    
            .. code-block:: sh
            
               make build
    
            Ensure your frontend and backend services are accessible on
            localhost using your preferred method. Then, open your browser in
            ``http://localhost:3000/product-inventory``.

         .. tab:: Deploy using Kubernetes
            :tabid: deploy-kubernetes
             
            Run the backend and frontend inside your Kubernetes cluster using
            the Docker images built for the demo. Follow these steps:

            **1. Build and push Docker images**
                
            Build and push the backend and frontend images to your container
            registry by executing the following commands:
      
            .. code-block:: sh
            
               #Backend
               docker build --platform linux/amd64 -t retail-backend:latest ./backend/advanced-search-ms
               docker tag retail-backend:latest <YOUR_REGISTRY>/retail-backend:latest
               docker push <YOUR_REGISTRY>/retail-backend:latest
              
               #Frontend
               docker build --platform linux/amd64 -t retail-frontend:latest ./frontend
               docker tag retail-frontend:latest <YOUR_REGISTRY>/retail-frontend:latest
               docker push <YOUR_REGISTRY>/retail-frontend:latest
      
            The ``--platform linux/amd64`` flag may be required
            depending on your machine’s architecture.

            **2. Create the Kubernetes secrets**
      
            Store sensitive values in a Kubernetes secret file named
            ``retail-secrets.yaml`` within the ``retail-unified-commerce/k8s``
            folder. Do not commit real credentials to source control. Below is
            an example template: 
      
            .. code-block:: yaml
               
               # retail-unified-commerce/k8s/retail-secrets.yaml
               apiVersion: v1
               kind: Secret
               metadata:
                 name: retail-secrets
                 namespace: default
               type: Opaque
               data:
                 NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: 
                 VOYAGE_API_KEY: 
               stringData:
                 MONGODB_URI: <YOUR_CONNECTION_STRING>
                 DB_NAME: "retail-unified-commerce"
                 NEXT_PUBLIC_COLLECTION_PRODUCTS: "products"
                 NEXT_PUBLIC_COLLECTION_INVENTORY: "inventory"
                 NEXT_PUBLIC_COLLECTION_STORES: "stores"
                 SEARCH_INDEX: "product_atlas_search"
                 NEXT_PUBLIC_BACKEND_ENDPOINT: "<YOUR_BACKEND_ENDPOINT>"
                 NEXT_PUBLIC_ENABLE_ATLAS_SEARCH: "true"
                 NEXT_PUBLIC_ENABLE_VECTOR_SEARCH: "true"
                 NEXT_PUBLIC_ENABLE_HYBRID_SEARCH: "true"
                 NEXT_PUBLIC_ENABLE_FULLTEXT_SEARCH: "true"
                 MONGODB_DATABASE: "retail-unified-commerce"
                 PRODUCTS_COLLECTION: "products"
                 SEARCH_TEXT_INDEX: "product_atlas_search"
                 SEARCH_VECTOR_INDEX: "product_text_vector_index"
                 NEXT_PUBLIC_SEARCH_META_INDEX: "product_atlas_search_meta"
                 EMBEDDING_FIELD_NAME: "textEmbeddingVector"
                 VOYAGE_API_URL: "https://api.voyageai.com/v1"
                 VOYAGE_MODEL: "voyage-3-large"
            
            Apply the secrets to your cluster:
      
            .. code-block:: sh
      
               kubectl apply -f k8s/retail-secrets.yaml
      
            **3. Deploy the backend and the frontend**

            Place the ``backend-deployment.yaml`` template in your ``/k8s``
            directory:   
      
            .. code-block:: yaml  
        
               # retail-unified-commerce/k8s/backend-deployment.yaml
               apiVersion: apps/v1
               kind: Deployment
               metadata:
                 name: retail-backend
               spec:
                 replicas: 2
                 selector:
                   matchLabels:
                     app: retail-backend
                 template:
                   metadata:
                     labels:
                       app: retail-backend
                   spec:
                     containers:
                     - name: backend
                       image: <YOUR_REGISTRY>/retail-backend:latest
                       ports:
                       - containerPort: 8000
                       envFrom:
                       - secretRef:
                         name: retail-secrets
               ---
               apiVersion: v1
               kind: Service
               metadata:
                 name: retail-backend-service
               spec:
                 type: LoadBalancer
                 selector:
                   app: retail-backend
                 ports:
                 - port: 80
                   targetPort: 8000
      
            Place the ``frontend-deployment.yaml`` template in your ``/k8s``
            directory:      
            
            .. code-block:: yaml  
        
               # retail-unified-commerce/k8s/frontend-deployment.yaml
               apiVersion: apps/v1
               kind: Deployment
               metadata:
                 name: retail-frontend
               spec:
                 replicas: 2
                 selector:
                   matchLabels:
                     app: retail-frontend
                 template:
                   metadata:
                     labels:
                       app: retail-frontend
                   spec:
                     containers:
                     - name: frontend
                       image: <YOUR_REGISTRY>/retail-frontend:latest
                       ports:
                       - containerPort: 3000
                       envFrom:
                       - secretRef:
                         name: retail-secrets
               ---
               apiVersion: v1
               kind: Service
               metadata:
                 name: retail-frontend-service
               spec:
                 type: LoadBalancer
                 selector:
                   app: retail-frontend
                 ports:
                 - port: 80
                   targetPort: 3000
      
            Apply your Kubernetes deployments:      
      
            .. code-block:: sh
               
               kubectl apply -f k8s/backend-deployment.yaml
               kubectl apply -f k8s/frontend-deployment.yaml
      
            Verify your deployments:
      
            .. code-block:: sh
      
               kubectl get pods -o wide
               kubectl get svc -o wide
               
            Wait until the frontend and backend services have an
            ``EXTERNAL-IP`` assigned.

            **4. Access the demo**
            
            Once the external IP appears for the frontend service, open it by
            using the following link:
            ``http://<EXTERNAL-IP>/product-inventory``.

   .. step:: Explore the demo’s search capabilities

      Select the *MongoDB Search* option and enter queries that don't
      exactly match product names. For example, use a term like *green
      tea face mask* or a typo like *cukie*. These queries demonstrate
      the system’s ability to return relevant results when the input is
      imprecise.

      .. figure:: /includes/images/industry-solutions/enterprise-server-search.svg
         :alt: Result for search capabilities

         Figure 4. Search result for *green tea face mask*

      Switch to the *MongoDB Vector Search* option to experience
      semantic understanding. Use descriptive or intent-based queries
      such as *a gift for a teen girl* or *high-protein spicy snack*.
      The system shows results aligned with the meaning of your
      query, not just the words used.

      .. figure:: /includes/images/industry-solutions/enterprise-server-vector.svg
         :alt: Vector search result for gift for a teen girl

         Figure 5. Vector search result for *gift for a teen girl*

      In both results, you can view the search score displayed on the
      top-left corner of each product card. This score indicates the
      relevance of the result to your query.

Key Learnings
-------------

- **On-premises adoption holds strategic importance:** On-premises
  deployments remain critical for industries and organizations that
  prioritize data sovereignty and control. This public preview enables
  organizations to adopt AI in their on-premises environments, ensuring
  they stay competitive and meet compliance requirements.  

- **Simplified tech stack accelerates AI adoption:** MongoDB Search and
  Vector Search with Enterprise Server enable powerful AI applications
  by consolidating diverse technologies, reducing architectural
  complexity, and allowing smart search queries without migrating
  operational data.

- **Advanced search capabilities enhance user experience:** Full-text
  search and vector search refine how users explore and access
  information, driving more intuitive experiences across different
  industries.

Authors
-------

- Angie Guemes Estrada, MongoDB
- Rodrigo Leal, MongoDB
- Prashant Juttukonda, MongoDB

Learn More
----------

- To deploy MongoDB Search and Vector Search in your Kubernetes cluster,
  visit :ref:`k8s-deploy-search-resources`.

- To learn about search and vector search capabilities for use with
  MongoDB Community Edition and MongoDB Enterprise Server, read the
  `Supercharge Self-Managed Apps With Search and Vector Search
  Capabilities <https://www.mongodb.com/company/blog/product-release-announcements/supercharge-self-managed-apps-search-vector-search-capabilities>`__.

- To discover how MongoDB drives innovation in retail, visit `MongoDB
  for Retail <https://www.mongodb.com/solutions/industries/retail>`__.