# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2019
# This file is distributed under the same license as the mongodb-manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/multikey-index-bounds.txt:3
msgid "Multikey Index Bounds"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:13
msgid "The bounds of an index scan define the portions of an index to search during a query. When multiple predicates over an index exist, MongoDB will attempt to combine the bounds for these predicates, by either *intersection* or *compounding*, in order to produce a scan with smaller bounds."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:22
msgid "Intersect Bounds for Multikey Index"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:24
msgid "Bounds intersection refers to a logical conjunction (i.e. ``AND``) of multiple bounds. For instance, given two bounds ``[ [ 3, Infinity ] ]`` and ``[ [ -Infinity, 6 ] ]``, the intersection of the bounds results in ``[ [ 3, 6 ] ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:29
msgid "Given an :ref:`indexed <index-type-multikey>` array field, consider a query that specifies multiple predicates on the array and can use a :ref:`multikey index <index-type-multikey>`. MongoDB can intersect :ref:`multikey index <index-type-multikey>` bounds if an :query:`$elemMatch` joins the predicates."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:35
msgid "For example, a collection ``survey`` contains documents with a field ``item`` and an array field ``ratings``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:43
msgid "Create a :ref:`multikey index <index-type-multikey>` on the ``ratings`` array:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:50
msgid "The following query uses :query:`$elemMatch` to require that the array contains at least one *single* element that matches both conditions:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:57
#: ../source/core/multikey-index-bounds.txt:130
#: ../source/core/multikey-index-bounds.txt:282
#: ../source/core/multikey-index-bounds.txt:358
msgid "Taking the predicates separately:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:59
msgid "the bounds for the greater than or equal to 3 predicate (i.e. ``$gte: 3``) are ``[ [ 3, Infinity ] ]``;"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:62
msgid "the bounds for the less than or equal to 6 predicate (i.e. ``$lte: 6``) are ``[ [ -Infinity, 6 ] ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:65
msgid "Because the query uses :query:`$elemMatch` to join these predicates, MongoDB can intersect the bounds to:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:72
msgid "If the query does *not* join the conditions on the array field with :query:`$elemMatch`, MongoDB cannot intersect the multikey index bounds. Consider the following query:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:80
msgid "The query searches the ``ratings`` array for at least one element greater than or equal to 3 and at least one element less than or equal to 6. Because a single element does not need to meet both criteria, MongoDB does *not* intersect the bounds and uses either ``[ [ 3, Infinity ] ]`` or ``[ [ -Infinity, 6 ] ]``. MongoDB makes no guarantee as to which of these two bounds it chooses."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:88
msgid "Compound Bounds for Multikey Index"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:90
msgid "Compounding bounds refers to using bounds for multiple keys of :ref:`compound index <index-type-compound>`. For instance, given a compound index ``{ a: 1, b: 1 }`` with bounds on field ``a`` of ``[ [ 3, Infinity ] ]`` and bounds on field ``b`` of ``[ [ -Infinity, 6 ] ]``, compounding the bounds results in the use of both bounds:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:100
msgid "If MongoDB cannot compound the two bounds, MongoDB always constrains the index scan by the bound on its leading field, in this case, ``a: [ [ 3, Infinity ] ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:105
msgid "Compound Index on an Array Field"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:107
msgid "Consider a compound multikey index; i.e. a :ref:`compound index <index-type-compound>` where one of the indexed fields is an array. For example, a collection ``survey`` contains documents with a field ``item`` and an array field ``ratings``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:117
msgid "Create a :ref:`compound index <index-type-compound>` on the ``item`` field and the ``ratings`` field:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:124
msgid "The following query specifies a condition on both keys of the index:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:132
#: ../source/core/multikey-index-bounds.txt:284
msgid "the bounds for the ``item: \"XYZ\"`` predicate are ``[ [ \"XYZ\", \"XYZ\" ] ]``;"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:134
msgid "the bounds for the ``ratings: { $gte: 3 }`` predicate are ``[ [ 3, Infinity ] ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:137
#: ../source/core/multikey-index-bounds.txt:365
msgid "MongoDB can compound the two bounds to use the combined bounds of:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:144
msgid "Range Queries on a Scalar Indexed Field (WiredTiger)"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:148
msgid "*For the WiredTiger and In-Memory storage engines only*,"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:150
msgid "Starting in MongoDB 3.4, for multikey indexes created using MongoDB 3.4 or later, MongoDB keeps track of which indexed field or fields cause an index to be a multikey index. Tracking this information allows the MongoDB query engine to use tighter index bounds."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:155
msgid "The aforementioned :ref:`compound index <index-type-compound>` is on the scalar field [#scalar]_ ``item`` and the array field ``ratings``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:162
msgid "For the WiredTiger and the In-Memory storage engines, if a query operation specifies multiple predicates on the indexed scalar field(s) of a compound multikey index created in MongoDB 3.4 or later, MongoDB will intersect the bounds for the field."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:167
msgid "For example, the following operation specifies a range query on the scalar field as well as a range query on the array field:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:176
msgid "MongoDB will intersect the bounds for ``item`` to ``[ [ \"L\", \"Z\" ] ]`` and ratings to ``[[3.0, 6.0]]`` to use the combined bounds of:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:183
msgid "For another example, consider where the scalar fields belong to a nested document. For instance, a collection ``survey`` contains the following documents:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:191
msgid "Create a compound multikey index on the scalar fields ``\"item.name\"``, ``\"item.manufactured\"``, and the array field ``ratings`` :"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:198
msgid "Consider the following operation that specifies query predicates on the scalar fields:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:208
msgid "For this query, MongoDB can use the combined bounds of:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:214
msgid "Earlier versions of MongoDB cannot combine these bounds for the scalar fields."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:218
msgid "A scalar field is a field whose value is neither a document nor an array; e.g. a field whose value is a string or an integer is a scalar field."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:222
msgid "A scalar field can be a field nested in a document, as long as the field itself is not an array or a document. For example, in the document ``{ a: { b: { c: 5, d: 5 } } }``, ``c`` and ``d`` are scalar fields where as ``a`` and ``b`` are not."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:229
msgid "Range Queries on the Scalar Indexed Field (MMAPv1)"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:231
msgid "For the MMAPv1 storage engine, MongoDB cannot combine bounds for the scalar field for a compound multikey index, even if the query is only on the scalar field."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:236
msgid "Compound Index on Fields from an Array of Embedded Documents"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:238
msgid "If an array contains embedded documents, to index on fields contained in the embedded documents, use the :ref:`dotted field name <document-dot-notation>` in the index specification. For instance, given the following array of embedded documents:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:247
msgid "The dotted field name for the ``score`` field is ``\"ratings.score\"``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:250
msgid "Compound Bounds of Non-array Field and Field from an Array"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:252
msgid "Consider a collection ``survey2`` contains documents with a field ``item`` and an array field ``ratings``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:268
msgid "Create a :ref:`compound index <index-type-compound>` on the non-array field ``item`` as well as two fields from an array ``ratings.score`` and ``ratings.by``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:276
msgid "The following query specifies a condition on all three fields:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:286
msgid "the bounds for the ``score: { $lte: 5 }`` predicate are ``[ [ -Infinity, 5 ] ]``;"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:289
msgid "the bounds for the ``by: \"anon\"`` predicate are ``[ \"anon\", \"anon\" ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:291
msgid "MongoDB can compound the bounds for the ``item`` key with *either* the bounds for ``\"ratings.score\"`` or the bounds for ``\"ratings.by\"``, depending upon the query predicates and the index key values. MongoDB makes no guarantee as to which bounds it compounds with the ``item`` field. For instance, MongoDB will either choose to compound the ``item`` bounds with the ``\"ratings.score\"`` bounds:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:307
msgid "Or, MongoDB may choose to compound the ``item`` bounds with ``\"ratings.by\"`` bounds:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:319
msgid "However, to compound the bounds for ``\"ratings.score\"`` with the bounds for ``\"ratings.by\"``, the query must use :query:`$elemMatch`. See :ref:`compound-fields-from-array` for more information."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:326
msgid "Compound Bounds of Index Fields from an Array"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:328
msgid "To compound together the bounds for index keys from the same array:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:330
msgid "the index keys must share the same field path up to but excluding the field names, and"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:333
msgid "the query must specify predicates on the fields using :query:`$elemMatch` on that path."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:336
msgid "For a field in an embedded document, the :ref:`dotted field name <document-dot-notation>`, such as ``\"a.b.c.d\"``, is the field path for ``d``. To compound the bounds for index keys from the same array, the :query:`$elemMatch` must be on the path up to *but excluding* the field name itself; i.e. ``\"a.b.c\"``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:342
msgid "For instance, create a :ref:`compound index <index-type-compound>` on the ``ratings.score`` and the ``ratings.by`` fields:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:349
msgid "The fields ``\"ratings.score\"`` and ``\"ratings.by\"`` share the field path ``ratings``. The following query uses :query:`$elemMatch` on the field ``ratings`` to require that the array contains at least one *single* element that matches both conditions:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:360
msgid "the bounds for the ``score: { $lte: 5 }`` predicate is ``[ -Infinity, 5 ]``;"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:363
msgid "the bounds for the ``by: \"anon\"`` predicate is ``[ \"anon\", \"anon\" ]``."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:372
msgid "Query Without ``$elemMatch``"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:374
msgid "If the query does *not* join the conditions on the indexed array fields with :query:`$elemMatch`, MongoDB *cannot* compound their bounds. Consider the following query:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:382
msgid "Because a single embedded document in the array does not need to meet both criteria, MongoDB does *not* compound the bounds. When using a compound index, if MongoDB cannot constrain all the fields of the index, MongoDB always constrains the leading field of the index, in this case ``\"ratings.score\"``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:396
msgid "``$elemMatch`` on Incomplete Path"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:398
msgid "If the query does not specify :query:`$elemMatch` on the path of the embedded fields, up to but excluding the field names, MongoDB **cannot** compound the bounds of index keys from the same array."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:402
msgid "For example, a collection ``survey3`` contains documents with a field ``item`` and an array field ``ratings``:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:419
msgid "Create a :ref:`compound index <index-type-compound>` on the ``ratings.scores.q1`` and the ``ratings.scores.q2`` fields:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:426
msgid "The fields ``\"ratings.scores.q1\"`` and ``\"ratings.scores.q2\"`` share the field path ``\"ratings.scores\"`` and the :query:`$elemMatch` must be on that path."
msgstr ""

#: ../source/core/multikey-index-bounds.txt:430
msgid "The following query, however, uses an :query:`$elemMatch` but not on the required path:"
msgstr ""

#: ../source/core/multikey-index-bounds.txt:437
msgid "As such, MongoDB **cannot** compound the bounds, and the ``\"ratings.scores.q2\"`` field will be unconstrained during the index scan. To compound the bounds, the query must use :query:`$elemMatch` on the path ``\"ratings.scores\"``:"
msgstr ""

