# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2014, MongoDB, Inc.
# This file is distributed under the same license as the mongodb-manual
# package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: MongoDB Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: 2014-04-08 16:30+0000\n"
"Last-Translator: tychoish <tychoish@gmail.com>\n"
"Language: es\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/mongodb-"
"manual/language/es/)\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../source/tutorial/create-indexes-to-support-queries.txt:5
msgid "Create Indexes to Support Your Queries"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:15
msgid ""
"An index supports a query when the index contains all the fields scanned "
"by the query. The query scans the index and not the collection. Creating "
"indexes that support queries results in greatly increased query "
"performance."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:19
msgid ""
"This document describes strategies for creating indexes that support "
"queries."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:22
msgid "Create a Single-Key Index if All Queries Use the Same, Single Key"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:24
msgid ""
"If you only ever query on a single key in a given collection, then you "
"need to create just one single-key index for that collection. For "
"example, you might create an index on ``category`` in the ``product`` "
"collection:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:35
msgid "Create Compound Indexes to Support Several Different Queries"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:37
msgid ""
"If you sometimes query on only one key and at other times query on that "
"key combined with a second key, then creating a compound index is more "
"efficient than creating a single-key index. MongoDB will use the compound"
" index for both queries. For example, you might create an index on both "
"``category`` and ``item``."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:47
msgid ""
"This allows you both options. You can query on just ``category``, and you"
" also can query on ``category`` combined with ``item``. A single "
":ref:`compound index <index-type-compound>` on multiple fields can "
"support all the queries that search a \"prefix\" subset of those fields."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:54
msgid "The following index on a collection:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:60
msgid "Can support queries that the following indexes support:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:67
msgid ""
"There are some situations where the prefix indexes may offer better query"
" performance: for example if ``z`` is a large array."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:70
msgid ""
"The ``{ x: 1, y: 1, z: 1 }`` index can also support many of the same "
"queries as the following index:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:77
msgid "Also, ``{ x: 1, z: 1 }`` has an additional use. Given the following query:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:84
msgid ""
"The ``{ x: 1, z: 1 }`` index supports both the query and the sort "
"operation, while the ``{ x: 1, y: 1, z: 1 }`` index only supports the "
"query. For more information on sorting, see :ref:`sorting-with-indexes`."
msgstr ""

#: ../source/includes/fact-index-intersection-vs-compound-indexes.rst:1
msgid ""
"Starting in version 2.6, MongoDB can use :doc:`index intersection </core"
"/index-intersection>` to fulfill queries. The choice between creating "
"compound indexes that support your queries or relying on index "
"intersection depends on the specifics of your system. See :ref:`index-"
"intersection-compound-indexes` for more details."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:92
msgid "Index Use and Collation"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:1
msgid ""
"To use an index for string comparisons, an operation must also specify "
"the same collation. That is, an index with a collation cannot support an "
"operation that performs string comparisons on the indexed fields if the "
"operation specifies a different collation."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:6
msgid ""
"For example, the collection ``myColl`` has an index on a string field "
"``category`` with the collation locale ``\"fr\"``."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:13
msgid ""
"The following query operation, which specifies the same collation as the "
"index, can use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:20
msgid ""
"However, the following query operation, which by default uses the "
"\"simple\" binary collator, cannot use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:27
msgid ""
"For a compound index where the index prefix keys are not strings, arrays,"
" and embedded documents, an operation that specifies a different "
"collation can still use the index to support comparisons on the index "
"prefix keys."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:32
msgid ""
"For example, the collection ``myColl`` has a compound index on the "
"numeric fields ``score`` and ``price`` and the string field ``category``;"
" the index is created with the  collation locale ``\"fr\"`` for string "
"comparisons:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:43
msgid ""
"The following operations, which use ``\"simple\"`` binary collation for "
"string comparisons, can use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:51
msgid ""
"The following operation, which uses ``\"simple\"`` binary collation for "
"string comparisons on the indexed ``category`` field, can use the index "
"to fulfill only the ``score: 5`` portion of the query:"
msgstr ""

#~ msgid ""
#~ "Because the index \"covers\" the query,"
#~ " MongoDB can both match the "
#~ ":ref:`query conditions <read-operations-"
#~ "query-document>` **and** return the results"
#~ " using only the index; MongoDB does"
#~ " not need to look at the "
#~ "documents, only the index, to fulfill"
#~ " the query. An index can also "
#~ "cover an :ref:`aggregation pipeline operation"
#~ " <aggregation-pipeline-operators-and-"
#~ "performance>` on unsharded collections."
#~ msgstr ""

# 0c292438a62a40359e111fe7538c31c9
# 93c80be3976049d59c542760ff951f46
#~ msgid "Example"
#~ msgstr ""

# 9855fd45dce94d6fa8b8b06c4f26c484
#~ msgid "Create Indexes that Support Covered Queries"
#~ msgstr ""

# c0942e724a2942819ff42839c938d7e8
#~ msgid "A covered query is a query in which:"
#~ msgstr ""

# 6884ad64a8af4ea8a472a66e0387bff5
#~ msgid ""
#~ "all the fields in the :ref:`query "
#~ "<read-operations-query-document>` are part"
#~ " of an index, **and**"
#~ msgstr ""

# 3433efe5aa7f4d96ad508cc288850d74
#~ msgid "all the fields returned in the results are in the same index."
#~ msgstr ""

# 792777819701422d80233af3d7cd0fbb
#~ msgid ""
#~ "Querying *only* the index can be "
#~ "much faster than querying documents "
#~ "outside of the index. Index keys "
#~ "are typically smaller than the documents"
#~ " they catalog, and indexes are "
#~ "typically available in RAM or located"
#~ " sequentially on disk."
#~ msgstr ""

# 66833c0e9d0b4abc84e30cc20144031f
#~ msgid ""
#~ "MongoDB automatically uses an index that"
#~ " covers a query when possible. To "
#~ "ensure that an index can *cover* a"
#~ " query, create an index that includes"
#~ " all the fields listed in the "
#~ ":ref:`query document <read-operations-"
#~ "query-document>` and in the query "
#~ "result. You can specify the fields "
#~ "to return in the query results "
#~ "with a :ref:`projection <projection>` "
#~ "document. By default, MongoDB includes "
#~ "the ``_id`` field in the query "
#~ "result. So, if the index does "
#~ "**not** include the ``_id`` field, then"
#~ " you must exclude the ``_id`` field"
#~ " (i.e. ``_id: 0``) from the query "
#~ "results."
#~ msgstr ""

# 6d403df33ae340759a932b3bec2f7cea
#~ msgid ""
#~ "Given collection ``users`` with an index"
#~ " on the fields ``user`` and "
#~ "``status``, as created by the following"
#~ " option:"
#~ msgstr ""

# 944c3ced2a2b48d09ba1f4424688dafb
#~ msgid ""
#~ "Then, this index will cover the "
#~ "following query which selects on the "
#~ "``status`` field and returns only the"
#~ " ``user`` field:"
#~ msgstr ""

# d22cc48ff688467e895ab1ecec7c69e7
#~ msgid ""
#~ "In the operation, the projection "
#~ "document explicitly specifies ``_id: 0`` "
#~ "to exclude the ``_id`` field from "
#~ "the result since the index is only"
#~ " on the ``status`` and the ``user``"
#~ " fields."
#~ msgstr ""

# 3b9aa4a76d2148fab6451245bc2e0fc6
#~ msgid ""
#~ "If the projection document does not "
#~ "specify the exclusion of the ``_id`` "
#~ "field, the query returns the ``_id`` "
#~ "field. The following query is **not**"
#~ " covered by the index on the "
#~ "``status`` and the ``user`` fields "
#~ "because with the projection document ``{"
#~ " user: 1 }``, the query returns "
#~ "both the ``user`` field and the "
#~ "``_id`` field:"
#~ msgstr ""

# e636c028b6b5449eb20097aadf236b8f
#~ msgid "An index **cannot** cover a query if:"
#~ msgstr ""

# 423a12009fa14aff82fa1167ac6e9567
#~ msgid ""
#~ "any of the indexed fields in any"
#~ " of the documents in the collection"
#~ " includes an array. If an indexed "
#~ "field is an array, the index "
#~ "becomes a :ref:`multi-key index "
#~ "<index-type-multikey>` index and cannot "
#~ "support a covered query."
#~ msgstr ""

# 9abae9d500b741e887c352ee344106de
#~ msgid ""
#~ "any of the indexed fields are "
#~ "fields in subdocuments. To index fields"
#~ " in subdocuments, use :term:`dot notation`."
#~ " For example, consider a collection "
#~ "``users`` with documents of the "
#~ "following form:"
#~ msgstr ""

# c761658cdaae4953b463c98aa0655613
#~ msgid "The collection has the following indexes:"
#~ msgstr ""

# 1a19f3416b0746cf8c7e845494ec8bb2
#~ msgid "The ``{ user: 1 }`` index covers the following query:"
#~ msgstr ""

# 92120895e27b483e9fa749f10d66254a
#~ msgid ""
#~ "However, the ``{ \"user.login\": 1 }``"
#~ " index does **not** cover the "
#~ "following query:"
#~ msgstr ""

# 5f1182dc855c4de2934d910618b02260
#~ msgid ""
#~ "The query, however, does use the "
#~ "``{ \"user.login\": 1 }`` index to "
#~ "find matching documents."
#~ msgstr ""

# ce238b44d7b9468e9b62b9cc463ca453
#~ msgid ""
#~ "To determine whether a query is a"
#~ " covered query, use the "
#~ ":method:`~cursor.explain()` method. If the "
#~ ":method:`~cursor.explain()` output displays ``true``"
#~ " for the :data:`~explain.indexOnly` field, "
#~ "the query is covered by an index,"
#~ " and MongoDB queries only that index"
#~ " to match the query **and** return"
#~ " the results."
#~ msgstr ""

# ae2a67c6c3ab4d329d940a62e3d93041
#~ msgid "For more information see :ref:`indexes-measuring-use`."
#~ msgstr ""

#~ msgid ""
#~ "Because the index \"covers\" the query,"
#~ " MongoDB can both match the "
#~ ":ref:`query conditions <read-operations-"
#~ "query-document>` **and** return the results"
#~ " using only the index; MongoDB does"
#~ " not need to look at the "
#~ "documents, only the index, to fulfill"
#~ " the query."
#~ msgstr ""

