#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../source/faq/concurrency.txt:3
msgid "FAQ: Concurrency"
msgstr ""

#: ../source/faq/concurrency.txt:15
msgid ""
"MongoDB allows multiple clients to read and write the same data. In order"
" to ensure consistency, it uses locking and other :term:`concurrency "
"control` measures to prevent multiple clients from modifying the same "
"piece of data simultaneously. Together, these mechanisms guarantee that "
"all writes to a single document occur either in full or not at all and "
"that clients never see an inconsistent view of the data."
msgstr ""

#: ../source/faq/concurrency.txt:27
msgid "What type of locking does MongoDB use?"
msgstr ""

#: ../source/includes/extracts/lock-general.rst:1
msgid ""
"MongoDB uses multi-granularity locking [#mgl-ref]_ that allows operations"
" to lock at the global, database or collection level, and allows for "
"individual storage engines to implement their own concurrency control "
"below the collection level (e.g., at the document-level in WiredTiger)."
msgstr ""

#: ../source/includes/extracts/lock-general.rst:7
msgid ""
"MongoDB uses reader-writer locks that allow concurrent readers shared "
"access to a resource, such as a database or collection, but in MMAPv1, "
"give exclusive access to a single write operation."
msgstr ""

#: ../source/faq/concurrency.txt:31
msgid ""
"In addition to a shared (S) locking mode for reads and an exclusive (X) "
"locking mode for write operations, intent shared (IS) and intent "
"exclusive (IX) modes indicate an intent to read or write a resource using"
" a finer granularity lock.  When locking at a certain granularity, all "
"higher levels are locked using an :term:`intent lock`."
msgstr ""

#: ../source/faq/concurrency.txt:37
msgid ""
"For example, when locking a collection for writing (using mode X), both "
"the corresponding database lock and the global lock must be locked in "
"intent exclusive (IX) mode. A single database can simultaneously be "
"locked in IS and IX mode, but an exclusive (X) lock cannot coexist with "
"any other modes, and a shared (S) lock can only coexists with intent "
"shared (IS) locks."
msgstr ""

#: ../source/faq/concurrency.txt:46
msgid ""
"Locks are fair, with reads and writes being queued in order. However, to "
"optimize throughput, when one request is granted, all other compatible "
"requests will be granted at the same time, potentially releasing them "
"before a conflicting request.  For example, consider a case in which an X"
" lock was just released, and in which the conflict queue contains the "
"following items:"
msgstr ""

#: ../source/faq/concurrency.txt:53
msgid "IS |rarr| IS |rarr| X |rarr| X |rarr| S |rarr| IS"
msgstr ""

#: ../source/faq/concurrency.txt:55
msgid ""
"In strict first-in, first-out (FIFO) ordering, only the first two IS "
"modes would be granted. Instead MongoDB will actually grant all IS and S "
"modes, and once they all drain, it will grant X, even if new IS or S "
"requests have been queued in the meantime. As a grant will always move "
"all other requests ahead in the queue, no starvation of any request is "
"possible."
msgstr ""

#: ../source/faq/concurrency.txt:62 ../source/faq/concurrency.txt:121
msgid ""
"In :method:`db.serverStatus()` and :method:`db.currentOp()` output, the "
"lock modes are represented as follows:"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:5
msgid "Lock Mode"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:6
msgid "Description"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:8
msgid "``R``"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:10
msgid "Represents Shared (S) lock."
msgstr ""

#: ../source/includes/fact-lock-modes.rst:12
msgid "``W``"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:14
msgid "Represents Exclusive (X) lock."
msgstr ""

#: ../source/includes/fact-lock-modes.rst:16
msgid "``r``"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:18
msgid "Represents Intent Shared (IS) lock."
msgstr ""

#: ../source/includes/fact-lock-modes.rst:20
msgid "``w``"
msgstr ""

#: ../source/includes/fact-lock-modes.rst:22
msgid "Represents Intent Exclusive (IX) lock."
msgstr ""

#: ../source/faq/concurrency.txt:67
msgid ""
"See the Wikipedia page on `Multiple granularity locking "
"<http://en.wikipedia.org/wiki/Multiple_granularity_locking>`_ for more "
"information."
msgstr ""

#: ../source/faq/concurrency.txt:73
msgid "How granular are locks in MongoDB?"
msgstr ""

#: ../source/faq/concurrency.txt:78
msgid "For WiredTiger"
msgstr ""

#: ../source/faq/concurrency.txt:80
msgid ""
"Beginning with version 3.0, MongoDB ships with the :ref:`WiredTiger "
"<storage-wiredtiger>` storage engine."
msgstr ""

#: ../source/includes/fact-wiredtiger-locks.rst:1
msgid ""
"For most read and write operations, WiredTiger uses optimistic "
"concurrency control. WiredTiger uses only intent locks at the global, "
"database and collection levels. When the storage engine detects conflicts"
" between two operations, one will incur a write conflict causing MongoDB "
"to transparently retry that operation."
msgstr ""

#: ../source/includes/fact-wiredtiger-locks.rst:7
msgid ""
"Some global operations, typically short lived operations involving "
"multiple databases, still require a global \"instance-wide\" lock. Some "
"other operations, such as dropping a collection, still require an "
"exclusive database lock."
msgstr ""

#: ../source/faq/concurrency.txt:86
msgid "For MMAPv1"
msgstr ""

#: ../source/faq/concurrency.txt:88
msgid ""
"The MMAPv1 storage engine uses collection-level locking as of the 3.0 "
"release series, an improvement on earlier versions in which the database "
"lock was the finest-grain lock. Third-party storage engines may either "
"use collection-level locking or implement their own finer-grained "
"concurrency control."
msgstr ""

#: ../source/faq/concurrency.txt:94
msgid ""
"For example, if you have six collections in a database using the MMAPv1 "
"storage engine and an operation takes a collection-level write lock, the "
"other five collections are still available for read and write operations."
" An exclusive database lock makes all six collections unavailable for the"
" duration of the operation holding the lock."
msgstr ""

#: ../source/faq/concurrency.txt:101
msgid "How do I see the status of locks on my :binary:`~bin.mongod` instances?"
msgstr ""

#: ../source/faq/concurrency.txt:103
msgid ""
"For reporting on lock utilization information on locks, use any of the "
"following methods:"
msgstr ""

#: ../source/faq/concurrency.txt:106
msgid ":method:`db.serverStatus()`,"
msgstr ""

#: ../source/faq/concurrency.txt:107
msgid ":method:`db.currentOp()`,"
msgstr ""

#: ../source/faq/concurrency.txt:108
msgid ":doc:`mongotop </reference/program/mongotop>`,"
msgstr ""

#: ../source/faq/concurrency.txt:109
msgid ":doc:`mongostat </reference/program/mongostat>`, and/or"
msgstr ""

#: ../source/faq/concurrency.txt:110
msgid ""
"the |mms-home| or :products:`Ops Manager, an on-premise solution "
"available in MongoDB Enterprise Advanced </mongodb-enterprise-"
"advanced?jmp=docs>`"
msgstr ""

#: ../source/faq/concurrency.txt:115
msgid ""
"Specifically, the :serverstatus:`locks` document in the :doc:`output of "
"serverStatus </reference/command/serverStatus>`, or the "
":data:`~currentOp.locks` field in the :doc:`current operation reporting "
"</reference/method/db.currentOp>` provides insight into the type of locks"
" and amount of lock contention in your :binary:`~bin.mongod` instance."
msgstr ""

#: ../source/faq/concurrency.txt:126
msgid "To terminate an operation, use :method:`db.killOp()`."
msgstr ""

#: ../source/faq/concurrency.txt:133
msgid "Does a read or write operation ever yield the lock?"
msgstr ""

#: ../source/faq/concurrency.txt:135
msgid "In some situations, read and write operations can yield their locks."
msgstr ""

#: ../source/faq/concurrency.txt:137
msgid ""
"Long running read and write operations, such as queries, updates, and "
"deletes, yield under many conditions.  MongoDB operations can also yield "
"locks between individual document modifications in write operations that "
"affect multiple documents like :method:`~db.collection.update()` with the"
" ``multi`` parameter."
msgstr ""

#: ../source/faq/concurrency.txt:143
msgid ""
"For storage engines supporting document level :term:`concurrency "
"control`, such as :doc:`WiredTiger </core/wiredtiger>`, yielding is not "
"necessary when accessing storage as the :term:`intent locks <intent "
"lock>`, held at the global, database and collection level, do not block "
"other readers and writers. However, operations will periodically yield, "
"such as:"
msgstr ""

#: ../source/faq/concurrency.txt:150
msgid ""
"to avoid long-lived storage transactions because these can potentially "
"require holding a large amount of data in memory;"
msgstr ""

#: ../source/faq/concurrency.txt:153
msgid ""
"to serve as interruption points so that you can kill long running "
"operations;"
msgstr ""

#: ../source/faq/concurrency.txt:156
msgid ""
"to allow operations that require exclusive access to a collection such as"
" index/collection drops and creations."
msgstr ""

#: ../source/faq/concurrency.txt:159
msgid ""
"MongoDB's :ref:`MMAPv1 <storage-mmapv1>` storage engine uses heuristics "
"based on its access pattern to predict whether data is likely in physical"
" memory before performing a read. If MongoDB *predicts* that the data is "
"not in physical memory, an operation will yield its lock while MongoDB "
"loads the data into memory. Once data is available in memory, the "
"operation will reacquire the lock to complete the operation."
msgstr ""

#: ../source/faq/concurrency.txt:170
msgid "What locks are taken by some common client operations?"
msgstr ""

#: ../source/faq/concurrency.txt:172
msgid ""
"The following table lists some operations and the types of locks they use"
" for document level locking storage engines:"
msgstr ""

#: ../source/faq/concurrency.txt:178
msgid "Operation"
msgstr ""

#: ../source/faq/concurrency.txt:180
msgid "Database"
msgstr ""

#: ../source/faq/concurrency.txt:182
msgid "Collection"
msgstr ""

#: ../source/faq/concurrency.txt:184
msgid "Issue a query"
msgstr ""

#: ../source/faq/concurrency.txt:186 ../source/faq/concurrency.txt:188
#: ../source/faq/concurrency.txt:210 ../source/faq/concurrency.txt:212
msgid "``r`` (Intent Shared)"
msgstr ""

#: ../source/faq/concurrency.txt:190
msgid "Insert data"
msgstr ""

#: ../source/faq/concurrency.txt:192 ../source/faq/concurrency.txt:194
#: ../source/faq/concurrency.txt:198 ../source/faq/concurrency.txt:200
#: ../source/faq/concurrency.txt:204 ../source/faq/concurrency.txt:206
#: ../source/faq/concurrency.txt:222 ../source/faq/concurrency.txt:224
msgid "``w`` (Intent Exclusive)"
msgstr ""

#: ../source/faq/concurrency.txt:196
msgid "Remove data"
msgstr ""

#: ../source/faq/concurrency.txt:202
msgid "Update data"
msgstr ""

#: ../source/faq/concurrency.txt:208
msgid "Perform Aggregation"
msgstr ""

#: ../source/faq/concurrency.txt:214
msgid "Create an index (Foreground)"
msgstr ""

#: ../source/faq/concurrency.txt:216
msgid "``W`` (Exclusive)"
msgstr ""

#: ../source/faq/concurrency.txt:220
msgid "Create an index (Background)"
msgstr ""

#: ../source/faq/concurrency.txt:226
msgid "List collections"
msgstr ""

#: ../source/faq/concurrency.txt:228
msgid "``R`` (Shared)"
msgstr ""

#: ../source/faq/concurrency.txt:232
msgid "Map-reduce"
msgstr ""

#: ../source/faq/concurrency.txt:234
msgid "``W`` (Exclusive) and ``R`` (Shared)"
msgstr ""

#: ../source/faq/concurrency.txt:236
msgid "``w`` (Intent Exclusive) and ``r`` (Intent Shared)"
msgstr ""

#: ../source/faq/concurrency.txt:239
msgid "Which administrative commands lock the database?"
msgstr ""

#: ../source/faq/concurrency.txt:241
msgid ""
"Certain administrative commands can exclusively lock the database for "
"extended periods of time. In some deployments, for large databases, you "
"may consider taking the :binary:`~bin.mongod` instance offline so that "
"clients are not affected. For example, if a :binary:`~bin.mongod` is part"
" of a :term:`replica set`, take the :binary:`~bin.mongod` offline and let"
" other members of the set service load while maintenance is in progress."
msgstr ""

#: ../source/faq/concurrency.txt:248
msgid ""
"The following administrative operations require an exclusive lock at the "
"database level for extended periods:"
msgstr ""

#: ../source/faq/concurrency.txt:253 ../source/faq/concurrency.txt:295
msgid "Commands"
msgstr ""

#: ../source/faq/concurrency.txt:254 ../source/faq/concurrency.txt:296
msgid "Methods"
msgstr ""

#: ../source/faq/concurrency.txt:256
msgid ":dbcommand:`cloneCollectionAsCapped`"
msgstr ""

#: ../source/faq/concurrency.txt:259
msgid ":dbcommand:`compact`"
msgstr ""

#: ../source/faq/concurrency.txt:262
msgid ":dbcommand:`convertToCapped`"
msgstr ""

#: ../source/faq/concurrency.txt:265
msgid ""
":dbcommand:`copydb`. This operation may lock all databases. See :ref"
":`faq-concurrency-lock-multiple-dbs`."
msgstr ""

#: ../source/faq/concurrency.txt:268
msgid ""
":method:`db.copyDatabase()`. This operation may lock all databases. See "
":ref:`faq-concurrency-lock-multiple-dbs`."
msgstr ""

#: ../source/faq/concurrency.txt:271
msgid ""
":dbcommand:`create` when creating a very large (i.e. many gigabytes) "
"capped collection"
msgstr ""

#: ../source/faq/concurrency.txt:273
msgid ""
":method:`db.createCollection()` when creating a very large (i.e. many "
"gigabytes) capped collection"
msgstr ""

#: ../source/faq/concurrency.txt:276
msgid ""
":dbcommand:`createIndexes` for indexes *without* ``background`` set to "
"``true``"
msgstr ""

#: ../source/faq/concurrency.txt:279
msgid ""
":method:`db.collection.createIndex()` and "
":method:`db.collection.createIndexes()` issued *without* ``background`` "
"set to ``true``"
msgstr ""

#: ../source/faq/concurrency.txt:283
msgid ":dbcommand:`reIndex`"
msgstr ""

#: ../source/faq/concurrency.txt:284
msgid ":method:`db.collection.reIndex()`"
msgstr ""

#: ../source/faq/concurrency.txt:286
msgid ":dbcommand:`repairDatabase`"
msgstr ""

#: ../source/faq/concurrency.txt:287
msgid ":method:`db.repairDatabase()`"
msgstr ""

#: ../source/faq/concurrency.txt:290
msgid ""
"The following administrative operations lock the database but only hold "
"the lock for a very short time:"
msgstr ""

#: ../source/faq/concurrency.txt:298
msgid ":dbcommand:`authenticate`"
msgstr ""

#: ../source/faq/concurrency.txt:300
msgid ":method:`db.auth()`"
msgstr ""

#: ../source/faq/concurrency.txt:303
msgid ":dbcommand:`createUser`"
msgstr ""

#: ../source/faq/concurrency.txt:304
msgid ":method:`db.createUser()`"
msgstr ""

#: ../source/faq/concurrency.txt:307
msgid ":dbcommand:`dropIndexes`"
msgstr ""

#: ../source/faq/concurrency.txt:308
msgid ":method:`db.collection.dropIndex()`"
msgstr ""

#: ../source/faq/concurrency.txt:310
msgid ":dbcommand:`getLastError`"
msgstr ""

#: ../source/faq/concurrency.txt:311
msgid ":method:`db.getLastError()`"
msgstr ""

#: ../source/faq/concurrency.txt:313
msgid ":dbcommand:`isMaster`"
msgstr ""

#: ../source/faq/concurrency.txt:314
msgid ":method:`db.isMaster()`"
msgstr ""

#: ../source/faq/concurrency.txt:316
msgid ":dbcommand:`replSetGetStatus`"
msgstr ""

#: ../source/faq/concurrency.txt:317
msgid ":method:`rs.status()`"
msgstr ""

#: ../source/faq/concurrency.txt:320
msgid ":dbcommand:`renameCollection`"
msgstr ""

#: ../source/faq/concurrency.txt:321
msgid ":method:`db.collection.renameCollection()`"
msgstr ""

#: ../source/faq/concurrency.txt:323
msgid ":dbcommand:`serverStatus`"
msgstr ""

#: ../source/faq/concurrency.txt:325
msgid ":method:`db.serverStatus()`"
msgstr ""

#: ../source/faq/concurrency.txt:327
msgid ":ref:`faq-concurrency-lock-multiple-dbs`"
msgstr ""

#: ../source/faq/concurrency.txt:332
msgid "Does a MongoDB operation ever lock more than one database?"
msgstr ""

#: ../source/faq/concurrency.txt:334
msgid "The following MongoDB operations lock multiple databases:"
msgstr ""

#: ../source/faq/concurrency.txt:336
msgid ""
":method:`db.copyDatabase()` must lock the entire :binary:`~bin.mongod` "
"instance at once."
msgstr ""

#: ../source/faq/concurrency.txt:339
msgid ""
":method:`db.repairDatabase()` obtains a global write lock and will block "
"other operations until it finishes."
msgstr ""

#: ../source/faq/concurrency.txt:342
msgid ""
":doc:`User authentication </core/authentication>` requires a read lock on"
" the ``admin`` database for deployments using :ref:`2.6 user credentials "
"<admin-system-users-collection>`. For deployments using the 2.4 schema "
"for user credentials, authentication locks the ``admin`` database as well"
" as the database the user is accessing."
msgstr ""

#: ../source/faq/concurrency.txt:348
msgid ""
"All writes to a replica set's :term:`primary` lock both the database "
"receiving the writes and then the ``local`` database for a short time. "
"The lock for the ``local`` database allows the :binary:`~bin.mongod` to "
"write to the primary's :term:`oplog` and accounts for a small portion of "
"the total time of the operation."
msgstr ""

#: ../source/faq/concurrency.txt:354
msgid ""
"Replica set member :doc:`state transitions </reference/replica-states>` "
"take global exlusive lock."
msgstr ""

#: ../source/faq/concurrency.txt:358
msgid "How does sharding affect concurrency?"
msgstr ""

#: ../source/faq/concurrency.txt:360
msgid ""
":term:`Sharding <sharding>` improves concurrency by distributing "
"collections over multiple :binary:`~bin.mongod` instances, allowing shard"
" servers (i.e. :binary:`~bin.mongos` processes) to perform any number of "
"operations concurrently to the various downstream :binary:`~bin.mongod` "
"instances."
msgstr ""

#: ../source/includes/extracts/lock-sharding.rst:1
msgid ""
"In a sharded cluster, locks apply to each individual shard, not to the "
"whole cluster; i.e. each :binary:`~bin.mongod` instance is independent of"
" the others in the sharded cluster and uses its own :ref:`locks <faq-"
"concurrency-locking>`. The operations on one :binary:`~bin.mongod` "
"instance do not block the operations on any others."
msgstr ""

#: ../source/faq/concurrency.txt:371
msgid "How does concurrency affect a replica set primary?"
msgstr ""

#: ../source/faq/concurrency.txt:373
msgid ""
"With replica sets, when MongoDB writes to a collection on the "
":term:`primary`, MongoDB also writes to the primary's :term:`oplog`, "
"which is a special collection in the ``local`` database. Therefore, "
"MongoDB must lock both the collection's database and the ``local`` "
"database. The :binary:`~bin.mongod` must lock both databases at the same "
"time to keep the database consistent and ensure that write operations, "
"even with replication, are \"all-or-nothing\" operations."
msgstr ""

#: ../source/includes/extracts/lock-replica-set-primary.rst:1
msgid ""
"When writing to a :term:`replica set`, the lock's scope applies to the "
":term:`primary`."
msgstr ""

#: ../source/faq/concurrency.txt:384
msgid "How does concurrency affect secondaries?"
msgstr ""

#: ../source/faq/concurrency.txt:386
msgid ""
"In :term:`replication`, MongoDB does not apply writes serially to "
":term:`secondaries <secondary>`. Secondaries collect oplog entries in "
"batches and then apply those batches in parallel. Secondaries do not "
"allow reads while applying the write operations, and apply write "
"operations in the order that they appear in the oplog."
msgstr ""

#: ../source/faq/concurrency.txt:394
msgid "Does MongoDB support transactions?"
msgstr ""

#: ../source/includes/extracts/transactions-faq.rst:1
msgid ""
"Because a single document can contain related data that would otherwise "
"be modeled across separate parent-child tables in a relational schema, "
"MongoDB's atomic single-document operations already provide transaction "
"semantics that meet the data integrity needs of the majority of "
"applications. One or more fields may be written in a single operation, "
"including updates to multiple sub-documents and elements of an array. The"
" guarantees provided by MongoDB ensure complete isolation as a document "
"is updated; any errors cause the operation to roll back so that clients "
"receive a consistent view of the document."
msgstr ""

#: ../source/includes/extracts/transactions-faq.rst:11
msgid ""
"Starting in version 4.0, for situations that require atomicity for "
"updates to multiple documents or consistency between reads to multiple "
"documents, MongoDB provides :manual:`multi-document transactions "
"</core/transactions>` for replica sets, and transactions for sharded "
"clusters are scheduled for MongoDB 4.2."
msgstr ""

#: ../source/includes/extracts/transactions-usage.rst:2
msgid ""
"In most cases, multi-document transaction incurs a greater performance "
"cost over single document writes, and the availability of multi-document "
"transaction should not be a replacement for effective schema design. For "
"many scenarios, the :ref:`denormalized data model (embedded documents and"
" arrays) <data-modeling-embedding>` will continue to be optimal for your "
"data and use cases. That is, for many scenarios, modeling your data "
"appropriately will minimize the need for multi-document transactions."
msgstr ""

#: ../source/includes/fact-upcoming.rst:1
msgid ""
"The development, release, and timing of any features or functionality "
"described for our products remains at our sole discretion. This "
"information is merely intended to outline our general product direction "
"and it should not be relied on in making a purchasing decision nor is "
"this a commitment, promise or legal obligation to deliver any material, "
"code, or functionality."
msgstr ""

#: ../source/faq/concurrency.txt:406
msgid "What isolation guarantees does MongoDB provide?"
msgstr ""

#: ../source/faq/concurrency.txt:408
msgid ""
"Depending on the read concern, clients can see the results of writes "
"before the writes are :term:`durable`. To control whether the data read "
"may be rolled back or not, clients can use the ``readConcern`` option."
msgstr ""

#: ../source/faq/concurrency.txt:412
msgid "For information, see:"
msgstr ""

#: ../source/faq/concurrency.txt:414
msgid ":doc:`/core/read-isolation-consistency-recency`"
msgstr ""

#: ../source/faq/concurrency.txt:416
msgid ":doc:`/core/write-operations-atomicity`"
msgstr ""

#: ../source/faq/concurrency.txt:418
msgid ":doc:`/reference/read-concern`"
msgstr ""

#~ msgid ""
#~ "MongoDB uses reader-writer locks that"
#~ " allow concurrent readers shared access "
#~ "to a resource, such as a database"
#~ " or collection, but give exclusive "
#~ "access to a single write operation."
#~ msgstr ""

#~ msgid ""
#~ "MongoDB uses multi-granularity locking "
#~ "[#mgl-ref]_ that allows operations to "
#~ "lock at the global, database or "
#~ "collection level, and allows for "
#~ "individual storage engines to implement "
#~ "their own concurrency control below the"
#~ " collection (i.e., at the document-"
#~ "level in WiredTiger)."
#~ msgstr ""

#~ msgid ""
#~ "Beginning with version 3.0, MongoDB "
#~ "ships with the :ref:`WiredTiger <storage-"
#~ "wiredtiger>` storage engine, which uses "
#~ "optimistic concurrency control for most "
#~ "read and write operations. WiredTiger "
#~ "uses only intent locks at the "
#~ "global, database and collection levels. "
#~ "When the storage engine detects "
#~ "conflicts between two operations, one "
#~ "will incur a write conflict causing "
#~ "MongoDB to transparently retry that "
#~ "operation."
#~ msgstr ""

#~ msgid ""
#~ "Specifically, the :data:`~serverStatus.locks` "
#~ "document in the :doc:`output of "
#~ "serverStatus </reference/command/serverStatus>`, or "
#~ "the :data:`~currentOp.locks` field in the "
#~ ":doc:`current operation reporting "
#~ "</reference/method/db.currentOp>` provides insight "
#~ "into the type of locks and amount"
#~ " of lock contention in your "
#~ ":program:`mongod` instance."
#~ msgstr ""

#~ msgid ""
#~ "MongoDB's :ref:`mmapv1 <storage-mmapv1>` "
#~ "storage engine uses heuristics based on"
#~ " its access pattern to predict "
#~ "whether data is likely in physical "
#~ "memory before performing a read. If "
#~ "MongoDB *predicts* that the data is "
#~ "not in physical memory, an operation "
#~ "will yield its lock while MongoDB "
#~ "loads the data into memory. Once "
#~ "data is available in memory, the "
#~ "operation will reacquire the lock to "
#~ "complete the operation."
#~ msgstr ""

#~ msgid ""
#~ "For storage engines supporting document "
#~ "level :term:`concurrency control`, yielding is"
#~ " not necessary when accessing storage, "
#~ "as the :term:`intent locks <intent "
#~ "lock>` held at the global, database "
#~ "and collection level do not block "
#~ "other readers and writers."
#~ msgstr ""

#~ msgid ""
#~ "Each :program:`mongod` instance is independent"
#~ " of the others in the shard "
#~ "cluster and uses its own :ref:`locks "
#~ "<faq-concurrency-locking>`. The operations "
#~ "on one :program:`mongod` instance do not"
#~ " block the operations on any others."
#~ msgstr ""

#~ msgid ""
#~ "In :term:`replication`, when MongoDB writes"
#~ " to a collection on the "
#~ ":term:`primary`, MongoDB also writes to "
#~ "the primary's :term:`oplog`, which is a"
#~ " special collection in the ``local`` "
#~ "database.  Therefore, MongoDB must lock "
#~ "both the collection's database and the"
#~ " ``local`` database. The :program:`mongod` "
#~ "must lock both databases at the "
#~ "same time to keep the database "
#~ "consistent and ensure that write "
#~ "operations, even with replication, are "
#~ "\"all-or-nothing\" operations."
#~ msgstr ""

#~ msgid ""
#~ "MongoDB can apply several writes in "
#~ "parallel on replica set secondaries, in"
#~ " two phases:"
#~ msgstr ""

#~ msgid ""
#~ "During the first *prefer* phase, under"
#~ " a read lock, the :program:`mongod` "
#~ "ensures that all documents affected by"
#~ " the operations are in memory. During"
#~ " this phase, other clients may "
#~ "execute queries against this member."
#~ msgstr ""

#~ msgid ""
#~ "A thread pool using write locks "
#~ "applies all write operations in the "
#~ "batch as part of a coordinated "
#~ "write phase."
#~ msgstr ""

#~ msgid ""
#~ "What kind of concurrency does MongoDB"
#~ " provide for JavaScript operations?"
#~ msgstr ""

#~ msgid ""
#~ "The V8 JavaScript engine added in "
#~ "2.4 allows multiple JavaScript operations "
#~ "to run at the same time. Prior "
#~ "to 2.4, a single :program:`mongod` could"
#~ " only run a *single* JavaScript "
#~ "operation at once."
#~ msgstr ""

#~ msgid ""
#~ "Read and write operations are atomic "
#~ "with respect to a single document "
#~ "and will always leave the document "
#~ "in a consistent state. This means "
#~ "that readers will never see a "
#~ "partially updated document, and indices "
#~ "will always be consistent with the "
#~ "contents of the collection. Furthermore, "
#~ "a set of read and write operations"
#~ " to a single document are "
#~ "serializable."
#~ msgstr ""

#~ msgid ""
#~ "Non-point-in-time read operations. "
#~ "Suppose a read operation begins at "
#~ "time *t*\\ :sub:`1` and starts reading"
#~ " documents. A write operation then "
#~ "commits an update to a document at"
#~ " some later time *t*\\ :sub:`2`. The"
#~ " reader may see the updated version"
#~ " of the document, and therefore does"
#~ " not see a point-in-time "
#~ "snapshot of the data."
#~ msgstr ""

#~ msgid ""
#~ "Dropped results. Reads may miss matching"
#~ " documents that are updated or "
#~ "deleted during the course of the "
#~ "read operation. However, data that has"
#~ " not been modified during the "
#~ "operation will always be visible."
#~ msgstr ""

#~ msgid ""
#~ "Yes, readers can see the results "
#~ "of writes before they are made "
#~ "durable, regardless of write concern "
#~ "level or journaling configuration. As a"
#~ " result, applications may observe the "
#~ "following behaviors:"
#~ msgstr ""

#~ msgid ""
#~ "MongoDB will allow a concurrent reader"
#~ " to see the result of the write"
#~ " operation before the write is "
#~ "acknowledged to the client application. "
#~ "For details on when writes are "
#~ "acknowledged for different write concern "
#~ "levels, see :doc:`/core/write-concern`."
#~ msgstr ""

#~ msgid ""
#~ "Reads can see data which may "
#~ "subsequently be rolled back in rare "
#~ "cases such as replica set failover "
#~ "or power loss. It does *not* mean"
#~ " that read operations can see "
#~ "documents in a partially written or "
#~ "otherwise inconsistent state."
#~ msgstr ""

#~ msgid ""
#~ "In addition to a shared (S) "
#~ "locking mode for reads and an "
#~ "exclusive (X) locking mode for write "
#~ "operations, intent shared (IS) and "
#~ "intent exclusive (IX) modes indicate an"
#~ " intent to read or write a "
#~ "resource using a finer granularity lock."
#~ "  When locking at a certain "
#~ "granularity all higher levels are locked"
#~ " using an :term:`intent lock`."
#~ msgstr ""

#~ msgid "How do I see the status of locks on my :program:`mongod` instances?"
#~ msgstr ""

#~ msgid ""
#~ "MongoDB does not yield locks when "
#~ "scanning an index even if it "
#~ "predicts that the index is not in"
#~ " memory."
#~ msgstr ""

#~ msgid "Which operations lock the database?"
#~ msgstr ""

#~ msgid ""
#~ "The following table lists common "
#~ "database operations and the types of "
#~ "locks they use."
#~ msgstr ""

#~ msgid "Lock Type"
#~ msgstr ""

#~ msgid "Read lock"
#~ msgstr ""

#~ msgid "Get more data from a :term:`cursor`"
#~ msgstr ""

#~ msgid "Write lock"
#~ msgstr ""

#~ msgid ":term:`Map-reduce <map-reduce>`"
#~ msgstr ""

#~ msgid ""
#~ "Read lock and write lock, unless "
#~ "operations are specified as non-atomic."
#~ " Portions of map-reduce jobs can "
#~ "run concurrently."
#~ msgstr ""

#~ msgid "Create an index"
#~ msgstr ""

#~ msgid ""
#~ "Building an index in the foreground, "
#~ "which is the default, locks the "
#~ "database for extended periods of time."
#~ msgstr ""

#~ msgid ":method:`db.eval()`"
#~ msgstr ""

#~ msgid ""
#~ "Write lock. The :method:`db.eval()` method "
#~ "takes a global write lock while "
#~ "evaluating the JavaScript function. To "
#~ "avoid taking this global write lock, "
#~ "you can use the :dbcommand:`eval` "
#~ "command with ``nolock: true``."
#~ msgstr ""

#~ msgid ":dbcommand:`eval`"
#~ msgstr ""

#~ msgid ""
#~ "Write lock. By default, :dbcommand:`eval` "
#~ "command takes a global write lock "
#~ "while evaluating the JavaScript function. "
#~ "If used with ``nolock: true``, the "
#~ ":dbcommand:`eval` command does *not* take "
#~ "a global write lock while evaluating "
#~ "the JavaScript function. However, the "
#~ "logic within the JavaScript function may"
#~ " take write locks for write "
#~ "operations."
#~ msgstr ""

#~ msgid ":method:`~db.collection.aggregate()`"
#~ msgstr ""

#~ msgid ""
#~ "Certain administrative commands can "
#~ "exclusively lock the database for "
#~ "extended periods of time. In some "
#~ "deployments, for large databases, you "
#~ "may consider taking the :program:`mongod` "
#~ "instance offline so that clients are "
#~ "not affected. For example, if a "
#~ ":program:`mongod` is part of a "
#~ ":term:`replica set`, take the "
#~ ":program:`mongod` offline and let other "
#~ "members of the set service load "
#~ "while maintenance is in progress."
#~ msgstr ""

#~ msgid ""
#~ "The following administrative operations "
#~ "require an exclusive (i.e. write) lock"
#~ " on the database for extended "
#~ "periods:"
#~ msgstr ""

#~ msgid ""
#~ ":method:`db.collection.createIndex()`, when issued "
#~ "*without* setting ``background`` to ``true``,"
#~ msgstr ""

#~ msgid ":dbcommand:`reIndex`,"
#~ msgstr ""

#~ msgid ":dbcommand:`compact`,"
#~ msgstr ""

#~ msgid ":method:`db.repairDatabase()`,"
#~ msgstr ""

#~ msgid ""
#~ ":method:`db.createCollection()`, when creating a "
#~ "very large (i.e. many gigabytes) capped"
#~ " collection,"
#~ msgstr ""

#~ msgid ":method:`db.collection.validate()`, and"
#~ msgstr ""

#~ msgid ""
#~ "The following administrative commands lock "
#~ "the database but only hold the "
#~ "lock for a very short time:"
#~ msgstr ""

#~ msgid ":method:`db.collection.dropIndex()`,"
#~ msgstr ""

#~ msgid ":method:`db.getLastError()`,"
#~ msgstr ""

#~ msgid ":method:`db.isMaster()`,"
#~ msgstr ""

#~ msgid ":method:`rs.status()` (i.e. :dbcommand:`replSetGetStatus`),"
#~ msgstr ""

#~ msgid ":method:`db.auth()`, and"
#~ msgstr ""

#~ msgid ":method:`db.addUser()`."
#~ msgstr ""

#~ msgid ""
#~ ":method:`db.copyDatabase()` must lock the "
#~ "entire :program:`mongod` instance at once."
#~ msgstr ""

#~ msgid ""
#~ ":term:`Journaling <journal>`, which is an "
#~ "internal operation, locks all databases "
#~ "for short intervals. All databases share"
#~ " a single journal."
#~ msgstr ""

#~ msgid ""
#~ "All writes to a replica set's "
#~ ":term:`primary` lock both the database "
#~ "receiving the writes and then the "
#~ "``local`` database for a short time. "
#~ "The lock for the ``local`` database "
#~ "allows the :program:`mongod` to write to"
#~ " the primary's :term:`oplog` and accounts"
#~ " for a small portion of the "
#~ "total time of the operation."
#~ msgstr ""

#~ msgid ""
#~ ":term:`Sharding <sharding>` improves concurrency "
#~ "by distributing collections over multiple "
#~ ":program:`mongod` instances, allowing shard "
#~ "servers (i.e. :program:`mongos` processes) to"
#~ " perform any number of operations "
#~ "concurrently to the various downstream "
#~ ":program:`mongod` instances."
#~ msgstr ""

#~ msgid "MongoDB does not support multi-document transactions."
#~ msgstr ""

#~ msgid ""
#~ "However, MongoDB does provide atomic "
#~ "operations on a single document. Often"
#~ " these document-level atomic operations "
#~ "are sufficient to solve problems that"
#~ " would require ACID transactions in a"
#~ " relational database."
#~ msgstr ""

#~ msgid ""
#~ "For example, in MongoDB, you can "
#~ "embed related data in nested arrays "
#~ "or nested documents within a single "
#~ "document and update the entire document"
#~ " in a single atomic operation. "
#~ "Relational databases might represent the "
#~ "same kind of data with multiple "
#~ "tables and rows, which would require "
#~ "transaction support to update the data"
#~ " atomically."
#~ msgstr ""

#~ msgid ""
#~ "MongoDB provides the following guarantees "
#~ "in the presence of concurrent read "
#~ "and write operations. These guarantees "
#~ "hold on systems configured with either"
#~ " the MMAPv1 or WiredTiger storage "
#~ "engines."
#~ msgstr ""

#~ msgid ""
#~ "Correctness with respect to query "
#~ "predicates, e.g. :method:`db.collection.find()` will"
#~ " only return documents that match and"
#~ " :method:`db.collection.update()` will only write"
#~ " to matching documents."
#~ msgstr ""

#~ msgid ""
#~ "Correctness with respect to sort. For"
#~ " read operations that request a sort"
#~ " order (e.g. :method:`db.collection.find()` or"
#~ " :method:`db.collection.aggregate()`), the sort "
#~ "order will not be violated due to"
#~ " concurrent writes."
#~ msgstr ""

#~ msgid ""
#~ "Although MongoDB provides these strong "
#~ "guarantees for single-document operations, "
#~ "read and write operations may access "
#~ "an arbitrary number of documents during"
#~ " execution.  Multi-document operations do"
#~ " *not* occur transactionally and are "
#~ "not isolated from concurrent writes. "
#~ "This means that the following behaviors"
#~ " are expected under the normal "
#~ "operation of the system, for both "
#~ "the MMAPv1 and WiredTiger storage "
#~ "engines:"
#~ msgstr ""

#~ msgid ""
#~ "Non-serializable operations. Suppose a "
#~ "read operation reads a document *d*\\"
#~ " :sub:`1` at time *t*\\ :sub:`1` and"
#~ " a write operation updates *d*\\ "
#~ ":sub:`1` at some later time *t*\\ "
#~ ":sub:`3`. This introduces a read-write"
#~ " dependency such that, if the "
#~ "operations were to be serialized, the"
#~ " read operation must precede the "
#~ "write operation. But also suppose that"
#~ " the write operation updates document "
#~ "*d*\\ :sub:`2` at time *t*\\ :sub:`2`"
#~ " and the read operation subsequently "
#~ "reads *d*\\ :sub:`2` at some later "
#~ "time *t*\\ :sub:`4`. This introduces a"
#~ " write-read dependency which would "
#~ "instead require the read operation to"
#~ " come *after* the write operation in"
#~ " a serializable schedule. There is a"
#~ " dependency cycle which makes "
#~ "serializability impossible."
#~ msgstr ""

#~ msgid "Can reads see changes that have not been committed to disk?"
#~ msgstr ""

#~ msgid "Other systems refer to these semantics as *read uncommitted*."
#~ msgstr ""

#~ msgid "On this page"
#~ msgstr ""

#~ msgid ""
#~ "Specifically, the :serverstatus:`locks` document "
#~ "in the :doc:`output of serverStatus "
#~ "</reference/command/serverStatus>`, or the "
#~ ":data:`~currentOp.locks` field in the "
#~ ":doc:`current operation reporting "
#~ "</reference/method/db.currentOp>` provides insight "
#~ "into the type of locks and amount"
#~ " of lock contention in your "
#~ ":program:`mongod` instance."
#~ msgstr ""

#~ msgid ""
#~ "For storage engines supporting document "
#~ "level :term:`concurrency control`, such as "
#~ ":doc:`WiredTiger </core/wiredtiger>`, yielding is"
#~ " not necessary when accessing storage "
#~ "as the :term:`intent locks <intent "
#~ "lock>`, held at the global, database "
#~ "and collection level, do not block "
#~ "other readers and writers."
#~ msgstr ""

#~ msgid ""
#~ "In a sharded cluster, locks apply "
#~ "to each individual shard, not to "
#~ "the whole cluster; i.e. each "
#~ ":program:`mongod` instance is independent of"
#~ " the others in the shard cluster "
#~ "and uses its own :ref:`locks <faq-"
#~ "concurrency-locking>`. The operations on "
#~ "one :program:`mongod` instance do not "
#~ "block the operations on any others."
#~ msgstr ""

#~ msgid ""
#~ "With replica sets, when MongoDB writes"
#~ " to a collection on the "
#~ ":term:`primary`, MongoDB also writes to "
#~ "the primary's :term:`oplog`, which is a"
#~ " special collection in the ``local`` "
#~ "database. Therefore, MongoDB must lock "
#~ "both the collection's database and the"
#~ " ``local`` database. The :program:`mongod` "
#~ "must lock both databases at the "
#~ "same time to keep the database "
#~ "consistent and ensure that write "
#~ "operations, even with replication, are "
#~ "\"all-or-nothing\" operations."
#~ msgstr ""

#~ msgid ""
#~ "Write operations are atomic with respect"
#~ " to a single document; i.e. if "
#~ "a write is updating multiple fields "
#~ "in the document, a reader will "
#~ "never see the document with only "
#~ "some of the fields updated."
#~ msgstr ""

#~ msgid ""
#~ "With a standalone :program:`mongod` instance,"
#~ " a set of read and write "
#~ "operations to a single document is "
#~ "serializable. With a replica set, a "
#~ "set of read and write operations "
#~ "to a single document is serializable "
#~ "*only* in the absence of a "
#~ "rollback."
#~ msgstr ""

#~ msgid ""
#~ "Non-point-in-time read operations. "
#~ "Suppose a read operation begins at "
#~ "time *t*\\ :sub:`1` and starts reading"
#~ " documents. A write operation then "
#~ "commits an update to one of the"
#~ " documents at some later time *t*\\"
#~ " :sub:`2`. The reader may see the "
#~ "updated version of the document, and "
#~ "therefore does not see a point-"
#~ "in-time snapshot of the data."
#~ msgstr ""

#~ msgid ""
#~ "Reads may miss matching documents that"
#~ " are updated during the course of "
#~ "the read operation."
#~ msgstr ""

#~ msgid ""
#~ "MongoDB 3.2 introduces :ref:`3.2-rel-notes-"
#~ "readConcern` option. Clients using "
#~ ":readconcern:`majority` ``readConcern`` cannot see"
#~ " the results of writes before they"
#~ " are made :term:`durable`."
#~ msgstr ""

#~ msgid ""
#~ "Readers, using :readconcern:`\"local\"` "
#~ "``readConcern`` can see the results of"
#~ " writes before they are made "
#~ ":term:`durable`, regardless of write concern"
#~ " level or journaling configuration. As "
#~ "a result, applications may observe the"
#~ " following behaviors:"
#~ msgstr ""

#~ msgid ""
#~ "MongoDB will allow a concurrent reader"
#~ " to see the result of the write"
#~ " operation before the write is "
#~ "acknowledged to the client application. "
#~ "For details on when writes are "
#~ "acknowledged for different write concern "
#~ "levels, see :doc:`/reference/write-concern`."
#~ msgstr ""

#~ msgid ""
#~ "Reads can see data which may "
#~ "subsequently be rolled back in cases "
#~ "such as replica set failover or "
#~ "power loss. It does *not* mean "
#~ "that read operations can see documents"
#~ " in a partially written or otherwise"
#~ " inconsistent state."
#~ msgstr ""

