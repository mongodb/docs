#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../source/core/aggregation-pipeline-optimization.txt:3
msgid "Aggregation Pipeline Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:13
msgid ""
"Aggregation pipeline operations have an optimization phase which attempts"
" to reshape the pipeline for improved performance."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:16
msgid ""
"To see how the optimizer transforms a particular aggregation pipeline, "
"include the :method:`explain <db.collection.aggregate()>` option in the "
":method:`db.collection.aggregate()` method."
msgstr ""

#: ../source/includes/fact-optimizations-subject-to-change.rst:1
msgid "Optimizations are subject to change between releases."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:25
msgid "Projection Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:27
msgid ""
"The aggregation pipeline can determine if it requires only a subset of "
"the fields in the documents to obtain the results. If so, the pipeline "
"will only use those required fields, reducing the amount of data passing "
"through the pipeline."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:35
msgid "Pipeline Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:40
msgid "``$project`` or ``$addFields`` + ``$match`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:42
msgid ""
"For an aggregation pipeline that contains a projection stage "
"(:pipeline:`$project` or :pipeline:`$addFields`) followed by a "
":pipeline:`$match` stage, MongoDB moves any filters in the "
":pipeline:`$match` stage that do not require values computed in the "
"projection stage to a new :pipeline:`$match` stage before the projection."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:49
msgid ""
"If an aggregation pipeline contains multiple projection and/or "
":pipeline:`$match` stages, MongoDB performs this optimization for each "
":pipeline:`$match` stage, moving each :pipeline:`$match` filter before "
"all projection stages that the filter does not depend on."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:54
msgid "Consider a pipeline of the following stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:74
msgid ""
"The optimizer breaks up the :pipeline:`$match` stage into four individual"
" filters, one for each key in the :pipeline:`$match` query document. The "
"optimizer then moves each filter before as many projection stages as "
"possible, creating new :pipeline:`$match` stages as needed. Given this "
"example, the optimizer produces the following *optimized* pipeline:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:96
msgid ""
"The :pipeline:`$match` filter ``{ avgTime: { $gt: 7 } }`` depends on the "
":pipeline:`$project` stage to compute the ``avgTime`` field. The "
":pipeline:`$project` stage is the last projection stage in this pipeline,"
" so the :pipeline:`$match` filter on ``avgTime`` could not be moved."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:102
msgid ""
"The ``maxTime`` and ``minTime`` fields are computed in the "
":pipeline:`$addFields` stage but have no dependency on the "
":pipeline:`$project` stage. The optimizer created a new "
":pipeline:`$match` stage for the filters on these fields and placed it "
"before the :pipeline:`$project` stage."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:108
msgid ""
"The :pipeline:`$match` filter ``{ name: \"Joe Schmoe\" }`` does not use "
"any values computed in either the :pipeline:`$project` or "
":pipeline:`$addFields` stages so it was moved to a new :pipeline:`$match`"
" stage before both of the projection stages."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:114
msgid ""
"After optimization, the filter ``{ name: \"Joe Schmoe\" }`` is in a "
":pipeline:`$match` stage at the beginning of the pipeline. This has the "
"added benefit of allowing the aggregation to use an index on the ``name``"
" field when initially querying the collection. See :ref:`aggregation-"
"pipeline-operators-and-performance` for more information."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:124
msgid "``$sort`` + ``$match`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:126
msgid ""
"When you have a sequence with :pipeline:`$sort` followed by a "
":pipeline:`$match`, the :pipeline:`$match` moves before the "
":pipeline:`$sort` to minimize the number of objects to sort. For example,"
" if the pipeline consists of the following stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:136
#: ../source/core/aggregation-pipeline-optimization.txt:189
#: ../source/core/aggregation-pipeline-optimization.txt:225
msgid ""
"During the optimization phase, the optimizer transforms the sequence to "
"the following:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:145
msgid "``$redact`` + ``$match`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:147
msgid ""
"When possible, when the pipeline has the :pipeline:`$redact` stage "
"immediately followed by the :pipeline:`$match` stage, the aggregation can"
" sometimes add a portion of the :pipeline:`$match` stage before the "
":pipeline:`$redact` stage. If the added :pipeline:`$match` stage is at "
"the start of a pipeline, the aggregation can use an index as well as "
"query the collection to limit the number of documents that enter the "
"pipeline. See :ref:`aggregation-pipeline-operators-and-performance` for "
"more information."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:156
#: ../source/core/aggregation-pipeline-optimization.txt:182
msgid "For example, if the pipeline consists of the following stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:163
msgid ""
"The optimizer can add the same :pipeline:`$match` stage before the "
":pipeline:`$redact` stage:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:175
msgid "``$skip`` + ``$limit`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:177
msgid ""
"When you have a sequence with :pipeline:`$skip` followed by a "
":pipeline:`$limit`, the :pipeline:`$limit` moves before the "
":pipeline:`$skip`. With the reordering, the :pipeline:`$limit` value "
"increases by the :pipeline:`$skip` amount."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:197
msgid ""
"This optimization allows for more opportunities for :ref:`agg-sort-limit-"
"coalescence`, such as with ``$sort`` + ``$skip`` + ``$limit`` sequences. "
"See :ref:`agg-sort-limit-coalescence` for details on the coalescence and "
":ref:`agg-sort-skip-limit-sequence` for an example."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:203
msgid ""
"For aggregation operations on :doc:`sharded collections <aggregation-"
"pipeline-sharded-collections>`, this optimization reduces the results "
"returned from each shard."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:210
msgid "``$project`` + ``$skip`` or ``$limit`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:214
msgid ""
"When you have a sequence with :pipeline:`$project` followed by either "
":pipeline:`$skip` or :pipeline:`$limit`, the :pipeline:`$skip` or "
":pipeline:`$limit` moves before :pipeline:`$project`. For example, if the"
" pipeline consists of the following stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:234
msgid ""
"This optimization allows for more opportunities for :ref:`agg-sort-limit-"
"coalescence`, such as with ``$sort`` + ``$limit`` sequences. See :ref"
":`agg-sort-limit-coalescence` for details on the coalescence."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:242
msgid "Pipeline Coalescence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:244
msgid ""
"When possible, the optimization phase coalesces a pipeline stage into its"
" predecessor. Generally, coalescence occurs *after* any sequence "
"reordering optimization."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:251
msgid "``$sort`` + ``$limit`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:253
msgid ""
"When a :pipeline:`$sort` immediately precedes a :pipeline:`$limit`, the "
"optimizer can coalesce the :pipeline:`$limit` into the :pipeline:`$sort`."
" This allows the sort operation to only maintain the top ``n`` results as"
" it progresses, where ``n`` is the specified limit, and MongoDB only "
"needs to store ``n`` items in memory [#coalescence-allowDiskUse]_. See "
":ref:`sort-and-memory` for more information."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:261
msgid ""
"The optimization will still apply when ``allowDiskUse`` is ``true`` and "
"the ``n`` items exceed the :ref:`aggregation memory limit <agg-memory-"
"restrictions>`."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:268
msgid "``$limit`` + ``$limit`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:270
msgid ""
"When a :pipeline:`$limit` immediately follows another :pipeline:`$limit`,"
" the two stages can coalesce into a single :pipeline:`$limit` where the "
"limit amount is the *smaller* of the two initial limit amounts. For "
"example, a pipeline contains the following sequence:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:281
msgid ""
"Then the second :pipeline:`$limit` stage can coalesce into the first "
":pipeline:`$limit` stage and result in a single :pipeline:`$limit` stage "
"where the limit amount ``10`` is the minimum of the two initial limits "
"``100`` and ``10``."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:293
msgid "``$skip`` + ``$skip`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:295
msgid ""
"When a :pipeline:`$skip` immediately follows another :pipeline:`$skip`, "
"the two stages can coalesce into a single :pipeline:`$skip` where the "
"skip amount is the *sum* of the two initial skip amounts. For example, a "
"pipeline contains the following sequence:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:305
msgid ""
"Then the second :pipeline:`$skip` stage can coalesce into the first "
":pipeline:`$skip` stage and result in a single :pipeline:`$skip` stage "
"where the skip amount ``7`` is the sum of the two initial limits ``5`` "
"and ``2``."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:317
msgid "``$match`` + ``$match`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:319
msgid ""
"When a :pipeline:`$match` immediately follows another :pipeline:`$match`,"
" the two stages can coalesce into a single :pipeline:`$match` combining "
"the conditions with an :expression:`$and`. For example, a pipeline "
"contains the following sequence:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:330
msgid ""
"Then the second :pipeline:`$match` stage can coalesce into the first "
":pipeline:`$match` stage and result in a single :pipeline:`$match` stage"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:341
msgid "``$lookup`` + ``$unwind`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:345
msgid ""
"When a :pipeline:`$unwind` immediately follows another "
":pipeline:`$lookup`, and the :pipeline:`$unwind` operates on the ``as`` "
"field of the :pipeline:`$lookup`, the optimizer can coalesce the "
":pipeline:`$unwind` into the :pipeline:`$lookup` stage. This avoids "
"creating large intermediate documents."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:351
msgid "For example, a pipeline contains the following sequence:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:365
msgid ""
"The optimizer can coalesce the :pipeline:`$unwind` stage into the "
":pipeline:`$lookup` stage. If you run the aggregation with ``explain`` "
"option, the ``explain`` output shows the coalesced stage:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:382
msgid "Examples"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:384
msgid ""
"The following examples are some sequences that can take advantage of both"
" sequence reordering and coalescence. Generally, coalescence occurs "
"*after* any sequence reordering optimization."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:391
msgid "``$sort`` + ``$skip`` + ``$limit`` Sequence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:393
msgid ""
"A pipeline contains a sequence of :pipeline:`$sort` followed by a "
":pipeline:`$skip` followed by a :pipeline:`$limit`:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:402
msgid ""
"First, the optimizer performs the :ref:`agg-skip-limit-optimization` to "
"transforms the sequence to the following:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:411
msgid ""
"The :ref:`agg-skip-limit-optimization` increases the :pipeline:`$limit` "
"amount with the reordering. See :ref:`agg-skip-limit-optimization` for "
"details."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:415
msgid ""
"The reordered sequence now has :pipeline:`$sort` immediately preceding "
"the :pipeline:`$limit`, and the pipeline can coalesce the two stages to "
"decrease memory usage during the sort operation. See :ref:`agg-sort-"
"limit-coalescence` for more information."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:421
msgid "``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` Sequence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:423
msgid ""
"A pipeline contains a sequence of alternating :pipeline:`$limit` and "
":pipeline:`$skip` stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:433
msgid ""
"The :ref:`agg-skip-limit-optimization` reverses the position of the ``{ "
"$skip: 5 }`` and ``{ $limit: 10 }`` stages and increases the limit "
"amount:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:444
msgid ""
"The optimizer then coalesces the two :pipeline:`$limit` stages into a "
"single :pipeline:`$limit` stage and the two :pipeline:`$skip` stages into"
" a single :pipeline:`$skip` stage. The resulting sequence is the "
"following:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:454
msgid ""
"See :ref:`agg-limit-limit-coalescence` and :ref:`agg-skip-skip-"
"coalescence` for details."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:458
msgid ""
":method:`explain <db.collection.aggregate()>` option in the "
":method:`db.collection.aggregate()`"
msgstr ""

#~ msgid "On this page"
#~ msgstr ""

