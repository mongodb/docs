.. _kotlin-sync-aggregation-expression-operations:

=================================
Aggregation Expression Operations
=================================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference

.. meta::
   :keywords: transform data, fluent interface

Overview
--------

In this guide, you can learn how to use the {+driver-short+} to construct
expressions for use in aggregation pipelines. You can perform
expression operations with discoverable, typesafe {+language+} methods rather
than by using BSON documents. Because these methods follow the fluent interface
pattern, you can chain aggregation operations together to create code
that is compact and naturally readable.

The operations in this guide use methods from the
`com.mongodb.client.model.mql <{+core-api+}/client/model/mql/package-summary.html>`__ package.
These methods provide an idiomatic way to use the Query API,
the mechanism by which the driver interacts with a MongoDB deployment. To learn more
about the Query API, see the :manual:`Server manual documentation </query-api/>`.

How to Use Operations
---------------------

The examples in this guide assume that you include the following imports
in your code:

.. code-block:: kotlin
   :copyable: true

   import com.mongodb.client.model.Aggregates
   import com.mongodb.client.model.Accumulators
   import com.mongodb.client.model.Projections
   import com.mongodb.client.model.Filters
   import com.mongodb.client.model.mql.MqlValues

To access document fields in an expression, you must reference the
current document being processed by the aggregation pipeline by using the
``current()`` method. To access the value of a
field, you must use the appropriately typed method, such as
``getString()`` or ``getDate()``. When you specify the type for a field,
you ensure that the driver provides only those methods which are
compatible with that type. The following code shows how to reference a
string field called ``name``:

.. code-block:: kotlin
   :copyable: true

   current().getString("name")

To specify a value in an operation, pass it to the ``of()`` constructor method to
convert it to a valid type. The following code shows how to reference a
value of ``1.0``:

.. code-block:: kotlin
   :copyable: true

   of(1.0)

To create an operation, chain a method to your field or value reference.
You can build more complex operations by chaining multiple methods.

The following example creates an operation to find patients in New
Mexico who have visited the doctor’s office at least once. The operation
performs the following actions:

- Checks if the size of the ``visitDates`` array value is greater than ``0``
  by using the ``gt()`` method
- Checks if the ``state`` field value is “New Mexico” by using the
  ``eq()`` method

The ``and()`` method links these operations so that the pipeline stage
matches only documents that meet both criteria.

.. code-block:: kotlin
   :copyable: true

   current()
       .getArray("visitDates")
       .size()
       .gt(of(0))
       .and(current()
           .getString("state")
           .eq(of("New Mexico")))

While some aggregation stages, such as ``group()``, accept operations
directly, other stages expect that you first include your operation in a
method such as ``computed()`` or ``expr()``. These methods, which take
values of type ``TExpression``, allow you to use your expressions in
certain aggregations.

To complete your aggregation pipeline stage, include your expression
in an aggregates builder method. The following list provides examples of
how to include your expression in common aggregates builder methods:

- ``match(expr(<expression>))``
- ``project(fields(computed("<field name>", <expression>)))``
- ``group(<expression>)``

To learn more about these methods, see the :ref:`kotlin-sync-aggregation` guide.

Constructor Methods
-------------------

You can use these constructor methods to define values for use in {+language+} aggregation
expressions.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Method
     - Description

   * - `current() <{+core-api+}/client/model/mql/MqlValues.html#current()>`__
     - References the current document being processed by the aggregation pipeline.

   * - `currentAsMap() <{+core-api+}/client/model/mql/MqlValues.html#currentAsMap()>`__
     - References the current document being processed by the aggregation pipeline as a map value.

   * - | `of() for MqlBoolean <{+core-api+}/client/model/mql/MqlValues.html#of(boolean)>`__
       | `of() for MqlNumber (double) <{+core-api+}/client/model/mql/MqlValues.html#of(double)>`__
       | `of() for MqlNumber (Decimal128) <{+core-api+}/client/model/mql/MqlValues.html#of(org.bson.types.Decimal128)>`__
       | `of() for MqlInteger (int) <{+core-api+}/client/model/mql/MqlValues.html#of(int)>`__
       | `of() for MqlInteger (long) <{+core-api+}/client/model/mql/MqlValues.html#of(long)>`__
       | `of() for MqlString <{+core-api+}/client/model/mql/MqlValues.html#of(java.lang.String)>`__
       | `of() for MqlDate <{+core-api+}/client/model/mql/MqlValues.html#of(java.time.Instant)>`__
       | `of() for MqlDocument <{+core-api+}/client/model/mql/MqlValues.html#of(org.bson.conversions.Bson)>`__

     - Returns an ``MqlValue`` type corresponding to the provided primitive.

   * - `ofArray() <{+core-api+}/client/model/mql/MqlValues.html#ofArray(T...)>`__

       | **Typed Variants**:
       | `ofBooleanArray() <{+core-api+}/client/model/mql/MqlValues.html#ofBooleanArray(boolean...)>`__
       | `ofDateArray() <{+core-api+}/client/model/mql/MqlValues.html#ofDateArray(java.time.Instant...)>`__
       | `ofIntegerArray() <{+core-api+}/client/model/mql/MqlValues.html#ofIntegerArray(int...)>`__
       | `ofNumberArray() <{+core-api+}/client/model/mql/MqlValues.html#ofNumberArray(double...)>`__
       | `ofStringArray() <{+core-api+}/client/model/mql/MqlValues.html#ofStringArray(java.lang.String...)>`__

     - Returns an array of ``MqlValue`` types corresponding to the provided array of primitives.

   * - `ofEntry() <{+core-api+}/client/model/mql/MqlValues.html#ofEntry(com.mongodb.client.model.mql.MqlString,T)>`__
     - Returns an entry value.

   * - `ofMap() <{+core-api+}/client/model/mql/MqlValues.html#ofMap()>`__
     - Returns an empty map value.

   * - `ofNull() <{+core-api+}/client/model/mql/MqlValues.html#ofNull()>`__
     - Returns the null value as exists in the Query API.

.. important::

   When you provide a value to one of these methods, the driver treats
   it literally. For example, ``of("$x")`` represents the string value
   ``"$x"``, rather than a field named ``x``.

Refer to any of the sections under :ref:`Operations
<kotlin-sync-aggregation-expression-ops-section>` for examples using these
methods.

.. _kotlin-sync-aggregation-expression-ops-section:

Operations
----------

The following sections provide information and examples for
aggregation expression operations available in the driver.
The operations are categorized by purpose and functionality.

Each section has a table that describes aggregation methods
available in the driver and corresponding expression operators in the
Query API. The method names link to API documentation and the
aggregation pipeline operator names link to descriptions and examples in
the Server manual documentation. While each method is effectively
equivalent to the corresponding aggregation operator, they may differ in
expected parameters and implementation.

The example in each section uses the ``listOf()`` method to create a
pipeline from the aggregation stage. Then, each example passes the
pipeline to the ``aggregate()`` method of ``MongoCollection``.

.. note::

   The driver generates a Query API expression that may be different
   from the Query API expression provided in each example. However,
   both expressions will produce the same aggregation result.

.. important::

   The driver does not provide methods for all aggregation pipeline operators in
   the Query API. To use an unsupported operation in an
   aggregation, you must define the entire expression using the BSON ``Document``
   type.
   
.. TODO Add to note once Kotlin Sync Document ata format page is written:
.. To learn more about the ``Document`` type, see the :ref:`<kotlin-sync-document-format>` guide.

Arithmetic Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform an arithmetic operation on a value of type ``MqlInteger`` or
``MqlNumber`` using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - | `abs() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#abs()>`__
       | `abs() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#abs()>`__

     - :manual:`$abs </reference/operator/aggregation/abs/>`

   * - | `add() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#add(int)>`__
       | `add() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#add(com.mongodb.client.model.mql.MqlNumber)>`__

     - :manual:`$add </reference/operator/aggregation/add/>`

   * - `divide() <{+core-api+}/client/model/mql/MqlNumber.html#divide(com.mongodb.client.model.mql.MqlNumber)>`__
     - :manual:`$divide </reference/operator/aggregation/divide/>`

   * - | `multiply() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#multiply(int)>`__
       | `multiply() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#multiply(com.mongodb.client.model.mql.MqlNumber)>`__

     - :manual:`$multiply </reference/operator/aggregation/multiply/>`

   * - `round() <{+core-api+}/client/model/mql/MqlNumber.html#round()>`__
     - :manual:`$round </reference/operator/aggregation/round/>`

   * - | `subtract() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#subtract(int)>`__
       | `subtract() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#subtract(com.mongodb.client.model.mql.MqlNumber)>`__

     - :manual:`$subtract </reference/operator/aggregation/subtract/>`

Suppose you have weather data for a specific year that includes the
precipitation measurement (in inches) for each day. You want to find the
average precipitation, in millimeters, for each month.

The ``multiply()`` operator multiplies the ``precipitation`` field by
``25.4`` to convert the field value to millimeters. The ``avg()`` accumulator method
returns the average as the ``avgPrecipMM`` field. The ``group()`` method
groups the values by month given in each document's ``date`` field.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-arithmetic-aggregation
   :end-before: end-arithmetic-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in the
Query API:

.. code-block:: javascript
   :copyable: true

   [ { $group: {
       _id: { $month: "$date" },
       avgPrecipMM: {
           $avg: { $multiply: ["$precipitation", 25.4] } }
   } } ]

Array Operations
~~~~~~~~~~~~~~~~

You can perform an array operation on a value of type ``MqlArray``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `all() <{+core-api+}/client/model/mql/MqlArray.html#all(java.util.function.Function)>`__
     - :manual:`$allElementsTrue </reference/operator/aggregation/allElementsTrue/>`

   * - `any() <{+core-api+}/client/model/mql/MqlArray.html#any(java.util.function.Function)>`__
     - :manual:`$anyElementTrue </reference/operator/aggregation/anyElementTrue/>`

   * - `concat() <{+core-api+}/client/model/mql/MqlArray.html#concat(com.mongodb.client.model.mql.MqlArray)>`__
     - :manual:`$concatArrays </reference/operator/aggregation/concatArrays/>`

   * - `concatArrays() <{+core-api+}/client/model/mql/MqlArray.html#concatArrays(java.util.function.Function)>`__
     - :manual:`$concatArrays </reference/operator/aggregation/concatArrays/>`

   * - `contains() <{+core-api+}/client/model/mql/MqlArray.html#contains(T)>`__
     - :manual:`$in </reference/operator/aggregation/in/>`

   * - `distinct() <{+core-api+}/client/model/mql/MqlArray.html#distinct()>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`

   * - `elementAt() <{+core-api+}/client/model/mql/MqlArray.html#elementAt(int)>`__
     - :manual:`$arrayElemAt </reference/operator/aggregation/arrayElemAt/>`

   * - `filter() <{+core-api+}/client/model/mql/MqlArray.html#filter(java.util.function.Function)>`__
     - :manual:`$filter </reference/operator/aggregation/filter/>`

   * - `first() <{+core-api+}/client/model/mql/MqlArray.html#first()>`__
     - :manual:`$first </reference/operator/aggregation/first/>`

   * - `joinStrings() <{+core-api+}/client/model/mql/MqlArray.html#joinStrings(java.util.function.Function)>`__
     - :manual:`$concat </reference/operator/aggregation/concat/>`

   * - `last() <{+core-api+}/client/model/mql/MqlArray.html#last()>`__
     - :manual:`$last </reference/operator/aggregation/last/>`

   * - `map() <{+core-api+}/client/model/mql/MqlArray.html#map(java.util.function.Function)>`__
     - :manual:`$map </reference/operator/aggregation/map/>`

   * - `max() <{+core-api+}/client/model/mql/MqlArray.html#max(T)>`__
     - :manual:`$max </reference/operator/aggregation/max/>`

   * - `maxN() <{+core-api+}/client/model/mql/MqlArray.html#maxN(com.mongodb.client.model.mql.MqlInteger)>`__
     - :manual:`$maxN </reference/operator/aggregation/maxN-array-element/>`

   * - `min() <{+core-api+}/client/model/mql/MqlArray.html#min(T)>`__
     - :manual:`$min </reference/operator/aggregation/min/>`

   * - `minN() <{+core-api+}/client/model/mql/MqlArray.html#minN(com.mongodb.client.model.mql.MqlInteger)>`__
     - :manual:`$minN </reference/operator/aggregation/minN-array-element/>`

   * - `multiply() <{+core-api+}/client/model/mql/MqlArray.html#multiply(java.util.function.Function)>`__
     - :manual:`$multiply </reference/operator/aggregation/multiply/>`

   * - `size() <{+core-api+}/client/model/mql/MqlArray.html#size()>`__
     - :manual:`$size </reference/operator/aggregation/size/>`

   * - `slice() <{+core-api+}/client/model/mql/MqlArray.html#slice(int,int)>`__
     - :manual:`$slice </reference/operator/aggregation/slice/>`

   * - `sum() <{+core-api+}/client/model/mql/MqlArray.html#sum(java.util.function.Function)>`__
     - :manual:`$sum </reference/operator/aggregation/sum/>`

   * - `union() <{+core-api+}/client/model/mql/MqlArray.html#union(com.mongodb.client.model.mql.MqlArray)>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`

   * - `unionArrays() <{+core-api+}/client/model/mql/MqlArray.html#unionArrays(java.util.function.Function)>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`

Suppose you have a collection of movies, each of which contains an array
of nested documents for upcoming showtimes. Each nested document
contains an array that represents the total number of seats in the
theater, where the first array entry is the number of premium seats and
the second entry is the number of regular seats. Each nested document
also contains the number of tickets that have already been bought for
the showtime. A document in this collection might resemble the
following:

.. code-block:: json
   :copyable: false

   {
     "_id": ...,
     "movie": "Hamlet",
     "showtimes": [
       {
         "date": "May 14, 2023, 12:00 PM",
         "seats": [ 20, 80 ],
         "ticketsBought": 100
       },
       {
         "date": "May 20, 2023, 08:00 PM",
         "seats": [ 10, 40 ],
         "ticketsBought": 34
       }]
   }

The ``filter()`` method displays only the results matching the provided
predicate. In this case, the predicate uses ``sum()`` to calculate the
total number of seats and compares that value to the number of ``ticketsBought``
by using the ``lt()`` method. The ``project()`` method stores these
filtered results as a new ``availableShowtimes`` array field.

.. tip::

   You must specify the type of values that an array contains when using
   the ``getArray()`` method to work with the values as any specific
   type. For example, you must specify that an array contains integers
   to perform calculations with those integers elsewhere in
   your application.

   The example in this section specifies that the ``seats`` array
   contains values of type ``MqlDocument`` so that it can extract nested
   fields from each array entry.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-array-aggregation
   :end-before: end-array-aggregation
   :language: kotlin
   :copyable:
   :dedent:

.. note::

   To improve readability, the previous example assigns intermediary values to
   the ``totalSeats`` and ``isAvailable`` variables. If you don't assign
   these intermediary values to variables, the code still produces
   equivalent results.

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       availableShowtimes: {
           $filter: {
               input: "$showtimes",
               as: "showtime",
               cond: { $lt: [ "$$showtime.ticketsBought", { $sum: "$$showtime.seats" } ] }
       } }
   } } ]

Boolean Operations
~~~~~~~~~~~~~~~~~~

You can perform a boolean operation on a value of type ``MqlBoolean``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `and() <{+core-api+}/client/model/mql/MqlBoolean.html#and(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$and </reference/operator/aggregation/and/>`

   * - `not() <{+core-api+}/client/model/mql/MqlBoolean.html#not()>`__
     - :manual:`$not </reference/operator/aggregation/not/>`

   * - `or() <{+core-api+}/client/model/mql/MqlBoolean.html#or(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$or </reference/operator/aggregation/or/>`

Suppose you want to classify very low or high weather temperature
readings (in degrees Fahrenheit) as extreme.

The ``or()`` operator checks to see if temperatures are extreme by comparing
the ``temperature`` field to predefined values by using the ``lt()`` and
``gt()`` methods. The ``project()`` method records this result in the
``extremeTemp`` field.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-boolean-aggregation
   :end-before: end-boolean-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       extremeTemp: { $or: [ { $lt: ["$temperature", 10] },
                             { $gt: ["$temperature", 95] } ] }
   } } ]

Comparison Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform a comparison operation on a value of type ``MqlValue``
using the methods described in this section.

.. tip::

   The ``cond()`` method is similar to the ternary operator in {+language+} and you
   can use it for simple branches based on boolean values. Use
   the ``switchOn()`` methods for more complex comparisons such as performing
   pattern matching on the value type or other arbitrary checks on the value.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `eq() <{+core-api+}/client/model/mql/MqlValue.html#eq(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$eq </reference/operator/aggregation/eq/>`

   * - `gt() <{+core-api+}/client/model/mql/MqlValue.html#gt(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$gt </reference/operator/aggregation/gt/>`

   * - `gte() <{+core-api+}/client/model/mql/MqlValue.html#gte(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$gte </reference/operator/aggregation/gte/>`

   * - `lt() <{+core-api+}/client/model/mql/MqlValue.html#lt(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$lt </reference/operator/aggregation/lt/>`

   * - `lte() <{+core-api+}/client/model/mql/MqlValue.html#lte(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$lte </reference/operator/aggregation/lte/>`

   * - | `max() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#max(com.mongodb.client.model.mql.MqlInteger)>`__
       | `max() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#max(com.mongodb.client.model.mql.MqlNumber)>`__

     - :manual:`$max </reference/operator/aggregation/max/>`

   * - | `min() for MqlInteger <{+core-api+}/client/model/mql/MqlInteger.html#min(com.mongodb.client.model.mql.MqlInteger)>`__
       | `min() for MqlNumber <{+core-api+}/client/model/mql/MqlNumber.html#min(com.mongodb.client.model.mql.MqlNumber)>`__

     - :manual:`$min </reference/operator/aggregation/min/>`

   * - `ne() <{+core-api+}/client/model/mql/MqlValue.html#ne(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$ne </reference/operator/aggregation/ne/>`

The following example shows a pipeline that matches all the documents
where the ``location`` field has the value ``"California"``:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-comparison-aggregation
   :end-before: end-comparison-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $match: { location: { $eq: "California" } } } ]

Conditional Operations
~~~~~~~~~~~~~~~~~~~~~~

You can perform a conditional operation using the methods described in
this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `cond() <{+core-api+}/client/model/mql/MqlBoolean.html#cond(T,T)>`__
     - :manual:`$cond </reference/operator/aggregation/cond/>`

   * - `switchOn() <{+core-api+}/client/model/mql/MqlValue.html#switchOn(java.util.function.Function)>`__

       | **Typed Variants**:
       | `switchArrayOn() <{+core-api+}/client/model/mql/MqlArray.html#switchArrayOn(java.util.function.Function)>`__
       | `switchBooleanOn() <{+core-api+}/client/model/mql/MqlBoolean.html#switchBooleanOn(java.util.function.Function)>`__
       | `switchDateOn() <{+core-api+}/client/model/mql/MqlDate.html#switchDateOn(java.util.function.Function)>`__
       | `switchDocumentOn() <{+core-api+}/client/model/mql/MqlDocument.html#switchDocumentOn(java.util.function.Function)>`__
       | `switchIntegerOn() <{+core-api+}/client/model/mql/MqlInteger.html#switchIntegerOn(java.util.function.Function)>`__
       | `switchMapOn() <{+core-api+}/client/model/mql/MqlMap.html#switchMapOn(java.util.function.Function)>`__
       | `switchNumberOn() <{+core-api+}/client/model/mql/MqlNumber.html#switchNumberOn(java.util.function.Function)>`__
       | `switchStringOn() <{+core-api+}/client/model/mql/MqlString.html#switchStringOn(java.util.function.Function)>`__

     - :manual:`$switch </reference/operator/aggregation/switch/>`

Suppose you have a collection of customers with their membership information.
Originally, customers were either members or not. Over time, membership levels
were introduced and used the same field. The information stored in this field
can be one of a few different types, and you want to create a standardized value
indicating their membership level.

The ``switchOn()`` method checks each clause in order. If the value matches the
type indicated by the clause, then the clause determines the string value
corresponding to the membership level. If the original value is a string, it
represents the membership level and that value is used. If the data type is a
boolean, it returns either ``Gold`` or ``Guest`` for the membership level. If
the data type is an array, it returns the most recent string in the array which
matches the most recent membership level. If the ``member`` field is an
unknown type, the ``switchOn()`` method provides a default value of ``Guest``.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-conditional-aggregation
   :end-before: end-conditional-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       membershipLevel: {
           $switch: {
             branches: [
               { case: { $eq: [ { $type: "$member" }, "string" ] }, then: "$member" },
               { case: { $eq: [ { $type: "$member" }, "bool" ] }, then: { $cond: {
                                                                              if: "$member",
                                                                              then: "Gold",
                                                                              else: "Guest" } } },
               { case: { $eq: [ { $type: "$member" }, "array" ] }, then: { $last: "$member" } }
             ],
             default: "Guest" } }
   } } ]

Convenience Operations
~~~~~~~~~~~~~~~~~~~~~~

You can apply custom functions to values of type
``MqlValue`` using the methods described in this section.

To improve readability and allow for code reuse, you can move redundant
code into static methods. However, you cannot directly chain
static methods in {+language+}. The ``passTo()`` method lets you chain values
into custom static methods.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `passTo() <{+core-api+}/client/model/mql/MqlValue.html#passTo(java.util.function.Function)>`__

       | **Typed Variants**:
       | `passArrayTo() <{+core-api+}/client/model/mql/MqlArray.html#passArrayTo(java.util.function.Function)>`__
       | `passBooleanTo() <{+core-api+}/client/model/mql/MqlBoolean.html#passBooleanTo(java.util.function.Function)>`__
       | `passDateTo() <{+core-api+}/client/model/mql/MqlDate.html#passDateTo(java.util.function.Function)>`__
       | `passDocumentTo() <{+core-api+}/client/model/mql/MqlDocument.html#passDocumentTo(java.util.function.Function)>`__
       | `passIntegerTo() <{+core-api+}/client/model/mql/MqlInteger.html#passIntegerTo(java.util.function.Function)>`__
       | `passMapTo() <{+core-api+}/client/model/mql/MqlMap.html#passMapTo(java.util.function.Function)>`__
       | `passNumberTo() <{+core-api+}/client/model/mql/MqlNumber.html#passNumberTo(java.util.function.Function)>`__
       | `passStringTo() <{+core-api+}/client/model/mql/MqlString.html#passStringTo(java.util.function.Function)>`__

     - *No corresponding operator*

Suppose you want to determine how a class is performing against some
benchmarks. You want to find the average final grade for each class and
compare it against the benchmark values.

The following custom method ``gradeAverage()`` takes an array of documents and
the name of an integer field shared across those documents. It calculates the
average of that field across all the documents in the provided array and
determines the average of that field across all the elements in
the provided array. The ``evaluate()`` method compares a provided value to
two provided range limits and generates a response string based on
how the values compare:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-convenience-aggregation-methods
   :end-before: end-convenience-aggregation-methods
   :language: kotlin
   :copyable:
   :dedent:

.. tip::

   Using the ``passTo()`` method allows you to reuse
   your custom methods for other aggregations. For example, you can
   use the ``gradeAverage()`` method to find the average of grades for
   groups of students filtered by entry year or district, not just their
   class. Similarly, you could use the ``evaluate()`` method to evaluate
   an individual student's performance or an entire school's performance.

The ``passArrayTo()`` method takes an array of all students and calculates the
average score by using the ``gradeAverage()`` method. Then, the
``passNumberTo()`` method uses the ``evaluate()`` method to determine how the
classes are performing. This example stores the result as the ``evaluation``
field using the ``project()`` method.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-convenience-aggregation
   :end-before: end-convenience-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       evaluation: { $switch: {
           branches: [
               { case: { $lte: [ { $avg: "$students.finalGrade" }, 70 ] },
                 then: "Needs improvement"
               },
               { case: { $lte: [ { $avg: "$students.finalGrade" }, 85 ] },
                 then: "Meets expectations"
               }
           ],
           default: "Exceeds expectations" } }
   } } ]

Conversion Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform a conversion operation to convert between certain ``MqlValue``
types using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `asDocument() <{+core-api+}/client/model/mql/MqlMap.html#asDocument()>`__
     - *No corresponding operator*

   * - `asMap() <{+core-api+}/client/model/mql/MqlDocument.html#asMap()>`__
     - *No corresponding operator*

   * - `asString() for MqlDate <{+core-api+}/client/model/mql/MqlDate.html#asString(com.mongodb.client.model.mql.MqlString,com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dateToString </reference/operator/aggregation/dateToString/>`

   * - `asString() for MqlValue <{+core-api+}/client/model/mql/MqlValue.html#asString()>`__
     - :manual:`$toString </reference/operator/aggregation/toString/>`

   * - `millisecondsAsDate() <{+core-api+}/client/model/mql/MqlInteger.html#millisecondsAsDate()>`__
     - :manual:`$toDate </reference/operator/aggregation/toDate/>`

   * - `parseDate() <{+core-api+}/client/model/mql/MqlString.html#parseDate()>`__
     - :manual:`$dateFromString </reference/operator/aggregation/dateFromString/>`

   * - `parseInteger() <{+core-api+}/client/model/mql/MqlString.html#parseInteger()>`__
     - :manual:`$toInt </reference/operator/aggregation/toInt/>`

Suppose you want to have a collection of student data that includes
their graduation years, which are stored as strings. You want to
calculate the year of their five-year reunion and store this value in a
new field.

The ``parseInteger()`` method converts the ``graduationYear`` to an integer
so that ``add()`` can calculate the reunion year. The ``addFields()`` method
stores this result as a new ``reunionYear`` field.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-convenience-aggregation
   :end-before: end-convenience-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $addFields: {
       reunionYear: {
           $add: [ { $toInt: "$graduationYear" }, 5 ] }
   } } ]

Date Operations
~~~~~~~~~~~~~~~

You can perform a date operation on a value of type ``MqlDate``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `dayOfMonth() <{+core-api+}/client/model/mql/MqlDate.html#dayOfMonth(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfMonth </reference/operator/aggregation/dayOfMonth/>`

   * - `dayOfWeek() <{+core-api+}/client/model/mql/MqlDate.html#dayOfWeek(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfWeek </reference/operator/aggregation/dayOfWeek/>`

   * - `dayOfYear() <{+core-api+}/client/model/mql/MqlDate.html#dayOfYear(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfYear </reference/operator/aggregation/dayOfYear/>`

   * - `hour() <{+core-api+}/client/model/mql/MqlDate.html#hour(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$hour </reference/operator/aggregation/hour/>`

   * - `millisecond() <{+core-api+}/client/model/mql/MqlDate.html#millisecond(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$millisecond </reference/operator/aggregation/millisecond/>`

   * - `minute() <{+core-api+}/client/model/mql/MqlDate.html#minute(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$minute </reference/operator/aggregation/minute/>`

   * - `month() <{+core-api+}/client/model/mql/MqlDate.html#month(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$month </reference/operator/aggregation/month/>`

   * - `second() <{+core-api+}/client/model/mql/MqlDate.html#second(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$second </reference/operator/aggregation/second/>`

   * - `week() <{+core-api+}/client/model/mql/MqlDate.html#week(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$week </reference/operator/aggregation/week/>`

   * - `year() <{+core-api+}/client/model/mql/MqlDate.html#year(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$year </reference/operator/aggregation/year/>`

Suppose you have data about package deliveries and want to match
deliveries that occurred on any Monday in the ``"America/New_York"`` time
zone.

If the ``deliveryDate`` field contains any string values representing
valid dates, such as ``"2018-01-15T16:00:00Z"`` or ``"Jan 15, 2018, 12:00
PM EST"``, you can use the ``parseDate()`` method to convert the strings
into date types.

The ``dayOfWeek()`` method determines which day of the week that a date
is, then converts it to a number. The number assignment uses ``0`` to mean
Sunday when using the ``"America/New_York"`` timezone. The ``eq()``
method compares this value to ``2``, or Monday.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-date-aggregation
   :end-before: end-date-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $match: {
       $expr: {
           $eq: [ {
               $dayOfWeek: {
                   date: { $dateFromString: { dateString: "$deliveryDate" } },
                   timezone: "America/New_York" }},
               2
           ] }
   } } ]

Document Operations
~~~~~~~~~~~~~~~~~~~

You can perform a document operation on a value of type ``MqlDocument``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - | `getArray() <{+core-api+}/client/model/mql/MqlDocument.html#getArray(java.lang.String)>`__
       | `getBoolean() <{+core-api+}/client/model/mql/MqlDocument.html#getBoolean(java.lang.String)>`__
       | `getDate() <{+core-api+}/client/model/mql/MqlDocument.html#getDate(java.lang.String)>`__
       | `getDocument() <{+core-api+}/client/model/mql/MqlDocument.html#getDocument(java.lang.String)>`__
       | `getField() <{+core-api+}/client/model/mql/MqlDocument.html#getField(java.lang.String)>`__
       | `getInteger() <{+core-api+}/client/model/mql/MqlDocument.html#getInteger(java.lang.String)>`__
       | `getMap() <{+core-api+}/client/model/mql/MqlDocument.html#getMap(java.lang.String)>`__
       | `getNumber() <{+core-api+}/client/model/mql/MqlDocument.html#getNumber(java.lang.String)>`__
       | `getString() <{+core-api+}/client/model/mql/MqlDocument.html#getString(java.lang.String)>`__
     - :manual:`$getField </reference/operator/aggregation/getField/>`

   * - `hasField() <{+core-api+}/client/model/mql/MqlDocument.html#hasField(java.lang.String)>`__
     - *No corresponding operator*

   * - `merge() <{+core-api+}/client/model/mql/MqlDocument.html#merge(com.mongodb.client.model.mql.MqlDocument)>`__
     - :manual:`$mergeObjects </reference/operator/aggregation/mergeObjects/>`

   * - `setField() <{+core-api+}/client/model/mql/MqlDocument.html#setField(java.lang.String,com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$setField </reference/operator/aggregation/setField/>`

   * - `unsetField() <{+core-api+}/client/model/mql/MqlDocument.html#unsetField(java.lang.String)>`__
     - :manual:`$unsetField </reference/operator/aggregation/unsetField/>`

Suppose you have a collection of legacy customer data which includes
addresses as child documents under the ``mailing.address`` field. You want
to find all the customers who live in Washington state. A
document in this collection might resemble the following:

.. code-block:: json
   :copyable: false

   {
     "_id": ...,
     "customer.name": "Mary Kenneth Keller",
     "mailing.address":
     {
       "street": "601 Mongo Drive",
       "city": "Vasqueztown",
       "state": "CO",
       "zip": 27017
     }
   }

The ``getDocument()`` method retrieves the ``mailing.address`` field as a
document so the nested ``state`` field can be retrieved with the
``getString()`` method. The ``eq()`` method checks if the value of the
``state`` field is ``"WA"``.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-document-aggregation
   :end-before: end-document-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
       { $match: {
           $expr: {
               $eq: [{
                   $getField: {
                       input: { $getField: { input: "$$CURRENT", field: "mailing.address"}},
                       field: "state" }},
                   "WA" ]
   }}}]

Map Operations
~~~~~~~~~~~~~~

You can perform a map operation on a value of either type ``MqlMap`` or
``MqlEntry`` using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `entries() <{+core-api+}/client/model/mql/MqlMap.html#entries()>`__
     - :manual:`$objectToArray </reference/operator/aggregation/objectToArray/>`

   * - `get() <{+core-api+}/client/model/mql/MqlMap.html#get(com.mongodb.client.model.mql.MqlString)>`__
     - *No corresponding operator*

   * - `getKey() <{+core-api+}/client/model/mql/MqlEntry.html#getKey()>`__
     - *No corresponding operator*

   * - `getValue() <{+core-api+}/client/model/mql/MqlEntry.html#getValue()>`__
     - *No corresponding operator*

   * - `has() <{+core-api+}/client/model/mql/MqlMap.html#has(com.mongodb.client.model.mql.MqlString)>`__
     - *No corresponding operator*

   * - `merge() <{+core-api+}/client/model/mql/MqlMap.html#merge(com.mongodb.client.model.mql.MqlMap)>`__
     - *No corresponding operator*

   * - `set() <{+core-api+}/client/model/mql/MqlMap.html#set(com.mongodb.client.model.mql.MqlString,T)>`__
     - *No corresponding operator*

   * - `setKey() <{+core-api+}/client/model/mql/MqlEntry.html#setKey(com.mongodb.client.model.mql.MqlString)>`__
     - *No corresponding operator*

   * - `setValue() <{+core-api+}/client/model/mql/MqlEntry.html#setValue(T)>`__
     - *No corresponding operator*

   * - `unset() <{+core-api+}/client/model/mql/MqlMap.html#unset(com.mongodb.client.model.mql.MqlString)>`__
     - *No corresponding operator*

Suppose you have a collection of inventory data where each document represents
an individual item you're responsible for supplying. Each document contains a
field that is a map of all your warehouses and how many copies they
have in their inventory of the item. You want to determine the total number of
copies of items you have across all warehouses. A document in this
collection might resemble the following:

.. code-block:: json
   :copyable: false

   {
     "_id": ...,
     "item": "notebook"
     "warehouses": [
       { "Atlanta", 50 },
       { "Chicago", 0 },
       { "Portland", 120 },
       { "Dallas", 6 }
     ]
   }

The ``entries()`` method returns the map entries in the ``warehouses``
field as an array. The ``sum()`` method calculates the total value of items
based on the values in the array retrieved with the ``getValue()`` method.
This example stores the result as the new ``totalInventory`` field using the
``project()`` method.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-map-aggregation
   :end-before: end-map-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       totalInventory: {
           $sum: {
             $getField: { $objectToArray: "$warehouses" },
           } }
   } } ]

String Operations
~~~~~~~~~~~~~~~~~

You can perform a string operation on a value of type ``MqlString``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `append() <{+core-api+}/client/model/mql/MqlString.html#append(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$concat </reference/operator/aggregation/concat/>`

   * - `length() <{+core-api+}/client/model/mql/MqlString.html#length()>`__
     - :manual:`$strLenCP </reference/operator/aggregation/strLenCP/>`

   * - `lengthBytes() <{+core-api+}/client/model/mql/MqlString.html#lengthBytes()>`__
     - :manual:`$strLenBytes </reference/operator/aggregation/strLenBytes/>`

   * - `substr() <{+core-api+}/client/model/mql/MqlString.html#substr(int,int)>`__
     - :manual:`$substrCP </reference/operator/aggregation/substrCP/>`

   * - `substrBytes() <{+core-api+}/client/model/mql/MqlString.html#substrBytes(int,int)>`__
     - :manual:`$substrBytes </reference/operator/aggregation/substrBytes/>`

   * - `toLower() <{+core-api+}/client/model/mql/MqlString.html#toLower()>`__
     - :manual:`$toLower </reference/operator/aggregation/toLower/>`

   * - `toUpper() <{+core-api+}/client/model/mql/MqlString.html#toUpper()>`__
     - :manual:`$toUpper </reference/operator/aggregation/toUpper/>`

Suppose you want to generate lowercase usernames for employees of a
company from the employees' last names and employee IDs.

The ``append()`` method combines the ``lastName`` and ``employeeID`` fields into
a single username, while the ``toLower()`` method makes the entire username
lowercase. This example stores the result as a new ``username`` field using
the ``project()`` method.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-string-aggregation
   :end-before: end-string-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       username: {
           $toLower: { $concat: ["$lastName", "$employeeID"] } }
   } } ]

Type-Checking Operations
~~~~~~~~~~~~~~~~~~~~~~~~

You can perform a type-check operation on a value of type ``MqlValue``
using the methods described in this section.

These methods do not return boolean values. Instead, you provide a default value
that matches the type specified by the method. If the checked value
matches the method type, the checked value is returned. Otherwise, the supplied
default value is returned. To program branching logic based on the
data type, see ``switchOn()``.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Method
     - Aggregation Pipeline Operator

   * - `isArrayOr() <{+core-api+}/client/model/mql/MqlValue.html#isArrayOr(com.mongodb.client.model.mql.MqlArray)>`__
     - *No corresponding operator*

   * - `isBooleanOr() <{+core-api+}/client/model/mql/MqlValue.html#isBooleanOr(com.mongodb.client.model.mql.MqlBoolean)>`__
     - *No corresponding operator*

   * - `isDateOr() <{+core-api+}/client/model/mql/MqlValue.html#isDateOr(com.mongodb.client.model.mql.MqlDate)>`__
     - *No corresponding operator*

   * - `isDocumentOr() <{+core-api+}/client/model/mql/MqlValue.html#isDocumentOr(T)>`__
     - *No corresponding operator*

   * - `isIntegerOr() <{+core-api+}/client/model/mql/MqlValue.html#isIntegerOr(com.mongodb.client.model.mql.MqlInteger)>`__
     - *No corresponding operator*

   * - `isMapOr() <{+core-api+}/client/model/mql/MqlValue.html#isMapOr(com.mongodb.client.model.mql.MqlMap)>`__
     - *No corresponding operator*

   * - `isNumberOr() <{+core-api+}/client/model/mql/MqlValue.html#isNumberOr(com.mongodb.client.model.mql.MqlNumber)>`__
     - *No corresponding operator*

   * - `isStringOr() <{+core-api+}/client/model/mql/MqlValue.html#isStringOr(com.mongodb.client.model.mql.MqlString)>`__
     - *No corresponding operator*

Suppose you have a collection of rating data. An early version of the review
schema allowed users to submit negative reviews without a star rating. You want
convert any of these negative reviews without a star rating to have the minimum
value of 1 star.

The ``isNumberOr()`` method returns either the value of ``rating``, or
a value of ``1`` if ``rating`` is not a number or is null. The
``project()`` method returns this value as a new ``numericalRating`` field.

The following code shows the pipeline for this aggregation:

.. literalinclude:: /includes/aggregation/aggExpressions.kt
   :start-after: start-type-aggregation
   :end-before: end-type-aggregation
   :language: kotlin
   :copyable:
   :dedent:

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [ { $project: {
       numericalRating: {
           $cond: { if: { $isNumber: "$rating" },
                    then: "$rating",
                    else: 1
           } }
   } } ]
