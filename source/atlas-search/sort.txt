.. _sort-ref:

==================
Sort |fts| Results 
==================

.. default-domain:: mongodb

.. meta::
   :description: Sort you Atlas Search results by date, number, and string fields.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol
   
Overview
--------

|fts| allows you to sort the results in ascending or descending order on 
fields that you define in your |fts| index. You can sort by date, number
(integer, float, and double values), and string fields using the
``sort`` option.

.. note:: 

   |fts| :ref:`sort <sort-ref>` option is available in sharded
   {+clusters+} only if you run MongoDB v6.0+.

Usage 
~~~~~

To sort your |fts| results, you must do the following:

1. Create an |fts| index on the fields to sort the results by. 
   
   |fts| automatically indexes number and date fields in all indexes
   created after :ref:`July 2023 <fts20230710>` for sorting. For
   preexisting indexes, you must trigger an index rebuild from the
   {+atlas-ui+} to use any date and number fields in the indexes for
   sorting. To learn more, see :ref:`sort-index-rebuild`.

   For string fields, you must manually index the field as ``token``
   type. To learn more, see :ref:`bson-data-types-token`. 

#. Create and run your query with the ``sort`` option against the fields
   you defined in the index for sorting. To learn more, see 
   :ref:`sort-syntax-ref`.
   
Behavior 
~~~~~~~~

The ``sort`` option takes a document that specifies the fields to sort 
by and the respective sort order. |fts| follows the :manual:`MongoDB
comparison order </reference/bson-type-comparison-order/>` for the
supported data types. It treats null and missing values as equivalent in
its sort order. To learn more, see :manual:`non-existent fields
</reference/bson-type-comparison-order/#non-existent-fields>`. 

You can specify the following sort order to sort your results by: 

.. list-table:: 
   :widths: 10 90 

   * - ``1`` 
     - Sort in ascending order. 
  
       When you sort in ascending order, |fts| returns documents with
       missing values before documents with values. 

   * - ``-1`` 
     - Sort in descending order .
  
|fts| flattens the arrays for sorting. 

.. example:: 

   Consider the following array: 

   .. code-block:: shell 
      :copyable: false 

      [4, [1, [8,5], 9], 2]

   |fts| flattens the preceding array similar to the following:

   .. code-block:: shell 
      :copyable: false 

      4, 1, 8, 5, 9, 2

   For an ascending sort, |fts| uses ``1`` to compare the array to other
   values. For a descending sort, |fts| uses ``9`` to compare the array
   to other values.

When comparing with elements inside an array:

- For an ascending sort, |fts| compares the smallest elements of the
  array or performs a less than (``<``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in ascending order:

     .. code-block:: shell 
        :copyable: false 

        -20
        [-3, 12] // <- -3 comes before 5.
        5
        [6, 18]  // <- 6 comes after 5.
        13
        14

- For a descending sort, |fts| compares the largest elements of the
  array or performs a greater than (``>``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in descending order:

     .. code-block:: shell 
        :copyable: false 

        [6, 18]  // <- 18 comes before 14.
        14
        13
        [-3, 12] // <- 12 comes after 13.
        5
        -20

.. _sort-considerations:

Considerations 
~~~~~~~~~~~~~~

Consistency 
```````````

|fts| indexes are eventually :ref:`consistent
<index-eventual-consistency-and-latency>`, and values returned in
results might be different from values used in sorting.

Performance 
```````````

This feature optimizes queries that use :pipeline:`$search` with
:pipeline:`$limit` as a subsequent stage. If |fts| needs to sort all 
documents in the collection, the response might be slow.

Scoring 
```````

|fts| returns :ref:`scores <scoring-ref>` for all documents in the
results. However, you might see higher scoring documents after lower
scoring documents because the order of documents in the results is based
on the sort criteria.  

Limitations 
~~~~~~~~~~~

- You can't sort on fields of :ref:`embeddedDocuments
  <bson-data-types-embedded-documents>` type.
- You can't use the ``sort`` option with the :ref:`knn-beta-ref`
  operator. 

.. _sort-compatibility-ref:

Compatibility 
~~~~~~~~~~~~~

|service| supports non-sharded sort queries across all major and minor release versions of MongoDB. Sharded sort queries are available on major release version 6.0 and all major and minor release versions 7.0 and later.  

.. _sort-syntax-ref:

Syntax 
------

``sort`` has the following syntax:

.. code-block:: json
   :emphasize-lines: 7-10

   {
     "$search": {  
       "index": "<index name>", // optional, defaults to "default"
       "<operator>": { // such as "text", "compound", or "phrase"
         <operator-specification>
       },
       "sort": { 
         "<field-to-sort>": <sort-order>, 
         ...
       }
     }
   }

.. _sort-index-rebuild:

Rebuild Index for Sorting  
-------------------------

|fts| automatically indexes fields of type date and number for indexes
created after :ref:`July 2023 <fts20230710>` for sorting. For
preexisting indexes, you must rebuild the indexes to use the date and
number fields in the indexes for sorting the |fts| results. To rebuild
the index, do the following:

.. note:: 

   |fts| index rebuild operation is both time and resource
   intensive. You must allocate free disk space equal to 125% of
   the disk space used by your old index for this operation. 

.. procedure:: 

   .. step:: Log in to |service| and navigate to the :guilabel:`Search` page.

      To navigate to the |fts| page:

      a. Click :guilabel:`Search` from the :guilabel:`Services` menu in
         the navigation bar. 
      
      #. Select the {+cluster+} from the :guilabel:`Select data source`
         dropdown and click :guilabel:`Go to Atlas Search`.

   .. step:: Click the name of the index that you want to rebuild. 

       The {+atlas-ui+} shows a warning icon next to the name of the
       indexes that you can upgrade to avail of the sort functionality.

   .. step:: Update your index to use the new capability for date and numeric fields. 
    
      To update your index: 
      
      a. In the :guilabel:`Index Overview` page, click :guilabel:`Update` in the banner.
      #. Click :guilabel:`Update Index` in the confirmation window. 

         While your index is rebuilding, you can continue to query your
         collection using your previous index.

Examples 
--------

The following examples use the ``sample_mflix.movies`` collection in the
:ref:`sample data <sample-data>`. 

Index Definition
~~~~~~~~~~~~~~~~

The example queries in this section use the following index. The index
definition for the collection specifies the following: 

- Index ``awards.wins`` field as: 

  - ``number`` type for sorting and querying
  - ``numberFacet`` type for running :ref:`fts-facet-ref` queries

- Index ``released`` field as: 

  - ``date`` type for sorting and querying
  - ``dateFacet`` type for running :ref:`fts-facet-ref` queries

- Index ``title`` field as: 

  - ``token`` type for sorting 
  - ``string`` type for querying  

.. code-block:: json
   :copyable: true 
   :linenos:

   {
     "mappings": {
       "dynamic": false,
       "fields": {
         "awards": {
           "dynamic": false,
           "fields": {
             "wins": [
               {
                 "type": "number"
               },
               {
                 "type": "numberFacet"
               }
             ]
           },
           "type": "document"
         },
         "released": [
           {
             "type": "date"
           },
           {
             "type": "dateFacet"
           }
         ],
         "title": [{
           "type": "token"
         }, {
           "type": "string"
         }]
       }
     }
   }

For the preceding index definition, |fts| creates an index named
``default`` with :ref:`static mappings <static-dynamic-mappings>` on the
specified fields. 

Date Search and Sort 
~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``released`` in the results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "range": {
              "path": "released",
              "gt": ISODate("2010-01-01T00:00:00.000Z"),
              "lt": ISODate("2015-01-01T00:00:00.000Z")
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          title: 'Cold in July',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'The Gambler',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'Force Majeure',
          released: ISODate("2014-12-30T00:00:00.000Z")
        },
        { 
          title: 'LFO', 
          released: ISODate("2014-12-27T00:00:00.000Z") 
        },
        {
          title: 'Peace After Marriage',
          released: ISODate("2014-12-26T00:00:00.000Z")
        }
      ]

Number Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have won awards.  
- Sort the results in descending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``awards.wins`` in the results.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
             "range": {
               "path": "awards.wins",
               "gt": 3
            },
            "sort": {
              "awards.wins": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "awards.wins": 1
          }
        }
      ])

   .. output::
      :language: json

      [
        { title: '12 Years a Slave', awards: { wins: 267 } },
        { title: 'Gravity', awards: { wins: 231 } },
        { title: 'Gravity', awards: { wins: 231 } },
        {
          title: 'Birdman: Or (The Unexpected Virtue of Ignorance)',
          awards: { wins: 210 }
        },
        { title: 'Boyhood', awards: { wins: 185 } },
      ]

String Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``country`` in the title.  
- Sort the results in ascending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title`` in the results.
- Add a field named ``score``.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "text": {
              "path": "title",
              "query": "country"
            },
            "sort": {
              "title": 1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json

      [
        { title: 'A Country Called Home', score: 2.5108444690704346 },
        { title: 'A Day in the Country', score: 2.2362313270568848 },
        { title: 'A Month in the Country', score: 2.2362313270568848 },
        { title: 'A Quiet Place in the Country', score: 2.01576566696167 },
        { title: 'A Sunday in the Country', score: 2.2362313270568848 }
      ]

Compound Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``dance`` in the title, with
  a preference for movies that have won 2 or more awards and were
  released after 01 January, 1990.  
- Sort the results by the number of awards in descending order, then by
  the movie title in ascending order, and then by the release date in
  descending order. 

The query uses the :pipeline:`$limit` stage to limit the output to ``10``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title``, ``released``, and ``awards.wins`` in
  the results. 
- Add a field named ``score``.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "compound": {
              "must": [{
                "text": {
                  "path": "title",
                  "query": "dance"
                }
              }],
              "should": [{
                "range": {
                  "path": "awards.wins",
                  "gte": 2
                }
              }, {
                "range": {
                  "path": "released",
                  "gte": ISODate("1990-01-01T00:00:00.000Z")
                }
              }]
            },
            "sort": {
              "awards.wins": -1, 
              "title": 1, 
              "released": -1
            }
          }
        },
        {
          "$limit": 10
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1,
            "awards.wins": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'War Dance',
          released: ISODate("2008-11-01T00:00:00.000Z"),
          awards: { wins: 11 },
          score: 5.466421127319336
        },
        {
          title: 'Dance with the Devil',
          released: ISODate("1997-10-31T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Save the Last Dance',
          released: ISODate("2001-01-12T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Dance with a Stranger',
          released: ISODate("1985-08-09T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 3.615056037902832
        },
        {
          title: 'The Baby Dance',
          released: ISODate("1998-08-23T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: 'Three-Step Dance',
          released: ISODate("2004-02-19T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: "Cats Don't Dance",
          released: ISODate("1997-03-26T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        },
        {
          title: 'Dance Me Outside',
          released: ISODate("1995-03-10T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        }
      ]

Facet Search and Sort 
~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Get a count of the number of movies that won ``1``, ``5``, ``10``, and
  ``15`` awards.
- Get a count of the number of movies released on ``2010-01-01``,
  ``2011-01-01``, ``2012-01-01``, ``2013-01-01``, ``2014-01-01``, and
  ``2015-01-01``.
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to do the following: 

- Limit the output to ``5`` documents in the ``docs`` output field. 
- Limit the output to ``1`` document in the ``meta`` output field. 

It uses the :pipeline:`$project` stage to omit all fields except the
``awards.wins``, ``released``, and ``title`` fields.

It also uses the :pipeline:`$replaceWith` stage to include the metadata
results stored in the ``$$SEARCH_META`` variable in the ``meta`` output
field and the :pipeline:`$set` stage to add the ``meta`` field to the
results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "facet": {
              "operator": {
                "range": {
                  "path": "released",
                  "gt": ISODate("2010-01-01T00:00:00.000Z"),
                  "lt": ISODate("2015-01-01T00:00:00.000Z")
                }
              },
              "facets": {
                "awardsFacet": {
                  "type": "number",
                  "path": "awards.wins",
                  "boundaries" : [1,5,10,15]
                },
                "releasedFacet" : {
                  "type" : "date",
                  "path" : "released",
                  "boundaries" : [ISODate("2010-01-01T00:00:00.000Z"), ISODate("2011-01-01T00:00:00.000Z"), ISODate("2012-01-01T00:00:00.000Z"), ISODate("2013-01-01T00:00:00.000Z"), ISODate("2014-01-01T00:00:00.000Z"), ISODate("2015-01-01T00:00:00.000Z")]
                }
              }
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$facet": {
            "docs": [
              { "$limit": 5 },
              { "$project":
                {
                  "_id": 0,
                  "title": 1,
                  "released": 1,
                  "awards.wins": 1
                }
              }
            ],
            "meta": [
              {"$replaceWith": "$$SEARCH_META"},
              {"$limit": 1}
            ]
          }
        },
        {
          "$set": {
            "meta": {
              "$arrayElemAt": ["$meta", 0]
            }
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          docs: [
            {
              title: 'Cold in July',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 1 }
            },
            {
              title: 'The Gambler',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 7 }
            },
            {
              title: 'Force Majeure',
              released: ISODate("2014-12-30T00:00:00.000Z"),
              awards: { wins: 31 }
            },
            {
              title: 'LFO',
              released: ISODate("2014-12-27T00:00:00.000Z"),
              awards: { wins: 3 }
            },
            {
              title: 'Peace After Marriage',
              released: ISODate("2014-12-26T00:00:00.000Z"),
              awards: { wins: 5 }
            }
          ],
          meta: {
            count: { lowerBound: Long("5429") },
            facet: {
              releasedFacet: {
                buckets: [
                  {
                    _id: ISODate("2010-01-01T00:00:00.000Z"),
                    count: Long("938")
                  },
                  {
                    _id: ISODate("2011-01-01T00:00:00.000Z"),
                    count: Long("1046")
                  },
                  {
                    _id: ISODate("2012-01-01T00:00:00.000Z"),
                    count: Long("1065")
                  },
                  {
                    _id: ISODate("2013-01-01T00:00:00.000Z"),
                    count: Long("1187")
                  },
                  {
                    _id: ISODate("2014-01-01T00:00:00.000Z"),
                    count: Long("1193")
                  }
                ]
              },
              awardsFacet: {
                buckets: [
                  { _id: 1, count: Long("2616") },
                  { _id: 5, count: Long("698") },
                  { _id: 10, count: Long("274") }
                ]
              }
            }
          }
        }
      ]
