.. _ref-language-analyzers:

==================
Language Analyzers
==================

.. default-domain:: mongodb

.. meta::
   :keywords: language analyzer, stop words, cjk, morfologik, kuromoji, nori, smartcn, french, german, dutch, irish, spanish, italian, lucene analyzer, text analyzer, full text search
   :description: Use a language analyzer to create search keywords in your Atlas Search index that are optimized for a particular natural language.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Use language-specific analyzers to create indexes tailored to a particular
language. Each language analyzer has built-in stop words and word divisions
based on that language's usage patterns.

|fts| offers the following language analyzers:

.. list-table::
   :widths: 25 25 25 25 

   * - ``lucene.arabic``
     - ``lucene.armenian``
     - ``lucene.basque``
     - ``lucene.bengali``
   * - ``lucene.brazilian``
     - ``lucene.bulgarian``
     - ``lucene.catalan``
     - ``lucene.chinese`` 
   * - ``lucene.cjk`` :sup:`1`
     - ``lucene.czech``
     - ``lucene.danish``
     - ``lucene.dutch``
   * - ``lucene.english``
     - ``lucene.finnish``
     - ``lucene.french``
     - ``lucene.galician``
   * - ``lucene.german``
     - ``lucene.greek``
     - ``lucene.hindi``
     - ``lucene.hungarian``
   * - ``lucene.indonesian``
     - ``lucene.irish``
     - ``lucene.italian``
     - ``lucene.japanese`` 
   * - ``lucene.korean`` 
     - ``lucene.kuromoji`` :sup:`2`
     - ``lucene.latvian``
     - ``lucene.lithuanian``
   * - ``lucene.morfologik`` :sup:`3`
     - ``lucene.nori`` :sup:`4`
     - ``lucene.norwegian``
     - ``lucene.persian``
   * - ``lucene.polish``
     - ``lucene.portuguese``
     - ``lucene.romanian``
     - ``lucene.russian``
   * - ``lucene.smartcn`` :sup:`5`
     - ``lucene.sorani``
     - ``lucene.spanish``
     - ``lucene.swedish``
   * - ``lucene.thai``
     - ``lucene.turkish``
     - ``lucene.ukrainian``
     - 

:sup:`1` ``cjk`` is a generic Chinese, Japanese, and Korean analyzer

:sup:`2` ``kuromoji`` is a Japanese analyzer

:sup:`3` ``morfologik`` is a Polish analyzer

:sup:`4` ``nori`` is a Korean analyzer

:sup:`5` ``smartcn`` is a Chinese analyzer

Examples
--------

Consider a collection named ``cars`` with the following documents:

.. code-block:: json
   :copyable: true

   { 
     "_id": 1,  
     "subject": {
       "en": "It is better to equip our cars to understand the causes of the accident.",
       "fr": "Mieux équiper nos voitures pour comprendre les causes d'un accident.",
       "he": "עדיף לצייד את המכוניות שלנו כדי להבין את הגורמים לתאונה."
     } 
   } 

.. code-block:: json
   :copyable: true
   
   { 
     "_id": 2,  
     "subject": {
       "en": "The best time to do this is immediately after you've filled up with fuel",
       "fr": "Le meilleur moment pour le faire c'est immédiatement après que vous aurez fait le plein de carburant.",
       "he": "הזמן הטוב ביותר לעשות זאת הוא מיד לאחר שמילאת דלק."
     } 
   } 

Built-In Language Analyzer Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example index definition specifies an index on
the ``subject.fr`` field using the ``french`` analyzer:

.. code-block:: json
   :copyable: true

   {
     "mappings": {
       "fields": {
         "subject": {
           "fields": {
             "fr": {
               "analyzer": "lucene.french",
               "type": "string"
             }
           },
           "type": "document"
         }
       }
     }
   }

The following query searches for the string ``pour`` in the
``subject.fr`` field:

.. io-code-block::
   :copyable: true

   .. input::
      :language: shell

      db.cars.aggregate([
        { 
          $search: {
            "text": {
              "query": "pour",
              "path": "subject.fr"
            }
          }
        },
        {
          $project: {
            "_id": 0,
            "subject.fr": 1
          }
        }
      ])

   .. output::
      :language: json
      :visible: true

The previous query returns no results when using the ``french`` analyzer,
because ``pour`` is a built-in stop word. Using the ``standard``
analyzer, the same query would return both documents.

The following query searches for the string ``carburant`` in the
``subject.fr`` field:

.. io-code-block::
   :copyable: true

   .. input::
      :language: shell

      db.cars.aggregate([
        { 
          $search: {
            "text": {
              "query": "carburant",
              "path": "subject.fr"
            }
          } 
        },
        {
          $project: {
            "_id": 0,
            "subject.fr": 1
          }
        }
      ])

   .. output::
      :language: json
      :visible: true

      { subject: { fr: "Le meilleur moment pour le faire c'est immédiatement après que vous aurez fait le plein de carburant." } }

|fts| returns a document with ``_id: 1`` in the results because the query
matched a token that the ``lucene.french`` analyzer created for the
document. The ``lucene.french`` analyzer creates the following tokens
for the ``subject.fr`` field in document with ``_id: 1``:

.. list-table::
   :widths: 33 33 33
   
   * - ``meileu``
     - ``moment`` 
     - ``fair``

   * - ``est``
     - ``imediat``
     - ``aprè``

   * - ``fait``
     - ``plein``
     - ``carburant``

Custom Language Analyzer Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also create indexes for unsupported languages by
creating a :ref:`custom analyzer <custom-analyzers>` with the
:ref:`icuFolding <icufolding-tf-ref>` and :ref:`stopword
<stopword-tf-ref>` token filters.

The following example index definition specifies an index on
the ``subject.he`` field using a :ref:`custom analyzer
<custom-analyzers>` called ``myHebrewAnalyzer`` to analyze and create
tokens for Hebrew text:

.. code-block:: json
   :copyable: true

   {
     "analyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "subject": {
           "fields": {
             "he": {
               "analyzer": "myHebrewAnalyzer",
               "type": "string"
             }
           },
           "type": "document"
         }
       }
     },
     "analyzers": [
       {
         "charFilters": [],
         "name": "myHebrewAnalyzer",
         "tokenFilters": [
           {
             "type": "icuFolding"
           },
           {
             "tokens": [
               "אן",
               "שלנו",
               "זה",
               "אל"
             ],
             "type": "stopword"
           }
         ],
         "tokenizer": {
           "type": "standard"
         }
       }
     ]
   }

The following query searches for the string ``המכוניות`` in the
``subject.he`` field:

.. io-code-block::
   :copyable: true

   .. input::
      :language: sh

      db.cars.aggregate([
        {
          $search: {
            "text": {
              "query": "המכוניות",
              "path": "subject.he"
            }
          }
        },
        {
          $project: {
            "_id": 0,
            "subject.he": 1
          }
        }
      ])

   .. output::
      :language: json
      :visible: true

      { subject: { he: 'עדיף לצייד את המכוניות שלנו כדי להבין את הגורמים לתאונה.' } }
  
|fts| returns a document with ``_id: 1`` in the results because the
query matched a token that the ``myHebrewAnalyzer`` analyzer created for
document. The ``myHebrewAnalyzer`` analyzer creates the following tokens
for the ``subject.he`` field in document with ``_id: 1``:

.. list-table::
   :widths: 33 33 33
   
   * - ``עדיף``
     - ``לצייד`` 
     - ``את``

   * - ``המכוניות``
     - ``כדי``
     - ``להבין``

   * - ``את``
     - ``הגורמים``
     - ``לתאונה``
