===============
Read Operations
===============

.. default-domain:: mongodb

Read operations retrieve data from collections. The data returned is in
the form of a :term:`document`.

This section of the manual describes how MongoDB performs read
operations and how different factors affect the efficiency of the read
operations.

.. index:: read operation; query
.. index:: query; read operations

.. _read-operations-operation:

Read Operators
--------------

MongoDB provides the :method:`find() <db.collection.find()>` method and
the :method:`findOne() <db.collection.findOne()>` method to perform
read operations.

The :method:`find() <db.collection.find()>` method is the primary
method to select data from a collection. The method has the syntax:

.. code-block:: javascript

   db.collection.find( <query>, <projection> )

- The ``query`` argument specifies the select criteria that limits the
  documents returned.

- The ``projection`` argument specifies the fields to return.

Both the ``query`` argument and the ``projection``
argument are in the form of a ``document`` structure.

For example, the following operation selects from the ``products``
collection where field ``type`` equals ``food`` and the field ``price``
is less than ``9.95`` and returns the fields ``item`` and ``qty``:

.. code-block:: javascript

   db.inventory.find( { type: 'food', price: { $lt: 9.95 } },
                      { item: 1, qty: 1 } )

The :method:`findOne() <db.collection.findOne()>` method is similar to
the :method:`find() <db.collection.find()>` method except the
:method:`findOne() <db.collection.findOne()>` method returns a single
document from a collection rather than a cursor. The method has the
syntax:

.. code-block:: javascript

   db.collection.findOne( <query>, <projection> )

For additional documentation and examples of the main MongoDB read
operators, refer to the :doc:`/applications/read` page of the
:doc:`/crud` section.

.. _read-operations-query-argument:

Query Argument
~~~~~~~~~~~~~~

The ``query`` argument determines which records to return. 

Consider the ``query`` arguments in the following :method:`find()
<db.collection.find()>` method calls:

- No ``query`` argument or an empty ``query`` argument (``{}``) returns
  all documents in a collection:

  .. code-block:: javascript

     db.inventory.find()
     db.inventory.find( {} )

- A ``query`` argument specifies the criteria where the field
  ``type`` equals either ``food`` or ``snacks``:

  .. code-block:: javascript

     db.inventory.find( { type: { $in: [ 'food', 'snacks' ] } } )

  .. note::

     Although you can express this query using the :operator:`$or`
     operator, choose the :operator:`$in` operator rather than the
     :operator:`$or` operator when performing equality checks on the
     same field.

- Compound ``query`` argument specifies the criteria where the field
  ``type`` equals ``food`` **and** the field ``price`` is less than
  ``9.95``:

  .. code-block:: javascript

     db.inventory.find( { type: 'food', price: { $lt: 9.95 } } )

- Compound ``query`` argument specifies the criteria where the field
  ``qty`` is greater than ``100`` **or** the field ``price`` is less
  than ``9.95``:

  .. code-block:: javascript

     db.inventory.find( { $or: [ { qty: { $gt: 100 } },
                                 { price: { $lt: 9.95 } } ]
                        } )

- Compound ``query`` argument specifies the criteria where the field
  ``type`` equals ``food`` the field **and** either the field ``qty``
  is greater than ``100`` **or** the field ``price`` is less than
  ``9.95``:

  .. code-block:: javascript

     db.inventory.find( { type: 'food', $or: [ { qty: { $gt: 100 } },
                                               { price: { $lt: 9.95 } } ]
                         } )

- A ``query`` argument specifies the criteria where the array field
  ``tags`` contains the element ``fruit``:

  .. code-block:: javascript

     db.inventory.find( { tags: "fruit" } )

MongoDB provides numerous query selector operators such as the
:operator:`$lt` operator and the :operator:`$or` operator. Refer to the
:doc:`/reference/operators` for the complete list of the ``query``
operators.

.. _read-operations-projection:

Projection Argument
~~~~~~~~~~~~~~~~~~~

The ``projection`` argument specifies the fields to return for the
matching documents. By narrowing the fields to return, projections can
minimize network and deserialization costs. In the ``projection``
argument, you can either specify the fields to include (``field:1``) or
specify the fields to exclude (``field:0``). The ``_id`` field is
implicitly included in the ``projection`` argument.

Consider the ``projection`` arguments in the following :method:`find()
<db.collection.find()>` method calls:

- No ``projection`` argument specifies that the :method:`find()
  <db.collection.find()>` method return all fields in the documents
  that have the ``type`` field equal to ``food``.

  .. code-block:: javascript

     db.inventory.find( { type: 'food' } )

- The ``projection`` argument specifies that the :method:`find()
  <db.collection.find()>` method return the ``item`` field, the ``qty``
  field, and by default, the ``_id`` field in the documents that have
  the ``type`` field equal to ``food``.

  .. code-block:: javascript

     db.inventory.find( { type: 'food' }, { item: 1, qty: 1 } )

- The ``projection`` argument specifies that the :method:`find()
  <db.collection.find()>` method return the ``item`` field and the
  ``qty`` field only in the documents that have the ``type`` field
  equal to ``food``.

  .. code-block:: javascript

     db.inventory.find( { type: 'food' }, { item: 1, qty: 1, _id:0 } )

  .. note:: 

     The ``projection`` argument cannot contain both include and
     exclude specifications *except* for the exclusion of the ``_id``.

- The ``projection`` argument specifies that the :method:`find()
  <db.collection.find()>` method return all fields except the ``type``
  field in the documents that have the ``type`` field equal to ``food``.

  .. code-block:: javascript

     db.inventory.find( { type: 'food' }, { type:0 } )

MongoDB also provides the following projection operators specific to
arrays. Refer to the operator documentation:

- :projection:`$elemMatch`

- :projection:`$slice`

.. _read-operations-indexing:

Indexes
-------

Indexes improve the efficiency of read operations by optimizing queries,
pre-sorting query results, and making it possible to store fewer
documents in memory.

The syntax to create an index on a collection is:

.. code-block:: javascript

   db.collection.ensureIndex( { field1: order1, field2: order2, ... } )

- The ``field`` specifies the field to index.

- The ``order`` specifies ascending ( ``1`` ) or descending ( ``-1`` ).

Refer to the :method:`ensureIndex() <db.collection.ensureIndex>` method
documentation for additional options available for the method.

Consider the performance of the following read operation that does not
use an index:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).explain()

The results from the :method:`explain() <cursor.explain()>` method
shows that the execution of the :method:`find() <db.collection.find()>`
method would involve scanning ``4000006`` documents to return ``5``
objects:

.. code-block:: javascript

   {
     "cursor" : "BasicCursor", 
     "isMultiKey" : false,
     "n" : 5,
     "nscannedObjects" : 4000006,
     "nscanned" : 4000006,
     "nscannedObjectsAllPlans" : 4000006,
     "nscannedAllPlans" : 4000006,
     "scanAndOrder" : false,
     "indexOnly" : false,
     "nYields" : 2,
     "nChunkSkips" : 0, 
     "millis" : 1591, 
     "indexBounds" : { }, 
     "server" : "My-Machine.local:27017" 
   }

To improve the performance of the query, create an index on the
``type`` field:

.. code-block:: javascript

   db.inventory.ensureIndex( { type: 1 } )

Compare the performance of the previous read operation, but now
executed with the newly created index:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).explain()

The results show a substantial improvement in the performance of the
operation. The execution of the :method:`find() <db.collection.find()>`
method would involve scanning ``5`` documents to return ``5`` objects:

.. code-block:: javascript

   {
     "cursor" : "BtreeCursor type_1",
     "isMultiKey" : false,
     "n" : 5,
     "nscannedObjects" : 5,
     "nscanned" : 5,
     "nscannedObjectsAllPlans" : 5,
     "nscannedAllPlans" : 5,
     "scanAndOrder" : false,
     "indexOnly" : false,
     "nYields" : 0,
     "nChunkSkips" : 0,
     "millis" : 0,
     "indexBounds" : { "type" : [
                                   [ "food",
                                     "food" ]
                                ] },
     "server" : "My-Machine.local:27017" }

.. index:: query optimizer
.. _read-operations-query-optimization:

Query Optimization
~~~~~~~~~~~~~~~~~~

The MongoDB query optimizer matches a query to the index that produces
the fastest results. The optimizer then uses this query plan each time
the query runs. If a collection changes significantly, the optimizer
creates a new query plan.

MongoDB creates a query plan as follows:

1. The query optimizer runs the query against several indexes in
   parallel.

#. The optimizer records the matches in a single common buffer, as
   though the results all come from the same index.

#. If an index returns a result already returned by another index, the
   optimizer skips the duplicate match.

#. The optimizer determines a "winning" index when either of
   the following occur:

   - The optimizer exhausts an index, which means that the index has
     provided the full result set. At this point, the optimizer stops
     querying.

   - The optimizer reaches 101 results. At this point, the optimizer
     chooses the index that has provided the most results *first* and
     continues reading only from that index. 

#. The "winning" index becomes the index specified in the query plan.

To evaluate the optimizer's choice of query plan, run the query with
the :method:`explain() <cursor.explain()>` method and the
:method:`hint() <cursor.hint()>` method appended. Instead of returning
query results, this returns statistics about how the query runs. For
example:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).explain().hint()

For details on the output, see the :method:`explain()
<cursor.explain()>` method documentation.

.. note::

   If you run :method:`explain() <cursor.explain()>` without including
   :method:`hint() <cursor.hint()>` the query optimizer re-evaluates
   the query and runs against multiple indexes before returning the query
   statistics.

As collections change over time, the query optimizer deletes a query
plan and re-evaluates the indexes when any of the following occur:

- The number of writes to the collection reaches 1,000.

- You run the :dbcommand:`reIndex() <reIndex>` command on the index.

- You restart :program:`mongod`.

When you re-evaluate a query, the optimizer displays the same results if
no data has changed, but the the results might appear in a different
order. This is because the optimizer retrieves the results from several
indexes at once during re-evaluation, and the order in which results
appear depends on the order of the indexes in the
parallel query operation.

For more information, refer to :doc:`/applications/indexes`.

.. _read-operations-aggregation:

Aggregation
~~~~~~~~~~~

When you run a query using aggregation, MongoDB performs summary,
grouping, or other operations on data before returning results. When you
run a query without aggregation, you retrieve data as it's stored in the
database; when you run with aggregation, you retrieve reframed data.

Beginning with MongoDB version 2.1, the primary way to perform
aggregation is through the aggregation framework, which processes data
through pipelines and returns data as a document stream specific to the
aggregation process.

For more information on the aggregation framework, including
descriptions of operators, see see :doc:`/applications/aggregation`.

In addition to the operators used by the aggregation framework, you can
use the following aggregation operators. For documentation on each
operator, click the operator name:

- :method:`count() <cursor.count()>`

- :dbcommand:`distinct() <distinct>`

- :method:`group()`

- :dbcommand:`mapReduce() <mapreduce>` (See also :wiki:`MapReduce`.)

.. index:: read operation; architecture
.. _read-operations-architecture:

Query Operators that Cannot Use Indexes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some query operators cannot take advantage of indexes and require a
collection scan. When using these operators you can narrow the documents
scanned by combining the operator with another operator that does use an
index.

Operators that cannot use indexes include the following:

- :operator:`$nin`

- :operator:`$ne`

.. TODO Regular expressions queries also do not use an index except when used with anchors.
.. TODO :method:`cursor.skip()` can cause paginating large numbers of docs

Architecture
------------

.. index:: read operation; connection pooling
.. index:: connection pooling; read operations
.. _read-operations-connection-pooling:

Connection Pooling
~~~~~~~~~~~~~~~~~~

.. TODO

Shard Clusters
~~~~~~~~~~~~~~

Issue all read operations to a sharded cluster to one of the
:program:`mongos` instances associated with the cluster. From the
perspective of the application there is no difference between read
operations to MongoDB sharded clusters and read operations to
standalone instances and replica sets.

For non-sharded collections, the :program:`mongos` locates the
:term:`primary shard` for the database, and directs all operations to
that :program:`mongod` instance. For sharded collections, the
:program:`mongos` must determine which :term:`shard` may have
documents that could match the query using the :term:`shard
key`. Then, the :program:`mongos` can direct the query to the relevant
members and merge all reseults.

If the query operation includes either the shard key, *or* a prefix of
the shard key, the :program:`mongos` may be able to target the query
to a smaller subset of the shards. In other cases, the
:program:`mongos` must query *all* shards in the cluster for
results. For clusters with a small number of shards, non-targeted
queries may perform acceptabily, but with more shards these
non-targeted queries, are inefficient and not pratical for routine
operations. When choosing a shard key, always pick a key that allows
you to minimize or eleminate non-targeted queries.

For more information on read operations in sharded systems, consider
the following resources:

- :ref:`An Introduction to Shard Keys <sharding-shard-key>`
- :ref:`Shard Key Internals and Operations <sharding-internals-shard-keys>`
- :ref:`Quering Sharded Clusters <sharding-internals-querying>`
- :ref:`sharding-mongos`

Replica Sets
~~~~~~~~~~~~

:term:`Replica sets <replica set>` use :term:`read preferences <read
preference>` to determine where and how to route read operations. By
default, MongoDB always reads data from a replica set's :term:`primary`.
You can modify that behavior by changing the :ref:`read preference mode
<replica-set-read-preference-modes>`.

For example, you can set the :ref:`read preference mode
<replica-set-read-preference-modes>` to allow reads from
:term:`secondaries <secondary>` when backing up data, or to block reads
entirely during a :ref:`failover <replica-set-failover>`.

If the majority of database use are read operations, then
using read preferences to distribute reads can improve read throughput.
The trade-off is that some reads might return stale data, as
secondaries always have some amount of lag.

For more information on choosing read preference modes, see
:ref:`replica-set-read-preference-modes`.
