.. _fts-field-mappings:

=====================
Define Field Mappings
=====================

.. default-domain:: mongodb

.. meta::
   :keywords: atlas search, define a static mapping, define a dynamic mapping, index a field, index multiple fields, index an array, array of fields, atlas search supported data types, atlas search field types, index definition example, static mapping example, static and dynamic mapping example, combined mapping example
   :description: Learn how to include specific fields in your search index or how to configure Atlas Search to automatically include all supported field types.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

When you create an |fts| index, you can:

- Specify the fields to index using static mappings. 
- Configure |fts| to automatically index all supported field types using
  dynamic mappings. 

To use static mappings, you must explicitly include the fields in the
collection that you want to index. In the ``type`` field, specify the 
:ref:`data type <bson-data-chart>` of the field in the field 
definition. Alternatively, you can specify an array of field definitions
for a field, one for each data type.

.. code-block:: json  
   :caption: Syntax 
   :emphasize-lines: 3-12
   :linenos:

   "mappings": { 
     "dynamic": <boolean>, 
     "fields": { 
       "<field-name>": [
         {
           "type": "<field-type>",
           ...
         },
         ...
       ],
       ...  
     }
   }

.. include:: /includes/fact-fts-index-field-order.rst 

.. _static-dynamic-mappings:

Static and Dynamic Mappings 
---------------------------

For **Static mappings**, set ``mappings.dynamic`` to ``false`` and 
specify the fields to index using ``mappings.fields``. |fts| only 
indexes the specified fields with specific options. 

Use static mappings to configure index options for fields that
shouldn't be indexed dynamically, or to configure a single field 
independently from others in an index.

.. note:: 

   You must specify static mappings when ``mappings.dynamic`` is 
   ``false``.

For **Dynamic mappings**, set ``mappings.dynamic`` to ``true``. |fts| 
automatically indexes the fields of :ref:`supported types 
<bson-data-chart>` in each document. For fields of type 
:ref:`bson-data-types-string`, |fts| stores the fields on ``mongot``.

Use dynamic mappings if your schema changes regularly or is unknown, or 
when experimenting with |fts|. You can configure an entire index to use 
dynamic mappings, or specify individual fields, such as fields of type 
``document``, to be dynamically mapped. Before using dynamic mappings,
see :ref:`bson-data-types-limitations`. 

.. note::

   Dynamically mapped indexes occupy more disk space than statically 
   mapped indexes and may be less performant.

.. _bson-data-chart:

|bson| Data Types
-----------------

|fts| doesn't support the following :manual:`BSON data types 
</reference/bson-types/>`\:

- Binary Data
- Decimal128
- JavaScript code with scope
- Max key
- Min key
- Null
- Regular Expression
- Timestamp

The following table enumerates the supported :manual:`BSON data types
</reference/bson-types/>` and the |fts| field type for the 
:manual:`BSON data types </reference/bson-types/>`. The table also  
indicates whether the |fts| field type is automatically included in an 
|fts| index when you enable :ref:`dynamic mappings 
<static-dynamic-mappings>`. 

.. list-table::
   :header-rows: 1

   * - BSON Type
     - Atlas Search Field Type
     - Dynamic Indexing?

   * - :ref:`Array <fts-array-ref>`
     - 
     - ✓ :icon-fa5:`star`

   * - Boolean
     - :ref:`boolean <boolean-ref>`
     - ✓

   * - Date
     - :ref:`date <bson-data-types-date>`
     - ✓ 

   * - Date
     - :ref:`dateFacet <bson-data-types-date-facet>`
     - 

   * - Double
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - Double
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - 32-bit integer
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - 32-bit integer
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - 64-bit integer
     - :ref:`number <bson-data-types-number>`
     - ✓ 

   * - 64-bit integer
     - :ref:`numberFacet <bson-data-types-number-facet>`
     - 

   * - Object
     - :ref:`document <bson-data-types-document>`
     - ✓ 

   * - Object
     - :ref:`embeddedDocuments <bson-data-types-embedded-documents>` 
       (for array of objects)
     - 

   * - ObjectId
     - :ref:`objectId <objectId-ref>`
     - ✓

   * - String 
     - :ref:`string <bson-data-types-string>`
     - ✓ 

   * - String 
     - :ref:`stringFacet <bson-data-types-string-facet>`
     - 

   * - String 
     - :ref:`bson-data-types-autocomplete`
     - 

:icon-fa5:`star` Some limitations apply. To learn more, see
:ref:`fts-array-ref`. 

.. note:: 

   You can store fields of all supported :ref:`data types 
   <bson-data-chart>` on |fts| using the ``storedSource`` :ref:`option 
   <index-definition-options>`.

.. _bson-data-types-limitations:

Limitations
~~~~~~~~~~~

|fts| doesn't support :ref:`dynamic mapping <static-dynamic-mappings>` 
to automatically index fields of any type for faceting. Instead, you 
must use :ref:`static mappings <static-dynamic-mappings>` to index the 
fields as the following |fts| field types: 

- :ref:`bson-data-types-date-facet` to run a facet query on ``date`` 
  fields.
- :ref:`bson-data-types-number-facet` to run a facet query on 
  ``number`` fields. 
- :ref:`bson-data-types-string-facet` to run a facet query on 
  ``string`` fields.

.. _bson-data-types-indexing:

Index Field as Multiple Data Types 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To index a field as multiple types, define the types in the field 
definition array for the field.  

.. example:: 
   
   The following example shows the field definition for indexing a 
   field as multiple types.

   .. code-block:: json
      :copyable: false 
      :linenos:
      :emphasize-lines: 6-16

      {
        ...
        "mappings": { 
          "dynamic": <boolean>, 
          "fields": { 
            "<field-name>": [
              {
                "type": "<field-type>",
                ...
              },
              {
                "type": "<field-type>",
                ...
              },
              ...
            ],
            ...  
          },
          ... 
        }
      }

.. _fts-array-ref:

Index Array
~~~~~~~~~~~

For indexing arrays, |fts| requires only the data type of the array 
elements. You don't have to specify that the data is contained in an 
array in the index definition. 

.. _fts-array-example:

.. example::

   The following index definition for the ``sample_mflix.movies`` 
   collection in the :ref:`sample dataset <available-sample-datasets>` 
   indexes the ``genres`` field, which contains an array of string 
   values. 

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "genres": {
              "type": "string"
            }
          }
        }
      }

|fts| doesn't index the following |fts| field types if the field type 
is contained in an array or is in a document that is contained in an 
array:

- :ref:`bson-data-types-date-facet`
- :ref:`bson-data-types-number-facet`

|fts| supports indexing the :ref:`supported data types
<bson-data-chart>` inside an array by flattening the fields during
indexing. 

.. example:: 

   For example, consider the following documents:

   .. code-block:: javascript 
      :copyable: false

      doc1 = { a: {b: [[<value1>, <value2>], <value3>] }}
      doc2 = { a: {b: [<value1>, <value2>, <value3>] } }
      doc3 = { a: [{ b: <value1>}, {b: <value2>}, {b: <value3>}] }

   |fts| flattens the preceding arrays similar to the following during
   indexing: 

   .. code-block:: shell 
      :copyable: false 

      LuceneDoc<n> = {"a.b":[<value1>,<value2>,<value3>]}

For querying individual documents inside an array of documents, you must
use the :ref:`bson-data-types-embedded-documents` type. 

.. _bson-data-types:

|fts| Field Types
-----------------

.. _bson-data-types-autocomplete:

autocomplete
~~~~~~~~~~~~

.. include:: /includes/fact-autocomplete-field-type.rst

.. tip:: 

   If you have a large number of documents and a wide range of data 
   against which you wish to run |fts| queries using the 
   :ref:`autocomplete-ref` operator, we recommend that you create a 
   separate index of type ``autocomplete`` because building this index 
   could take some time. You can define an autocompete-specific index 
   to reduce the impact on other indexes and queries while the index  
   builds.

The ``autocomplete`` type takes the following options: 

.. list-table::
   :widths: 18 9 8 54 11
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description
     - Default

   * - ``type``
     - string 
     - required
     - Human-readable label that identifies this field type. Value must be ``autocomplete``.
     - 

   * - ``analyzer``
     - string
     - optional
     - Name of the :ref:`analyzer <analyzers-ref>` to use with this 
       autocomplete mapping. You can use any |fts| analyzer except the 
       ``lucene.kuromoji`` :ref:`language analyzer 
       <ref-language-analyzers>` and the following :ref:`custom 
       analyzer <custom-analyzers>` tokenizers and token filters: 

       - :ref:`nGram <ngram-tokenizer-ref>` Tokenizer
       - :ref:`edgeGram <edgegram-tokenizer-ref>` Tokenizer
       - :ref:`daitchMokotoffSoundex <daitchmokotoffsoundex-tf-ref>` 
         Token Filter
       - :ref:`nGram <ngram-tf-ref>` Token Filter 
       - :ref:`edgeGram <edgegram-tf-ref>` Token Filter 
       - :ref:`shingle <shingle-tf-ref>` Token Filter

     - ``lucene.standard``
      
   * - ``maxGrams``
     - int
     - optional
     - Maximum number of characters per indexed sequence. The 
       value limits the character length of indexed tokens. When you 
       search for terms longer than the ``maxGrams`` value, |fts| 
       truncates the tokens to the ``maxGrams`` length.
     - ``15``

   * - ``minGrams``
     - int
     - optional
     - Minimum number of characters per indexed sequence. We 
       recommend ``4`` for the minimum value. A value that is less 
       than ``4`` could impact performance because the size of the 
       index can become very large. We recommend the default value of 
       ``2`` for ``edgeGram`` only.
     - ``2``

   * - ``tokenization``
     - enum
     - optional
     - Tokenization strategy to use when indexing the field for 
       autocompletion. Value can be one of the following: 

       - ``edgeGram`` - create indexable tokens, referred to as 
         ``grams``, from variable-length character sequences starting 
         at the left side of the words as delimited by the analyzer 
         used with this autocomplete mapping.

       - ``rightEdgeGram`` -  create indexable tokens, referred to 
         as ``grams``, from variable-length character sequences 
         starting at the right side of the words as delimited by the 
         analyzer used with this autocomplete mapping.

       - ``nGram`` - create indexable tokens, referred to as 
         ``grams``, by sliding a variable-length character window over 
         a word. |fts| creates more tokens for ``nGram`` than 
         ``edgeGram`` or ``rightEdgeGram``. Therefore, ``nGram`` takes 
         more space and time to index the field. ``nGram`` is better 
         suited for querying languages with long, compound words or 
         languages that don't use spaces.

       ``edgeGram``, ``rightEdgeGram``, and ``nGram`` are applied at 
       the letter-level. For example, consider the following sentence: 
         
       .. code-block:: none
          :copyable: false 

          The quick brown fox jumps over the lazy dog. 

       When tokenized with ``minGrams`` value of ``2`` and ``maxGrams`` 
       value of ``5``, |fts| indexes the following sequence of 
       characters based on the ``tokenization`` value you choose: 

       .. tabs:: 

          .. tab:: edgeGram
             :tabid: edgegram

             .. code-block:: none
                :copyable: false 

                Th
                The
                The{SPACE}
                The q 
                qu
                qui
                quic
                quick
                ...

          .. tab:: rightEdgeGram 
             :tabid: rightedgegram

             .. code-block:: none
                :copyable: false 

                og
                dog
                {SPACE}dog
                y dog
                zy
                azy
                lazy
                {SPACE}lazy
                he
                the
                {SPACE}the
                r the
                er
                ver
                over
                {SPACE}over
                ...

          .. tab:: nGram
             :tabid: ngram

             .. code-block:: none 
                :copyable: false 

                Th
                The 
                The{SPACE}  
                The q
                he 
                he{SPACE}   
                he q
                he qu
                e{SPACE} 
                e q
                qu
                e qui
                {SPACE}q
                {SPACE}qu
                {SPACE}qui
                {SPACE}quic
                qu
                qui
                quic
                quick
                ...

       .. note:: 

          Indexing a field for autocomplete with an ``edgeGram``, 
          ``rightEdgeGram``, or ``nGram`` tokenization strategy is more 
          computationally expensive than indexing a string field. The 
          index takes more space than an index with regular string 
          fields.

     - ``edgeGram``

   * - ``foldDiacritics``
     - boolean
     - optional
     - Flag that indicates whether diacritics should be 
       included or removed from the indexed text. Value can be 
       one of the following: 

       - ``true`` - ignore diacritic marks in the index and query 
         text. Returns results with and without diacritic marks. For 
         example, a search for ``cafè`` returns results with the 
         characters ``cafè`` and ``cafe``.
       - ``false`` - include diacritic marks in the index and query 
         text. Returns only results that match the strings with or 
         without diacritics in the query. For example, a search for 
         ``cafè`` returns results only with the characters ``cafè``. A 
         search for ``cafe`` returns results only with the characters 
         ``cafe``.

     - ``true``

.. example::

   .. code-block:: json 
      :emphasize-lines: 6-11

      {
        "mappings": {
          "dynamic": true|false,
          "fields": {
            "<field-name>": {
              "type": "autocomplete",
              "analyzer": "lucene.standard",
              "tokenization": "edgeGram|rightEdgeGram|nGram",
              "minGrams": <2>,
              "maxGrams": <15>,
              "foldDiacritics": true|false
            }
          }
        }
      }

.. note:: 

   You can index a field as other types also by specifying the other 
   types in the array. For example, the following index definition 
   indexes the field as both ``autocomplete`` and ``string`` types.

   .. code-block:: json 
      :emphasize-lines: 6, 14
         
      {
        "mappings": {
          "dynamic": true|false,
          "fields": {
            "<field-name>": [
              {
                "type": "autocomplete",
                "analyzer": "lucene.standard",
                "tokenization": "edgeGram|rightEdgeGram|nGram",
                "minGrams": <2>,
                "maxGrams": <15>,
                "foldDiacritics": true|false
              },
              {
                "type": "string"
              }
            ]
          }
        }
      }

.. _boolean-ref:

boolean
~~~~~~~

Use the ``boolean`` data type to index ``true`` and ``false`` 
values. It works in conjunction with the :ref:`equals <equals-ref>` 
operator.

The ``boolean`` type takes the following option: 

.. list-table::
   :widths: 18 9 8 54 
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description

   * - ``type``
     - string 
     - required
     - Human-readable label that identifies this field type. Value must
       be ``boolean``. 

.. _boolean-objectid-example:

.. example::

   The following example index definition maps a field named 
   ``verified_user`` to the ``boolean`` data type and a field named 
   ``teammates`` to the ``objectId`` data type.

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "verified_user": {
              "type": "boolean"
            },
            "teammates": {
              "type": "objectId"
            }
          }
        }
      }

.. _bson-data-types-date:

date
~~~~

Use the ``date`` type to index date values. The ``date`` type takes the
following option:  

.. list-table::
   :widths: 18 9 8 54
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description

   * - ``type``
     - string 
     - required
     - Human-readable label that identifies this field type. Value must
       be ``date``. 

.. note:: 
   
   You must index the date fields using  
   :ref:`bson-data-types-date-facet` to run a facet query on ``date`` 
   fields.

   You must use the :ref:`range-ref` operator only to query indexed 
   date values inside arrays. You can't use the :ref:`near-ref` operator
   to query date values stored in an array, even if you have an |fts|
   index on the date values inside the array.

.. _bson-data-types-date-facet:

dateFacet 
~~~~~~~~~

Use the ``dateFacet`` type for indexing date values for faceting.  

.. note::

   You can't index date field for faceting if it's inside an array or if
   it's inside a document in an array. 

   |fts| doesn't support date faceting over fields indexed as part of 
   an ``embeddedDocuments`` field.

The ``dateFacet`` type takes the following option:  

.. list-table::
   :widths: 18 9 8 54
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description

   * - ``type``
     - string 
     - required
     - Human-readable label that identifies this field type. Value must
       be ``dateFacet``. 

.. example:: 

   The following index definition for the ``sample_mflix.movies`` 
   collection in the :ref:`sample dataset <available-sample-datasets>` 
   indexes the ``released`` field as ``dateFacet`` for faceting.

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "released": {
              "type": "dateFacet"
            }
          }
        }
      }

.. _bson-data-types-document:

document
~~~~~~~~

Use the ``document`` data type to index fields with embedded documents.
It takes the following parameters:

.. list-table::
   :widths: 15 10 15 50 10
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description
     - Default

   * - ``type``
     - string
     - Required
     - Human-readable label that identifies the field type.
       Value must be ``document``.
     - 

   * - ``dynamic``
     - boolean
     - Conditional
     - Flag that indicates whether |fts| recursively indexes all fields 
       and embedded documents. If set to ``true``, |fts| recursively 
       indexes all fields and embedded documents in the ``document`` 
       except fields of :ref:`certain data types <bson-data-chart>`.
       
       To index all fields in a document including fields that 
       |fts| doesn't dynamically index, define the fields 
       in the index definition.

       If omitted or set to ``false``, you must specify individual 
       fields to index.

       .. include:: /includes/admonitions/importants/dynamic-flag-considerations.rst

     - false

   * - ``fields``
     - document
     - Conditional
     - Document that maps field names to field definitions. To learn 
       more, see an :ref:`example <index-config-example>`. This is 
       required if ``dynamic`` is omitted or set to ``false``. 
     - 

.. _bson-data-types-embedded-documents:

embeddedDocuments
~~~~~~~~~~~~~~~~~

.. note:: 

   .. include:: /includes/fact-embedded-document-preview.rst

Use the ``embeddedDocuments`` type to index fields in documents that 
are elements of an array. |fts| indexes embedded documents independent 
of their parent document. Each indexed document contains only fields 
that are part of the embedded document array element. 

The following limitations apply:

- You can use ``embeddedDocuments`` only on fields with up to ``5`` 
  levels of nesting. An ``embeddedDocuments`` field can't have more 
  than ``4`` parent ``embeddedDocuments`` fields.
- You can't use ``embeddedDocuments`` for :ref:`date 
  <bson-data-types-date-facet>` or :ref:`numeric 
  <bson-data-types-number-facet>` faceting. 
- You can't :ref:`highlight <highlight-ref>` fields or children of
  fields indexed as the ``embeddedDocuments`` type.

.. important:: 

   .. include:: /includes/fact-fts-embedded-documents-limitation.rst

It takes the following options:

.. list-table::
   :widths: 15 10 15 50 10
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description
     - Default

   * - ``type``
     - string
     - Required
     - Human-readable label that identifies the field type.
       Value must be ``embeddedDocuments``.
     - 

   * - ``dynamic``
     - boolean
     - Optional
     - Flag that specifies whether to index every dynamically indexable 
       field in the document. Value can be one of 
       the following: 

       - ``true`` - index all indexable fields
       - ``false`` - don't index all the indexable fields 

     - ``false``

   * - ``fields``
     - document
     - Conditional
     - Fields to index. 
     
       If ``dynamic`` is ``true``, |fts| indexes all indexable fields.
       
       If ``dynamic`` is ``false``, you can specify the fields to index 
       in the field definition for ``fields``.

       .. note:: 

          |fts| doesn't support indexing facet fields as part of an 
          ``embeddedDocuments`` field.

     - ``{}``

Examples 
```````` 

The following index examples use the ``sample_supplies.sales`` 
collection in the :ref:`sample dataset <sample-data>`.

.. tabs:: 

   .. tab:: Index All Fields
      :tabid: include 

      .. example:: 

         The following index definition specifies that all dynamically 
         indexable fields in the ``items`` array of documents must be 
         automatically indexed. You can use the **Visual Editor** or the 
         **JSON Editor** in the {+atlas-ui+} to configure the index.
         After you select your preferred configuration method, select
         the database and collection.

         .. tabs:: 

            .. tab:: Visual Editor 
               :tabid: vib 

               a. Click :guilabel:`Refine Your Index` to configure your
                  index.
               #. In the :guilabel:`Field Mappings` section, click
                  :guilabel:`Add Field` to open the :guilabel:`Add Field
                  Mapping` window. 
               #. Select :guilabel:`items` from the :guilabel:`Field
                  Name` dropdown.
               #. Click the :guilabel:`Data Type` dropdown and select
                  :guilabel:`EmbeddedDocuments`.  
               #. Toggle :guilabel:`Enable Dynamic Mapping` to enable
                  dynamic mapping, if needed.
               #. Click :guilabel:`Add`.

            .. tab:: JSON Editor 
               :tabid: jsonib

               Replace the default index definition with the following 
               index definition.

               .. code-block:: json 

                  {
                    "mappings": {
                      "fields": {
                        "items": {
                          "type": "embeddedDocuments",
                          "dynamic": true
                        }
                      }
                    }
                  }

         .. note:: 

            To index all fields in an embedded document including 
            fields that |fts| doesn't dynamically index, define the fields 
            in the index definition. For string faceting, |fts| counts 
            string facets once for each document in the result set.
            For example, the following index definition shows how to 
            dynamically index all fields in an embedded document field 
            named ``items``. The index definition includes a field 
            ``purchaseMethod`` of type
            :ref:`bson-data-types-string-facet`, which |fts| doesn't 
            dynamically index:

            .. tabs:: 
               :hidden:

               .. tab:: Visual Builder 
                  :tabid: vib 

                  Click :guilabel:`Add Field` in the :guilabel:`Field
                  Mappings` section and add the following fields by
                  clicking :guilabel:`Add` after configuring the
                  settings for each field in the :guilabel:`Add
                  Field Mapping` window. 
                     
                  .. list-table:: 
                     :header-rows: 1

                     * - :guilabel:`Field Name`
                       - :guilabel:`Data Type`
                           
                     * - ``items``
                       - Click the dropdown and select
                         ``EmbeddedDocuments``. 

                     * - ``purchaseMethod``
                       - Click the dropdown and select
                         ``StringFacet``. 

               .. tab:: JSON Builder 
                  :tabid: jsonib 

                  .. code-block:: json 
   
                     {
                       "mappings": {
                         "dynamic": true,
                         "fields": {
                           "items": {
                             "dynamic": true,
                             "type": "embeddedDocuments"
                           },
                           "purchaseMethod": {
                             "type": "stringFacet"
                           }
                         }
                       }
                     }

   .. tab:: Index Specified Fields Only
      :tabid: exclude 

      .. example:: 

         The following index defintion identifies the specific fields 
         in the ``items`` array of documents to index. You can use the
         **Visual Editor** or the **JSON Editor** in the {+atlas-ui+} to 
         configure the index. 
         
         You can use the **Visual Editor** or the **JSON Editor** in the
         {+atlas-ui+} to configure the index. After you select your
         preferred configuration method, select the database and
         collection. 

         .. tabs:: 

            .. tab:: Visual Editor 
               :tabid: vib 

               a. Click :guilabel:`Refine Your Index` to configure your
                  index. 
               #. In the :guilabel:`Field Mappings` section, click
                  :guilabel:`Add Field` to open the :guilabel:`Add Field
                  Mapping` window. 
               #. Select :guilabel:`items` from the :guilabel:`Field
                  Name` dropdown.
               #. Click the :guilabel:`Data Type` dropdown and select
                  :guilabel:`EmbeddedDocuments`.  
               #. Disable :guilabel:`Enable Dynamic Mapping`.
               #. Click :guilabel:`Add`.
               #. Click :guilabel:`Add Embedded Field` for the
                  :guilabel:`items` field in the :guilabel:`Field
                  Mappings` table. 
               #. Select :guilabel:`.name` under the
                  :guilabel:`items` field from the :guilabel:`Field
                  Name` dropdown.
               #. Click the :guilabel:`Data Type` dropdown and select
                  :guilabel:`String`. 
               #. Click :guilabel:`Save`.
               #. Repeat steps **g** to **j** to add :guilabel:`.tags`
                  field under :guilabel:`items` as :guilabel:`String`
                  type. 
               #. Click :guilabel:`Add`.

            .. tab:: JSON Editor 
               :tabid: jsonib

               Replace the default index definition with the following 
               index definition.

               .. code-block:: json 

                  {
                    "mappings": {
                      "fields": {
                        "items": {
                          "type": "embeddedDocuments",
                          "dynamic": false,
                          "fields": {
                            "name": {
                              "type": "string"
                            },
                            "tags": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }

.. _bson-data-types-geo:

geo
~~~

Use the ``geo`` type to index geographic point and shape 
coordinates. For this type, the indexed field must be a 
:manual:`GeoJSON </reference/geojson/>` object.

.. list-table::
   :widths: 20 10 10 50 10
   :header-rows: 1

   * - Option
     - Type 
     - Necessity
     - Description
     - Default

   * - ``type``
     - string 
     - Required
     - Human-readable label that identifies this field type.
       Value must be ``geo``.
     - 

   * - ``indexShapes`` 
     - boolean 
     - Optional
     - Flag that indicates whether to index shapes. By default, |fts|: 

       - Indexes points, even when nested.
       - Doesn't index shape geometries such as lines and polygons.

       Value can be: 

       - ``true`` to index shapes and points 
       - ``false`` to index only points

     - ``false``

.. example:: 

   .. code-block:: json 
      :emphasize-lines: 7-8

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "<field-name>": {
              "indexShapes": true|false,
              "type": "geo"
            }
          }
        }
      }

.. _bson-data-types-number:

number
~~~~~~

Use the ``number`` type to index fields with numeric values of 
``int32``, ``int64``, ``dateTime``, and ``double`` data types. 

.. note::
   
   - You must index the ``number`` fields using 
     :ref:`bson-data-types-number-facet` to run a facet query on 
     ``number`` fields.

   - You can use the :ref:`range-ref` operator only to query numeric 
     values in arrays.

The ``number`` type has the following options: 

.. list-table::
   :widths: 20 10 10 50 10
   :header-rows: 1

   * - Option
     - Type 
     - Necessity
     - Description
     - Default

   * - ``type``
     - string 
     - Required
     - Human-readable label that identifies this field type.
       Value must be ``number``.
     - 

   * - ``representation``
     - string 
     - Optional
     - Data type of the field to index. Values are:

       - ``int64`` - for indexing large integers without loss of 
         precision and for rounding double values to integers. You 
         can't use this type to index large double values.
       - ``double`` - for indexing large double values without rounding.

       To learn more, see :ref:`example <number-egs>` below.

     - ``double``

   * - ``indexIntegers``
     - boolean 
     - Optional
     - Flag that indicates whether to index or omit indexing ``int32`` 
       and ``int64`` type values. Value can be ``true`` or ``false``.
       To learn more, see :ref:`example <number-egs>` below.

     - ``true``

   * - ``indexDoubles``
     - boolean 
     - Optional
     - Flag that indicates whether to index or omit indexing ``double``
       type values. Value can be ``true`` or ``false``. To learn more, 
       see :ref:`example <number-egs>` below.

     - ``true``

.. _number-egs:

``representation`` Example
``````````````````````````

.. example::

   The following index definition for the 
   ``sample_analytics.accounts`` collection in the :ref:`sample 
   dataset <available-sample-datasets>` indexes the 
   ``account_id`` field with 64-bit integer values. The 
   following example also: 
    
   - Indexes all other integer values in the ``account_id`` field
   - Rounds any decimal values and indexes small double type 
     values in the ``account_id`` field

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
                "account_id": {
                  "type": "number",
                  "representation": "int64"
                }
            }
        }
      }

``indexIntegers`` Example
`````````````````````````

.. example::

   The following index definition for the 
   ``sample_airbnb.listingsAndReviews`` collection in the 
   :ref:`sample dataset <available-sample-datasets>` omits the 
   ``bathrooms`` field with 32-bit and 64-bit integer values. 
   The following example will index the ``bathrooms`` field with 
   ``double`` type values.

   .. code-block:: json 
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
              "bathrooms": {
                  "type": "number",
                  "indexIntegers": false
              }
            }
        }
      }

``indexDoubles`` Example
````````````````````````

.. example::

   The following index definition for the
   ``sample_analytics.accounts`` collection in the 
   :ref:`sample dataset <available-sample-datasets>`:
  
   - Indexes the ``account_id`` field with integer values.
   - Omits the ``account_id`` field with doubles values.

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
            "dynamic": false,
            "fields": {
              "account_id": {
                  "type": "number",
                  "representation": "int64",
                  "indexDoubles": false
              }
            }
        }
      }

.. _bson-data-types-number-facet:

numberFacet 
~~~~~~~~~~~ 

Use the ``numberFacet`` data type for indexing numeric values using 
the specified ``representation`` for faceting. You can index numbers of 
|bson| types ``int32``, ``int64``, and ``double``. The following 
limitations apply:

- You can't index ``decimal128`` for faceting. 
- You can't index numeric values in arrays or in a document contained in an array 
  for faceting.
- You can't facet over numeric fields indexed as part of an 
  ``embeddedDocuments`` field.

If you specify both :ref:`bson-data-types-number` and 
:ref:`bson-data-types-number-facet` in the index definition, |fts| uses 
the :ref:`bson-data-types-number-facet` options only for faceted 
queries on numeric fields.

The ``numberFacet`` type has the following options: 

.. list-table::
   :widths: 20 10 10 50 10
   :header-rows: 1

   * - Option
     - Type 
     - Necessity
     - Description
     - Default

   * - ``type``
     - string 
     - Required
     - The type of field. Value must be ``numberFacet``.
     - 

   * - ``representation``
     - string 
     - Optional
     - The data type of the field to index. Values can be one of the 
       following |bson| types:

       - ``int64`` - for indexing large integers without loss of 
         precision and for rounding double values to integers. You 
         can't use this type to index large double values.
       - ``double`` - for indexing large double values without rounding.

       To learn more, see :ref:`example <number-facet-egs>` below.

     - ``double``

   * - ``indexIntegers``
     - boolean 
     - Optional
     - Indicates whether to index or omit indexing ``int32`` and 
       ``int64`` type values. Value can be ``true`` or ``false``.
       To learn more, see :ref:`example <number-facet-egs>` below.
       Either this or ``indexDoubles`` must be ``true``.

     - ``true``

   * - ``indexDoubles``
     - boolean 
     - Optional
     - Indicates whether to index or omit indexing ``double`` type 
       values. Value can be ``true`` or ``false``. To learn more, 
       see :ref:`example <number-facet-egs>` below. Either this or 
       ``indexIntegers`` must be ``true``.

     - ``true``

.. _number-facet-egs:

.. example:: 

   The following index definition for the ``sample_mflix.movies`` 
   collection in the :ref:`sample dataset <available-sample-datasets>` 
   indexes the ``year`` field as ``numberFacet`` for faceting.

   .. code-block:: json
      :copyable: false

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "year": {
              "type": "numberFacet"
            }
          }
        }
      }

.. _objectId-ref:

objectId
~~~~~~~~

Use the ``objectId`` data type to index :manual:`ObjectId
</reference/bson-types/#objectid>` fields. It works in conjunction with 
the :ref:`equals <equals-ref>` operator.

The ``objectId`` type takes the following option:  

.. list-table::
   :widths: 18 9 8 54
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description

   * - ``type``
     - string 
     - required
     - Human-readable label that identifies this field type. Value must
       be ``objectId``. 

.. _bson-data-types-string:

string
~~~~~~

Use the ``string`` data type to index :manual:`string 
</reference/bson-types/#string>` fields.

.. note:: 

   You can't use :ref:`dynamic mapping <static-dynamic-mappings>` to 
   automatically index ``string`` fields for faceting. You must index 
   the fields using :ref:`bson-data-types-string-facet` to run a facet 
   query on ``string`` fields.

The ``string`` data type takes the following parameters:

.. list-table::
   :widths: 20 10 10 40 20
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description
     - Default

   * - ``type``
     - string
     - Required
     - Human-readable label that identifies this field type.
       Value must be ``string``.
     - 

   * - ``analyzer``
     - string
     - Optional
     - Name of a built-in or overridden :ref:`analyzer 
       <analyzers-ref>` to use for indexing the field. If omitted,
       defaults to an analyzer in the following order: 
       
       a. The ``analyzer`` option for the :ref:`index
          <ref-index-definitions>` if specified. 
       b. The ``lucene.standard`` analyzer.

     - 

   * - ``searchAnalyzer``
     - string
     - Optional
     - Analyzer to use when querying the field. If omitted, defaults to 
       an analyzer in the following order: 
       
       a. The ``analyzer`` option for this field if specified.
       b. The ``searchAnalyzer`` option for the :ref:`index
          <ref-index-definitions>` if specified. 
       c. The ``analyzer`` option for the :ref:`index
          <ref-index-definitions>` if specified. 
       d. The ``lucene.standard`` analyzer.

     - 

   * - ``indexOptions``
     - string
     - Optional 
     - Amount of information to store for the indexed 
       field. Value can be one of the following:

       - ``docs`` - Only indexes documents. The frequency and position 
         of the indexed term are ignored. Only a single occurence of 
         the term is reflected in the :ref:`score <scoring-ref>`.
       - ``freqs`` - Only indexes documents and term frequency. The 
         position of the indexed term is ignored. 
       - ``positions`` - Indexes documents, term frequency, and term 
         positions. 
       - ``offsets`` - (Default) Indexes documents, term frequency, 
         term positions, and term offsets. This option is required for 
         :ref:`highlight-ref`.

     - ``offsets``

   * - ``store``
     - boolean
     - Optional
     - Flag that indicates whether or not to store the exact document text as 
       well as the analyzed values in the index. Value can be ``true`` 
       or ``false``. The value for this option must be ``true`` for 
       :ref:`highlight-ref`.

       .. note:: 

          To reduce the index size and performance footprint, we 
          recommend setting ``store`` to ``false``\. To learn more, see 
          :ref:`index-perf`.

     - ``true``

   * - ``ignoreAbove``
     - int
     - Optional
     - Maximum number of characters in the value of the field to 
       index. |fts| doesn't index if the field value is greater than 
       the specified number of characters.
     - 

   * - ``multi``
     - String Field Definition
     - Optional 
     - String field to index with the name of the alternate 
       analyzer specified in the ``multi`` object. To learn more about 
       specifying the ``multi`` object, see :ref:`ref-multi-analyzers` 
       and :ref:`example <multi-eg>` below.

     - 

   * - ``norms``
     - string
     - Optional
     - String that specifies whether to include or omit the field length in 
       the result when scoring. The length of the field is determined 
       by the number of tokens produced by the analyzer for the field. 
       Value can be one of the following: 
 
       - ``include`` - to include the field length when scoring.
       - ``omit`` - to omit the field length when scoring.
      
       If value is ``include``, |fts| uses the length of the field to 
       determine the higher score when scoring. For example, if two 
       documents match an |fts| query, the document with the shorter 
       field length scores higher than the document with the longer 
       field length.

       If value is ``omit``, |fts| ignores the field length when 
       scoring. 

     - ``include``

.. _multi-eg:

``multi`` Example 
`````````````````

.. example:: 
       
   The following index definition for a ``library.books`` collection 
   indexes string values in the field ``text`` with the 
   ``lucene.english`` and ``lucene.french`` analyzers in addition to 
   the default ``lucene.standard`` analyzer:

   .. code-block:: json 
      :copyable: false

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "text": {
              "type": "string",
              "multi": {
                "english": {
                  "type": "string",
                  "analyzer": "lucene.english"
                },
                "french": {
                  "type": "string",
                  "analyzer": "lucene.french"
                }
              }
            }
          }
        }
      }

.. _bson-data-types-string-facet:

stringFacet
~~~~~~~~~~~

Use the ``stringFacet`` data type to index :manual:`string 
</reference/bson-types/#string>` fields for faceting, which allows you 
to run a facet query on that field. |fts| doesn't apply the analyzer 
when indexing ``string`` fields for faceting. The ``stringFacet`` data 
type takes the following parameter:

.. list-table::
   :widths: 20 10 10 40 20
   :header-rows: 1

   * - Option
     - Type
     - Necessity
     - Description
     - Default

   * - ``type``
     - string
     - Required
     - Human-readable label that identifies this field type.
       Value must be ``stringFacet``.
     - 

.. note:: 

   To perform a normal search on the same field, you must index the 
   field as type ``string`` also.

.. _string-facet-egs:

``stringFacet`` Examples
`````````````````````````

.. tabs:: 

   .. tab:: stringFacet Type Example
      :tabid: sfeg1

      The following index definition for the ``sample_mflix.movies`` 
      collection in the :ref:`sample dataset 
      <available-sample-datasets>` indexes the ``genres`` field as 
      ``stringFacet`` for faceting.

      .. code-block:: json
         :copyable: false

         {
           "mappings": {
             "dynamic": false,
             "fields": {
               "genres": {
                 "type": "stringFacet"
               }
             }
           }
         }

   .. tab:: Normal Search Example
      :tabid: sfeg2

      The following index definition for the ``sample_mflix.movies`` 
      collection in the :ref:`sample dataset 
      <available-sample-datasets>` indexes the ``genres`` field as 
      ``stringFacet`` for faceting and as ``string`` for performing a 
      normal search.

      .. code-block:: json
         :copyable: false

         {
           "mappings": {
             "dynamic": false,
             "fields": {
               "genres": {
                 "type": "stringFacet"
               },
               {
                 "type": "string"
               }
             }
           }
         }

.. _index-config-example:

Examples
--------

Static Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~

The following index definition example uses static mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that are not explicitly 
  mentioned are not indexed. So, the index definition includes:

  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``.
    
    The ``city`` sub-field uses the :ref:`lucene.simple
    <ref-simple-analyzer>` analyzer by default for queries.
    It uses the ``ignoreAbove`` option to ignore any string of
    more than 255 bytes in length.
    
    The ``state`` sub-field uses the :ref:`lucene.english
    <ref-language-analyzers>` analyzer by default for queries.

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries.

    To learn more about ``multi`` analyzers, see :ref:`Path 
    Construction <ref-path>`.

  - The ``employees`` field, which is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. For indexing arrays, |fts| 
    only requires the data type of the array elements. You don't 
    have to specify that the data is contained in an array in the 
    index definition.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "address": {
           "type": "document",
           "fields": {
             "city": {
               "type": "string",
               "analyzer": "lucene.simple",
               "ignoreAbove": 255
             },
             "state": {
               "type": "string",
               "analyzer": "lucene.english"
             }
           }
         },
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string", 
           "analyzer": "lucene.standard"
         }
       }
     }
   }

Combined Mapping Example 
~~~~~~~~~~~~~~~~~~~~~~~~

The following index definition example uses both static 
and dynamic mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`. You can change the search analyzer 
  if you want the query term to be parsed differently than how it 
  is stored in your |fts| index.
- The index specifies static field mappings (``dynamic``: 
  ``false``), which means fields that aren't explicitly 
  mentioned aren't indexed. So, the index definition includes:

  - The ``company`` field, which is of type ``string``. It uses 
    the :ref:`lucene.whitespace <ref-whitespace-analyzer>` 
    analyzer by default for queries. It has a ``multi`` analyzer 
    named ``mySecondaryAnalyzer`` which uses the 
    :ref:`lucene.french <ref-language-analyzers>` analyzer by 
    default for queries. To learn more about ``multi`` 
    analyzers, see :ref:`Path Construction <ref-path>`.
  - The ``employees`` field, which  is an array of strings. It 
    uses the :ref:`lucene.standard <ref-keyword-analyzer>` 
    analyzer by default for queries. 
  - The ``address`` field, which is of type ``document``. It has 
    two embedded sub-fields, ``city`` and ``state``. Instead of 
    explicitly mentioning each nested field in the document, the 
    index definition enables dynamic mapping for all the 
    sub-fields in the document. It uses the :ref:`lucene.standard 
    <ref-keyword-analyzer>` analyzer by default for queries.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "address": {
           "type": "document",
           "dynamic": true,
           "analyzer": "lucene.standard"
         }
       }
     }
   }
