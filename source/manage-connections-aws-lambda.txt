==================================
Manage Connections with AWS Lambda
==================================

.. default-domain:: mongodb

.. meta::
   :keywords: lambda connection

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Use the following best practices to properly manage connections
between :aws:`AWS Lambda </lambda/latest/dg/welcome.html>`
and |service|:

- Define the client to the MongoDB server outside
  the :aws:`AWS Lambda handler function </lambda/latest/dg/nodejs-prog-model-handler.html>`.

  Don't define a new MongoClient object each time you invoke your
  function. Doing so causes the driver to create a new database
  connection with each function call. This can be expensive and
  can result in your application exceeding database connection limits.
  As an alternative, do the following:

  1. Create the MongoClient object once.
  2. Store the object so your function can reuse the MongoClient across
     function invocations.

  The :ref:`Connection Example <lambda-aws-example>` reuses existing
  database connections to speed up communication with the database and
  keep connection counts to the database at a reasonable level with
  respect to application traffic.

- If your handler takes a callback as its last argument, set the
  ``callbackWaitsForEmptyEventLoop`` property on the
  :aws:`AWS Lambda Context </lambda/latest/dg/nodejs-context.html#nodejs-prog-model-context-properties>`
  object to **false**.

  .. code-block:: java
      
     context.callbackWaitsForEmptyEventLoop = false;

  This allows a Lambda function to return its result to the caller
  without requiring that the MongoDB database connection be closed.
  Setting this property is not applicable for `async handlers
  <https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html>`__.

- Restrict network access to your |service| cluster.
  
  Connect to your |service| cluster over private networking using a
  :doc:`Network Peering connection </security-vpc-peering>` 
  between your |service| cluster and your |aws| Lambda function, or,
  alternatively, a :doc:`private endpoint </security-private-endpoint/>`,
  so that you can allow only private IP addresses to your
  :doc:`IP access list </security/ip-access-list/>`.

  If private networking is not an option, consider connecting to your
  |service| cluster via a `NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html>`__
  with a mapped Elastic IP address. Otherwise, you must
  allow all IP addresses (0.0.0.0/0) to access your service cluster.

  .. warning:: 

     Adding ``0.0.0.0/0`` to your :doc:`IP access list </security/ip-access-list/>` 
     allows cluster access from anywhere in the public internet. 
     Ensure that you're using strong credentials for all database 
     users when allowing access from anywhere.

- :doc:`/security/set-up-unified-aws-access` and use |aws| IAM authentication where possible.

  You can connect to your |service| {+clusters+} using |aws| `IAM roles <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html>`__
  instead of hardcoding your credentials in Lambda. Hardcoded credentials are
  viewable by anyone who accesses your AWS Lambda environment, which can pose
  a security risk. With |aws| IAM authentication, |service| accesses |aws| Lambda
  through an `assumed IAM role <https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html>`__,
  so you don't need credentials in your connection strings.
  
  |service| supports |aws| IAM authentication for {+clusters+} running
  MongoDB version 4.4 or higher. We strongly advise using |aws| IAM
  authentication for Lambda connections if your {+cluster+} meets the
  requirements.
  
  To use |aws| IAM authentication, :doc:`/security/set-up-unified-aws-access`.
  
  .. note::

     For the connection examples on this page, you can use AWS IAM
     authentication instead of hardcoded credentials by doing the following:

     1. :doc:`/security/set-up-unified-aws-access`
     2. In the :ref:`first Node.js example <lambda-aws-example>`, replace
        ``const { MongoClient } = require('mongodb');`` with the following lines of code:

        .. code-block:: javascript
           :caption: index.js
           :linenos:

           const MONGODB_CONNECTION_STRING = new URL(process.env.MONGODB_URI);
           MONGODB_CONNECTION_STRING.username = process.env.AWS_ACCESS_KEY_ID;
           MONGODB_CONNECTION_STRING.password = encodeURIComponent(process.env.AWS_SECRET_ACCESS_KEY);
           MONGODB_CONNECTION_STRING.searchParams.set('authSource', '$external');
           MONGODB_CONNECTION_STRING.searchParams.set('authMechanism', 'AWS_SESSION_TOKEN:' + encodeURIComponent(process.env.AWS_SESSION_TOKEN));
    
     3. In the :ref:`first Node.js example <lambda-aws-example>`, replace
        ``process.env.MONGODB_URI`` with ``MONGODB_CONNECTION_STRING.toString()``

.. _lambda-aws-example:

Connection Examples
```````````````````

This section includes examples for two approaches:

- In the first Node.js example, the ``index.js`` file shows how to reuse
  ``Mongoclient.connect`` across function invocations.
- In the second Node.js example, the ``index.js`` and
  ``mongodb-client.js`` files show how to isolate the call to
  ``MongoClient.connect`` into its own module so that the connections
  can be reused across functions. Use this approach if you package
  multiple logical functions together in a single Lambda handler function.

The following example shows the best practice of defining the
``MongoClient.connect`` function in your application's Node.js code
outside the handler so it can be reused across function invocations.

.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";

   // Import the dependency.
   const { MongoClient } = require('mongodb');

   // Create a module-scoped MongoClient promise.
   // CRITICAL: You must call connect() outside the handler so that the client
   // can be reused across function invocations.
   let client = new MongoClient(process.env.MONGODB_URI,
       { useNewUrlParser: true, useUnifiedTopology: true });
   const clientPromise = client.connect();

   // Handler
   module.exports.handler = async function(event, context) {

   // Get the MongoClient by calling await on the promise.
   // Because this is a promise, it will only resolve once.
   client = await clientPromise;

   // Use the client to return the name of the connected database.
   return client.db().databaseName;
   }

Some serverless frameworks that run on top of Lambda allow for
multiple logical functions to be packaged together in a single
Lambda handler function. If your application runs multiple functions
within the same Lambda process, we recommend isolating the call to
the ``MongoClient.connect`` function into its own module so that
the connections can be reused across functions.

In the following code examples:

- ``mongo-client.js`` organizes the ``MongoClient.connect`` function
  into its own module (mongo-client).
- ``index.js`` imports that module and uses it to connect.

.. code-block:: javascript
   :caption: mongodb-client.js
   :linenos:

   "use strict";

   // Import the dependency.
   const { MongoClient } = require('mongodb');

   // Export a module-scoped MongoClient promise. By doing this in a separate
   // module, the client can be shared across functions.
   const client = new MongoClient(process.env.MONGODB_URI,
     { useNewUrlParser: true,  useUnifiedTopology: true });
   module.exports = client.connect();



.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";

   // Import the dependency.
   const clientPromise = require('./mongodb-client');

   // Handler
   module.exports.handler = async function(event, context) {

      // Get the MongoClient by calling await on the connection promise. Because
      // this is a promise, it will only resolve once.
      const client = await clientPromise;

      // Use the connection to return the name of the connected database.
      return client.db().databaseName;
   }
