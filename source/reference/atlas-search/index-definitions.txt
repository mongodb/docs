.. _ref-index-definitions:

=================
Index Definitions
=================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

When you configure an |fts| index, you can specify that certain fields
should be indexed with a particular analyzer or with multiple
analyzers. You can also specify that certain fields should be indexed
while others are left unindexed, or you can dynamically index all the
fields in a collection.

.. include:: /includes/atlas-search-out-agg.rst

.. _static-dynamic-mappings:

Static and Dynamic Mappings
---------------------------

Individual field mappings that you configure when you create the index
are called *static mappings*.

Mappings that are automatically assigned when new data is
inserted into a field are called *dynamic mappings*. Dynamic mappings
are useful if you have a dynamic schema and you don't know ahead of
time all the fields that a collection may contain. You can configure
an entire index to use dynamic mappings, or specify individual fields
to be dynamically mapped.

.. note::

   Dynamically mapped indexes occupy more disk space than static
   mappings and may be less performant.

See the :ref:`index configuration example
<index-config-example>`.

.. _default-index-definition:

Defining an Index
-----------------

When you create a new |fts| index, choose a configuration method. 

.. figure:: /images/create-fts-index.png
     :alt: Screenshot of Create an Atlas Search Index modal window
     :figwidth: 650px
     :border:

You can use either the default index defintion or specify a custom
definition for the index. The default index definition will work with 
any collection. If you wish to create a custom index definition, you 
can specify which fields should be indexed with which analyzer and as 
which data type. 

.. include:: /includes/default-fts-index-name.rst

See :ref:`Create an Atlas Search Index <ref-create-index>` for complete 
instructions on creating a new |fts| index.

.. _index-config-example:

Static Mapping Example
~~~~~~~~~~~~~~~~~~~~~~

The following example index definition file uses static mappings.

- The default index analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The default search analyzer is :ref:`lucene.standard
  <ref-standard-analyzer>`.
- The index specifies static field mappings (``dynamic``: false).
- The field ``address`` is of type ``document``. It has two embedded
  sub-fields, ``city`` and ``state``.
- The ``city`` sub-field uses the :ref:`lucene.simple
  <ref-simple-analyzer>` analyzer by default for queries.
  It uses the ``ignoreAbove`` option to ignore any string of
  more than 255 bytes in length.
- The ``state`` sub-field uses the :ref:`lucene.english
  <ref-language-analyzers>` analyzer by default for queries.
- The ``company`` field is of type ``string``. It uses the
  :ref:`lucene.whitespace <ref-whitespace-analyzer>` analyzer by
  default for queries. It has a ``multi`` analyzer named
  ``mySecondaryAnalyzer`` which uses the :ref:`lucene.french
  <ref-language-analyzers>` analyzer by default for queries.

  For more information on ``multi`` analyzers, see :ref:`Path
  construction <ref-path>`.
- The ``employees`` field is an array of strings. It uses the 
  :ref:`lucene.standard <ref-keyword-analyzer>` analyzer by
  default for queries. For indexing arrays, |fts| only requires 
  the data type of the array elements. You don't have to specify 
  that the data is contained in an array in the index definition.
- The ``dynamic`` value is set to ``false``, so any fields which are not
  explicitly mentioned are not indexed.

.. code-block:: json

   {
     "analyzer": "lucene.standard",
     "searchAnalyzer": "lucene.standard",
     "mappings": {
       "dynamic": false,
       "fields": {
         "address": {
           "type": "document",
           "fields": {
             "city": {
               "type": "string",
               "analyzer": "lucene.simple",
               "ignoreAbove": 255
             },
             "state": {
               "type": "string",
               "analyzer": "lucene.english"
             }
           }
         },
         "company": {
           "type": "string",
           "analyzer": "lucene.whitespace",
           "multi": {
             "mySecondaryAnalyzer": {
               "type": "string",
               "analyzer": "lucene.french"
             }
           }
         },
         "employees": {
           "type": "string", 
           "analyzer": "lucene.standard"
         }
       }
     }
   }

Custom Analyzers
~~~~~~~~~~~~~~~~

You can also define a :ref:`custom analyzer <custom-analyzers>` within
an index definition. Custom analyzers allow you to create an |fts| mechanism
tailored to your specific needs.

.. _bson-data-chart:

BSON Data Types
---------------

The table below enumerates all the :manual:`BSON data types
</reference/bson-types/>` and whether they are included in an |fts| index
with :ref:`dynamic mappings <static-dynamic-mappings>`. 

.. list-table::
   :header-rows: 1

   * - BSON Type
     - Dynamic Index?
     - Atlas Search Data Type

   * - Double
     - yes
     - :ref:`number <bson-data-types-number>`

   * - 32-bit integer
     - yes
     - :ref:`number <bson-data-types-number>`

   * - 64-bit integer
     - yes
     - :ref:`number <bson-data-types-number>`

   * - String
     - yes
     - :ref:`string <bson-data-types-string>`
  
   * - Date
     - yes
     - :ref:`date <bson-data-types-date>`

   * - Object
     - yes
     - :ref:`document <bson-data-types-document>`

   * - ObjectId
     - no
     - :ref:`objectId <objectId-ref>`

   * - Boolean
     - no
     - :ref:`boolean <boolean-ref>`

   * - Timestamp
     - no
     - 

   * - Array
     - yes
     - 

   * - Binary Data
     - no
     - 

   * - Null
     - no
     - 

   * - Regular Expression
     - no
     - 

   * - JavaScript
     - no
     - 

   * - Decimal128
     - no
     - 

   * - Min key
     - no
     - 

   * - Max key
     - no
     - 

.. _bson-data-types:

Atlas Search Data Types
-----------------------

.. _bson-data-types-autocomplete:

``autocomplete`` 
~~~~~~~~~~~~~~~~

The ``autocomplete`` type is for indexing text values for autocompletion. The 
indexed fields can only be queried with the :ref:`autocomplete 
<autocomplete-ref>` operator. 

.. note:: 

   The ``autocomplete`` type can't be used to index fields whose value is 
   an array of strings.

The ``autocomplete`` type takes the following options: 

.. list-table::
   :widths: 20 10 50 10 10
   :header-rows: 1

   * - Option
     - Type
     - Purpose
     - Necessity
     - Default

   * - ``type``
     - string 
     - The type of field. Value must be ``autocomplete``.
     - required
     - 

   * - ``maxGrams``
     - int
     - The maximum number of characters per indexed sequence. The 
       value limits the character length of indexed tokens. When you 
       search for terms longer than the ``maxGrams`` value, tokens are 
       truncated to the ``maxGrams`` length.
     - optional
     - ``15``

   * - ``minGrams``
     - int
     - The minimum number of characters per indexed sequence. The 
       recommend minimum value is ``4``. A value that is less 
       than ``4`` could impact performance because the size of the 
       index can become very large. The default value of ``2`` is 
       only recommended for ``edgeGram``.
     - optional
     - ``2``

   * - ``tokenization``
     - enum
     - The tokenization strategy to use when indexing the field for 
       autocompletion. Value can be one of the following: 

       - ``edgeGram`` - to create indexable tokens, referred to as 
         ``grams``, from variable-length character sequences starting at 
         the beginning of the words and delimited by whitespace. 

       - ``nGram`` - to create indexable tokens, referred to as ``grams``, 
         by sliding a variable-length character window over a word. |fts| 
         creates more tokens for ``nGram`` than ``edgeGram`` and because 
         of this, ``nGram`` takes more space and time to index the field. 
         This is better suited for querying languages with long, compound 
         words or languages that don't use spaces.

       For example, consider the following sentence: 
         
       .. code-block:: none
          :copyable: false 

          The quick brown fox jumps over the lazy dog. 

       When tokenized with ``minGrams`` value of ``2`` and ``maxGrams`` 
       value of ``5``, the following sequence of characters are indexed: 
    
       .. tabs:: 

          .. tab:: edgeGram Tokenization Strategy
             :tabid: edgeGram
         
             .. code-block:: none
                :copyable: false 

                Th
                The
                The{SPACE}
                The q 
                qu
                qui
                quic
                quick
                ...

          .. tab:: nGram Tokenization Strategy  
             :tabid: nGram

             .. code-block:: none 
                :copyable: false 

                Th
                The 
                The{SPACE}  
                The q
                he 
                he{SPACE}   
                he q
                he qu
                e{SPACE} 
                e q
                e qu
                e qui
                {SPACE}q
                {SPACE}qu
                {SPACE}qui
                {SPACE}quic
                qu
                qui
                quic
                quick
                ...

       .. note:: 

          Indexing a field for autocomplete with ``edgeGram`` or 
          ``nGram`` tokenization strategy is more computationally  
          expensive and takes more space than indexing a regular 
          string field.

     - optional
     - ``edgeGram``

   * - ``foldDiacritics``
     - boolean
     - The setting to indicate whether diacritics should be 
       included or removed from the indexed text. Value can be 
       one of the following: 

       - ``true`` - to remove diacritic marks 
       - ``false`` - to include diacritic marks 

     - optional
     - ``true``

.. example::

   .. code-block:: json 
      :emphasize-lines: 7-11

      {
        "mappings": {
          "dynamic": true|false,
          "fields": {
            "<field-name>": [
              {
                "type": "autocomplete",
                "tokenization": "edgeGram|nGram",
                "minGrams": <2>,
                "maxGrams": <15>,
                "foldDiacritics": true|false
              }
            ]
          }
        }
      }

.. _boolean-ref:

``boolean``
~~~~~~~~~~~

The ``boolean`` data type is for indexing ``true`` and ``false`` values. It
works in conjunction with the :ref:`equals <equals-ref>` operator.

.. note::

   Fields of type ``boolean`` cannot be dynamically indexed. They must be
   specifically indexed as part of a static mapping.

.. _boolean-objectid-example:

.. example::

   The following example index definition maps a field named ``verified_user``
   with the ``boolean`` data type and field named ``teammates`` with the
   ``objectId`` data type.

   .. code-block:: json

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "verified_user": {
              "type": "boolean"
            },
            "teammates": {
              "type": "objectId"
            }
          }
        }
      }

.. _objectId-ref:

``objectId``
~~~~~~~~~~~~

The ``objectId`` data type is for indexing :manual:`ObjectId
</reference/bson-types/#objectid>` fields. It works in conjunction with the
:ref:`equals <equals-ref>` operator.

.. note::

   Fields of type ``objectId`` cannot be dynamically indexed. They must be
   specifically indexed as part of a static mapping. See the :ref:`example
   <boolean-objectid-example>` in the :ref:`boolean <boolean-ref>` section
   on this page.

.. _bson-data-types-string:

``string``
~~~~~~~~~~

The ``string`` data type takes the following parameters:

.. list-table::
   :widths: 20 10 60 10
   :header-rows: 1

   * - Option
     - Type
     - Purpose
     - Default

   * - ``analyzer``
     - string
     - Name of a built-in or overridden :ref:`analyzer <analyzers-ref>`
       to use for indexing the field.
     - ``lucene.standard``

   * - ``searchAnalyzer``
     - string
     - Analyzer to use when querying the field.
     - ``lucene.standard``

   * - ``indexOptions``
     - string
     - Specifies the amount of information to store for the indexed 
       field. Value can be one of the following:

       - ``docs`` - Only indexes documents. The frequency and position of 
         the indexed term are ignored. Only a single occurence of the 
         term is reflected in the :ref:`score <scoring-ref>`.
       - ``freqs`` - Only indexes documents and term frequency. The position 
         of the indexed term is ignored. 
       - ``positions`` - Indexes documents, term frequency, and term positions. 
       - ``offsets`` - (Default) Indexes documents, term frequency, term 
         positions, and term offsets. This is required for :ref:`highlight-ref`.

     - ``offsets``

   * - ``store``
     - boolean
     - Specifies whether or not to store the exact document text as well as 
       the analyzed values in the index. Value can be ``true`` or ``false``. 
       The value for this must be ``true`` for :ref:`highlight-ref`.
     - ``true``

   * - ``ignoreAbove``
     - int
     - Do not index if the field value is greater than the specified
       number of characters.
     - None

   * - ``multi``
     - string
     - The string field to index with the name of the alternate analyzer 
       specified in the ``multi`` object. 
       
       .. example::
       
          The following index definition for a ``library.books`` collection 
          indexes string values in the field ``text`` with the 
          ``lucene.english`` and ``lucene.french`` analyzers in addition to 
          the default ``lucene.standard`` analyzer:

          .. code-block:: json 
             :copyable: false

             {
               "mappings": {
                 "dynamic": false,
                 "fields": {
                   "text": {
                     "type": "string",
                     "multi": {
                       "english": {
                         "type": "string",
                         "analyzer": "lucene.english"
                       },
                       "french": {
                         "type": "string",
                         "analyzer": "lucene.french"
                       }
                     }
                   }
                 }
               }
             }

     - None

   * - ``norms``
     - string
     - Specifies whether to include or omit the field length in 
       the result when scoring. The length of the field is determined 
       by the number of tokens produced by the analyzer for the field. Value 
       can be one of the following: 
 
       - ``include`` - to include the field length when scoring.
       - ``omit`` - to omit the field length when scoring.
      
       If value is ``include``, |fts| uses the length of the field to determine 
       the higher score when scoring. For example, if two documents match an 
       |fts| query, the document with the shorter field length will score higher 
       than the document with the longer field length.

       If value is ``omit``, |fts| ignores the field length when scoring. 

     - ``include``

.. _bson-data-types-document:

``document``
~~~~~~~~~~~~

The ``document`` data type is for fields with embedded documents.
It takes the following parameters:

.. list-table::
   :widths: 20 10 60 10
   :header-rows: 1

   * - Option
     - Type
     - Purpose
     - Default

   * - ``type``
     - string
     - Must be ``document``.
     - none

   * - ``dynamic``
     - boolean
     - If set to ``true``, |fts| indexes all fields in the collection except:

       - :ref:`geo <bson-data-types-geo>` fields.
       - Any fields explicitly excluded by the ``fields`` parameter.

       If set to ``false``, you must specify individual fields to index.

     - true

   * - ``fields``
     - document
     - Maps document field names to field definitions. See the :ref:`example
       <index-config-example>` on this page.
     - none

.. _bson-data-types-date:

``date``
~~~~~~~~

The ``date`` type is for indexing date values. A  date cannot be 
indexed if it is part of an array. It takes the ``type`` 
option. The value of ``type`` must be ``date``. 

.. _bson-data-types-number:

``number``
~~~~~~~~~~

The ``number`` type is for fields with numeric values of ``int32``, 
``int64``, and ``double`` data types. The ``number`` type has the 
following options: 

.. list-table::
   :widths: 30 60 10
   :header-rows: 1

   * - Option
     - Purpose
     - Default

   * - ``type``
     - The type of field. Value must be ``number``.
     - 

   * - ``representation``
     - The data type of the field to index. Valid values are:

       - ``int64`` - for indexing large integers without loss of precision 
         and for rounding double values to integers. This cannot be used to 
         index large double values.
       - ``double`` - for indexing large double values without rounding.

       .. example::

          The following index definition for the 
          ``sample_analytics.accounts`` collection in the :ref:`sample 
          dataset <available-sample-datasets>` indexes the ``account_id`` 
          field with 64 bit integer values. The following example also 
          indexes all other integer and small double type values in the 
          ``id`` field after rounding any decimal values in the double 
          type before indexing.

          .. code-block:: json
             :copyable: false

             {
                "mappings": {
                    "dynamic": false,
                    "fields": {
                       "account_id": {
                          "type": "number",
                          "representation": "int64"
                       }
                    }
                }
             }

     - ``double``

   * - ``indexIntegers``
     - Index or omit ``int32`` and ``int64`` type values. Value can be 
       ``true`` or ``false``.

       .. example::

          The following index definition for the 
          ``sample_airbnb.listingsAndReviews`` collection in the :ref:`sample 
          dataset <available-sample-datasets>` omits the ``bathrooms`` 
          field with 32 and 64 bit integer values. The following example 
          will index the ``bathrooms`` field with double type values.

          .. code-block:: json 
             :copyable: false

             {
                "mappings": {
                   "dynamic": false,
                   "fields": {
                      "bathrooms": {
                         "type": "number",
                         "indexIntegers": false
                      }
                   }
                }
             }

     - ``true``

   * - ``indexDoubles``
     - Index or omit ``double`` type values. Value can be ``true`` or 
       ``false``.

       .. example::

          The following index definition for the
          ``sample_analytics.accounts`` collection in the 
          :ref:`sample dataset <available-sample-datasets>`:
       
          - Indexes the ``account_id`` field with integer values.
          - Omits the ``account_id`` field with doubles values.

          .. code-block:: json
             :copyable: false

             {
                "mappings": {
                   "dynamic": false,
                   "fields": {
                      "account_id": {
                         "type": "number",
                         "representation": "int64",
                         "indexDoubles": false
                      }
                   }
                }
             }

     - ``true``

.. _bson-data-types-geo:

``geo``
~~~~~~~

The ``geo`` type is for indexing geographic point and shape coordinates. For 
this type, the indexed field must be a :manual:`GeoJSON </reference/geojson/>` 
object.

.. list-table::
   :widths: 30 60 10
   :header-rows: 1

   * - Option
     - Purpose
     - Default

   * - ``type``
     - The type of field. Value must be ``geo``.
     - 

   * - ``indexShapes`` 
     - Specifies whether or not to index shapes. By default: 

       - Shape geometries such as lines and polygons are not indexed.
       - Points are indexed, even when nested.

       Value can be: 

       - ``true`` to index shapes and points 
       - ``false`` to index only points

     - ``false``

.. example:: 

   .. code-block:: json 
      :emphasize-lines: 7-8

      {
        "mappings": {
          "dynamic": false,
          "fields": {
            "type": "document",
            "<field-name>": {
              "indexShapes": true|false
              "type": "geo"
            }
          }
        }
      }

Limitation
----------

|fts| cannot index numeric, date, or boolean values if they are part of 
an array.
