# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2019
# This file is distributed under the same license as the mongodb-manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/tutorial/create-indexes-to-support-queries.txt:5
msgid "Create Indexes to Support Your Queries"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:15
msgid "An index supports a query when the index contains all the fields scanned by the query. The query scans the index and not the collection. Creating indexes that support queries results in greatly increased query performance."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:19
msgid "This document describes strategies for creating indexes that support queries."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:22
msgid "Create a Single-Key Index if All Queries Use the Same, Single Key"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:24
msgid "If you only ever query on a single key in a given collection, then you need to create just one single-key index for that collection. For example, you might create an index on ``category`` in the ``product`` collection:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:35
msgid "Create Compound Indexes to Support Several Different Queries"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:37
msgid "If you sometimes query on only one key and at other times query on that key combined with a second key, then creating a compound index is more efficient than creating a single-key index. MongoDB will use the compound index for both queries. For example, you might create an index on both ``category`` and ``item``."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:47
msgid "This allows you both options. You can query on just ``category``, and you also can query on ``category`` combined with ``item``. A single :ref:`compound index <index-type-compound>` on multiple fields can support all the queries that search a \"prefix\" subset of those fields."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:54
msgid "The following index on a collection:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:60
msgid "Can support queries that the following indexes support:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:67
msgid "There are some situations where the prefix indexes may offer better query performance: for example if ``z`` is a large array."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:70
msgid "The ``{ x: 1, y: 1, z: 1 }`` index can also support many of the same queries as the following index:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:77
msgid "Also, ``{ x: 1, z: 1 }`` has an additional use. Given the following query:"
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:84
msgid "The ``{ x: 1, z: 1 }`` index supports both the query and the sort operation, while the ``{ x: 1, y: 1, z: 1 }`` index only supports the query. For more information on sorting, see :ref:`sorting-with-indexes`."
msgstr ""

#: ../source/includes/fact-index-intersection-vs-compound-indexes.rst:1
msgid "Starting in version 2.6, MongoDB can use :doc:`index intersection </core/index-intersection>` to fulfill queries. The choice between creating compound indexes that support your queries or relying on index intersection depends on the specifics of your system. See :ref:`index-intersection-compound-indexes` for more details."
msgstr ""

#: ../source/tutorial/create-indexes-to-support-queries.txt:92
msgid "Index Use and Collation"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:1
msgid "To use an index for string comparisons, an operation must also specify the same collation. That is, an index with a collation cannot support an operation that performs string comparisons on the indexed fields if the operation specifies a different collation."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:6
msgid "For example, the collection ``myColl`` has an index on a string field ``category`` with the collation locale ``\"fr\"``."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:13
msgid "The following query operation, which specifies the same collation as the index, can use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:20
msgid "However, the following query operation, which by default uses the \"simple\" binary collator, cannot use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:27
msgid "For a compound index where the index prefix keys are not strings, arrays, and embedded documents, an operation that specifies a different collation can still use the index to support comparisons on the index prefix keys."
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:32
msgid "For example, the collection ``myColl`` has a compound index on the numeric fields ``score`` and ``price`` and the string field ``category``; the index is created with the  collation locale ``\"fr\"`` for string comparisons:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:43
msgid "The following operations, which use ``\"simple\"`` binary collation for string comparisons, can use the index:"
msgstr ""

#: ../source/includes/extracts/collation-index-use.rst:51
msgid "The following operation, which uses ``\"simple\"`` binary collation for string comparisons on the indexed ``category`` field, can use the index to fulfill only the ``score: 5`` portion of the query:"
msgstr ""

