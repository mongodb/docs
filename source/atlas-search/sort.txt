.. _sort-ref:

==================
Sort |fts| Results 
==================

.. default-domain:: mongodb

.. meta::
   :description: Sort you Atlas Search results by date, number, and string fields.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol
   
Overview
--------

|fts| allows you to sort the results in ascending or descending order on 
fields that you define in your |fts| index. You can sort by date, number
(integer, float, and double values), and string fields indexed as a 
:ref:`token <bson-data-types-token>` type using the ``sort`` option. You
can also sort by the score of the documents in the results. 

.. note:: 

   |fts| :ref:`sort <sort-ref>` option is available in sharded
   {+clusters+} only if you run MongoDB v6.0+.

Usage 
~~~~~

To sort your |fts| results, you must do the following:

1. Create an |fts| index on the fields to sort the results by. 
   
   |fts| automatically indexes number and date fields in all indexes
   created after :ref:`July 2023 <fts20230710>` for sorting. For
   preexisting indexes, you must trigger an index rebuild from the
   {+atlas-ui+} to use any date and number fields in the indexes for
   sorting. To learn more, see :ref:`sort-index-rebuild`.

   For string fields, you must manually index the field as ``token``
   type. To learn more, see :ref:`bson-data-types-token`. 

#. Create and run your query with the ``sort`` option against the fields
   you defined in the index for sorting. To learn more, see 
   :ref:`sort-syntax-ref`.

Behavior 
~~~~~~~~

Sort by Date, Numeric, or String Field 
``````````````````````````````````````

The ``sort`` option takes a document that specifies the fields to sort 
by and the respective sort order. |fts| follows the :manual:`MongoDB
comparison order </reference/bson-type-comparison-order/>` for the
supported data types. It treats null and missing values as equivalent in
its sort order. To learn more, see :manual:`non-existent fields
</reference/bson-type-comparison-order/#non-existent-fields>`. 

You can specify the following sort order to sort your results by: 

.. list-table:: 
   :widths: 10 90 

   * - ``1`` 
     - Sort in ascending order. 
  
       When you sort in ascending order, |fts| returns documents with
       missing values before documents with values. 

   * - ``-1`` 
     - Sort in descending order.

Sort by Score And Date or Numeric Field 
```````````````````````````````````````

You can also sort by score in ascending or descending order. The
``sort`` option takes a document that specifies the :manual:`$meta
</reference/operator/aggregation/meta/>` expression, which requires the
``searchScore`` value. 

.. example:: 

   Suppose your application allows users to skip to the last page of the
   search results. The following example sorts the results by score in
   ascending order so that the document with the lowest score displays at
   the top of the results: 

   .. code-block:: json 
      :copyable: true 

      sort: {unused: {$meta: "searchScore", order: 1}}

You can use ``sort`` to also ensure that the results have a determined
order when multiple documents in the results have identical scores. The
following example doesn't sort the results by a unique field.   

If you don't specify a unique date or numeric field to sort the results
by, |fts| defaults to sorting the results by score in descending order
and returns results with identical scores in an arbitrary order:  

.. example:: 

   .. code-block:: shell 
      :copyable: false 

      sort: {unused: {$meta: "searchScore"}}

However, if you sort the results by a unique date or numeric field, such
as a date field named ``lastUpdated`` as shown in the following example,
|fts| uses the value of the specified field to return results with
identical scores in a determined order:  

.. example::

   .. code-block:: 
      :copyable: false

      sort: {unused: {$meta: "searchScore"}, lastUpdated: 1}

To learn more, see :ref:`scoring-ref`.

Sort Arrays 
```````````

|fts| flattens the arrays for sorting. 

.. example:: 

   Consider the following array: 

   .. code-block:: shell 
      :copyable: false 

      [4, [1, [8,5], 9], 2]

   |fts| flattens the preceding array similar to the following:

   .. code-block:: shell 
      :copyable: false 

      4, 1, 8, 5, 9, 2

   For an ascending sort, |fts| uses ``1`` to compare the array to other
   values. For a descending sort, |fts| uses ``9`` to compare the array
   to other values.

When comparing with elements inside an array:

- For an ascending sort, |fts| compares the smallest elements of the
  array or performs a less than (``<``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in ascending order:

     .. code-block:: shell 
        :copyable: false 

        -20
        [-3, 12] // <- -3 comes before 5.
        5
        [6, 18]  // <- 6 comes after 5.
        13
        14

- For a descending sort, |fts| compares the largest elements of the
  array or performs a greater than (``>``) comparison. 

  .. example:: 

     |fts| sorts results in the following order if you sort by numbers
     in descending order:

     .. code-block:: shell 
        :copyable: false 

        [6, 18]  // <- 18 comes before 14.
        14
        13
        [-3, 12] // <- 12 comes after 13.
        5
        -20

.. _sort-considerations:

Considerations 
~~~~~~~~~~~~~~

Consistency 
```````````

|fts| indexes are eventually :ref:`consistent
<index-eventual-consistency-and-latency>`, and values returned in
results might be different from values used in sorting.

Performance 
```````````

This feature optimizes queries that use :pipeline:`$search` with
:pipeline:`$limit` as a subsequent stage. If |fts| needs to sort all 
documents in the collection, the response might be slow.

Scoring 
```````

|fts| returns :ref:`scores <scoring-ref>` for all documents in the
results. However, you might see higher scoring documents after lower
scoring documents because the order of documents in the results is based
on the sort criteria unless you explicitly sort by score.

Limitations 
~~~~~~~~~~~

- You can't sort on fields of :ref:`embeddedDocuments
  <bson-data-types-embedded-documents>` type.
- You can't use the ``sort`` option with the :ref:`knn-beta-ref`
  operator. 

.. _sort-compatibility-ref:

Compatibility 
~~~~~~~~~~~~~

|service| supports non-sharded sort queries across all major and minor
release versions of MongoDB. Sharded sort queries are available on
major release version 6.0 and all major and minor release versions 7.0
and later. If you use ``sort``  on sharded |service| {+clusters+}
running MongoDB v5.0 and earlier, |fts| returns an error.

.. _sort-syntax-ref:

Syntax 
------

``sort`` has the following syntax:

.. code-block:: json
   :emphasize-lines: 7-11
   :linenos:

   {
     "$search": {  
       "index": "<index name>", // optional, defaults to "default"
       "<operator>": { // such as "text", "compound", or "phrase"
         <operator-specification>
       },
       "sort": { 
         unused: {$meta: "searchScore"},
         "<field-to-sort>": <sort-order>, 
         ...
       } 
     }
   }

.. _sort-index-rebuild:

Rebuild Index for Sorting  
-------------------------

|fts| automatically indexes fields of type date and number for indexes
created after :ref:`July 2023 <fts20230710>` for sorting. For
preexisting indexes, you must rebuild the indexes to use the date and
number fields in the indexes for sorting the |fts| results. To rebuild
the index, do the following:

.. note:: 

   |fts| index rebuild operation is both time and resource
   intensive. You must allocate free disk space equal to 125% of
   the disk space used by your old index for this operation. 

.. procedure:: 

   .. step:: Log in to |service| and navigate to the :guilabel:`Search` page.

      To navigate to the |fts| page:

      a. Click :guilabel:`Search` from the :guilabel:`Services` menu in
         the navigation bar. 
      
      #. Select the {+cluster+} from the :guilabel:`Select data source`
         dropdown and click :guilabel:`Go to Atlas Search`.

   .. step:: Click the name of the index that you want to rebuild. 

       The {+atlas-ui+} shows a warning icon next to the name of the
       indexes that you can upgrade to avail of the sort functionality.

   .. step:: Update your index to use the new capability for date and numeric fields. 
    
      To update your index: 
      
      a. In the :guilabel:`Index Overview` page, click :guilabel:`Update` in the banner.
      #. Click :guilabel:`Update Index` in the confirmation window. 

         While your index is rebuilding, you can continue to query your
         collection using your previous index.

Examples 
--------

The following examples use the ``sample_mflix.movies`` collection in the
:ref:`sample data <sample-data>`. 

Index Definition
~~~~~~~~~~~~~~~~

The example queries in this section use the following index. The index
definition for the collection specifies the following: 

- Index ``awards.wins`` field as: 

  - ``number`` type for sorting and querying
  - ``numberFacet`` type for running :ref:`fts-facet-ref` queries

- Index ``released`` field as: 

  - ``date`` type for sorting and querying
  - ``dateFacet`` type for running :ref:`fts-facet-ref` queries

- Index ``title`` field as: 

  - ``token`` type for sorting 
  - ``string`` type for querying  

.. code-block:: json
   :copyable: true 
   :linenos:

   {
     "mappings": {
       "dynamic": false,
       "fields": {
         "awards": {
           "dynamic": false,
           "fields": {
             "wins": [
               {
                 "type": "number"
               },
               {
                 "type": "numberFacet"
               }
             ]
           },
           "type": "document"
         },
         "released": [
           {
             "type": "date"
           },
           {
             "type": "dateFacet"
           }
         ],
         "title": [{
           "type": "token"
         }, {
           "type": "string"
         }]
       }
     }
   }

For the preceding index definition, |fts| creates an index named
``default`` with :ref:`static mappings <static-dynamic-mappings>` on the
specified fields. 

Date Search and Sort 
~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``released`` in the results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "range": {
              "path": "released",
              "gt": ISODate("2010-01-01T00:00:00.000Z"),
              "lt": ISODate("2015-01-01T00:00:00.000Z")
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          title: 'The Gambler',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'Cold in July',
          released: ISODate("2014-12-31T00:00:00.000Z")
        },
        {
          title: 'Force Majeure',
          released: ISODate("2014-12-30T00:00:00.000Z")
        },
        { 
          title: 'LFO', 
          released: ISODate("2014-12-27T00:00:00.000Z") 
        },
        {
          title: 'The Water Diviner',
          released: ISODate("2014-12-26T00:00:00.000Z")
        }
      ]

Number Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have won awards.  
- Sort the results in descending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to omit all fields
except ``title`` and ``awards.wins`` in the results.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
             "range": {
               "path": "awards.wins",
               "gt": 3
            },
            "sort": {
              "awards.wins": -1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "awards.wins": 1
          }
        }
      ])

   .. output::
      :language: json

      [
        { title: '12 Years a Slave', awards: { wins: 267 } },
        { title: 'Gravity', awards: { wins: 231 } },
        { title: 'Gravity', awards: { wins: 231 } },
        {
          title: 'Birdman: Or (The Unexpected Virtue of Ignorance)',
          awards: { wins: 210 }
        },
        { title: 'Boyhood', awards: { wins: 185 } },
      ]

String Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``country`` in the title.  
- Sort the results in ascending order using ``sort`` option. 

The query uses the :pipeline:`$limit` stage to limit the output to ``5``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title`` in the results.
- Add a field named ``score``.

.. io-code-block::
   :copyable: true 

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "text": {
              "path": "title",
              "query": "country"
            },
            "sort": {
              "title": 1
            }
          }
        },
        {
          "$limit": 5
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json

      [
        { title: 'A Country Called Home', score: 2.536633253097534 },
        { title: 'A Month in the Country', score: 2.258953094482422 },
        { title: 'A Quiet Place in the Country', score: 2.0360684394836426 },
        { title: 'A Sunday in the Country', score: 2.258953094482422 },
        { title: 'Another Country', score: 3.3635599613189697 }
      ]

Compound Search and Sort 
~~~~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies that have the term ``dance`` in the title, with
  a preference for movies that have won 2 or more awards and were
  released after 01 January, 1990.  
- Sort the results by the number of awards in descending order, then by
  the movie title in ascending order, and then by the release date in
  descending order. 

The query uses the :pipeline:`$limit` stage to limit the output to ``10``
documents. It also uses the :pipeline:`$project` stage to do the
following: 

- Omit all fields except ``title``, ``released``, and ``awards.wins`` in
  the results. 
- Add a field named ``score``.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "compound": {
              "must": [{
                "text": {
                  "path": "title",
                  "query": "dance"
                }
              }],
              "should": [{
                "range": {
                  "path": "awards.wins",
                  "gte": 2
                }
              }, {
                "range": {
                  "path": "released",
                  "gte": ISODate("1990-01-01T00:00:00.000Z")
                }
              }]
            },
            "sort": {
              "awards.wins": -1, 
              "title": 1, 
              "released": -1
            }
          }
        },
        {
          "$limit": 10
        },
        {
          "$project": {
            "_id": 0,
            "title": 1,
            "released": 1,
            "awards.wins": 1,
            "score": { "$meta": "searchScore" }
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'Shall We Dance?',
          released: ISODate("1997-07-11T00:00:00.000Z"),
          awards: { wins: 57 },
          score: 4.9811458587646484
        },
        {
          title: 'War Dance',
          released: ISODate("2008-11-01T00:00:00.000Z"),
          awards: { wins: 11 },
          score: 5.466421127319336
        },
        {
          title: 'Dance with the Devil',
          released: ISODate("1997-10-31T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Save the Last Dance',
          released: ISODate("2001-01-12T00:00:00.000Z"),
          awards: { wins: 6 },
          score: 4.615056037902832
        },
        {
          title: 'Dance with a Stranger',
          released: ISODate("1985-08-09T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 3.615056037902832
        },
        {
          title: 'The Baby Dance',
          released: ISODate("1998-08-23T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: 'Three-Step Dance',
          released: ISODate("2004-02-19T00:00:00.000Z"),
          awards: { wins: 4 },
          score: 4.981145858764648
        },
        {
          title: "Cats Don't Dance",
          released: ISODate("1997-03-26T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        },
        {
          title: 'Dance Me Outside',
          released: ISODate("1995-03-10T00:00:00.000Z"),
          awards: { wins: 3 },
          score: 4.981145858764648
        }
      ]

Facet Search and Sort 
~~~~~~~~~~~~~~~~~~~~~

The following query uses the :pipeline:`$search` stage to do the
following: 

- Search for movies released between 01 January, 2010 and 01, January,
  2015 using the :ref:`range-ref` operator. 
- Get a count of the number of movies that won ``1``, ``5``, ``10``, and
  ``15`` awards.
- Get a count of the number of movies released on ``2010-01-01``,
  ``2011-01-01``, ``2012-01-01``, ``2013-01-01``, ``2014-01-01``, and
  ``2015-01-01``.
- Sort the results in descending order of released date using the 
  ``sort`` option. 

The query uses the :pipeline:`$limit` stage to do the following: 

- Limit the output to ``5`` documents in the ``docs`` output field. 
- Limit the output to ``1`` document in the ``meta`` output field. 

It uses the :pipeline:`$project` stage to omit all fields except the
``awards.wins``, ``released``, and ``title`` fields.

It also uses the :pipeline:`$replaceWith` stage to include the metadata
results stored in the ``$$SEARCH_META`` variable in the ``meta`` output
field and the :pipeline:`$set` stage to add the ``meta`` field to the
results.

.. io-code-block:: 
   :copyable: true

   .. input:: 
      :language: json 

      db.movies.aggregate([
        {
          "$search": {
            "facet": {
              "operator": {
                "range": {
                  "path": "released",
                  "gt": ISODate("2010-01-01T00:00:00.000Z"),
                  "lt": ISODate("2015-01-01T00:00:00.000Z")
                }
              },
              "facets": {
                "awardsFacet": {
                  "type": "number",
                  "path": "awards.wins",
                  "boundaries" : [1,5,10,15]
                },
                "releasedFacet" : {
                  "type" : "date",
                  "path" : "released",
                  "boundaries" : [ISODate("2010-01-01T00:00:00.000Z"), ISODate("2011-01-01T00:00:00.000Z"), ISODate("2012-01-01T00:00:00.000Z"), ISODate("2013-01-01T00:00:00.000Z"), ISODate("2014-01-01T00:00:00.000Z"), ISODate("2015-01-01T00:00:00.000Z")]
                }
              }
            },
            "sort": {
              "released": -1
            }
          }
        },
        {
          "$facet": {
            "docs": [
              { "$limit": 5 },
              { "$project":
                {
                  "_id": 0,
                  "title": 1,
                  "released": 1,
                  "awards.wins": 1
                }
              }
            ],
            "meta": [
              {"$replaceWith": "$$SEARCH_META"},
              {"$limit": 1}
            ]
          }
        },
        {
          "$set": {
            "meta": {
              "$arrayElemAt": ["$meta", 0]
            }
          }
        }
      ])

   .. output::
      :language: json

      [
        {
          docs: [
            {
              title: 'The Gambler',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 7 }
            },
            {
              title: 'Cold in July',
              released: ISODate("2014-12-31T00:00:00.000Z"),
              awards: { wins: 1 }
            },
            {
              title: 'Force Majeure',
              released: ISODate("2014-12-30T00:00:00.000Z"),
              awards: { wins: 31 }
            },
            {
              title: 'LFO',
              released: ISODate("2014-12-27T00:00:00.000Z"),
              awards: { wins: 3 }
            },
            {
              title: 'The Water Diviner',
              released: ISODate("2014-12-26T00:00:00.000Z"),
              awards: { wins: 8 }
            }
          ],
          meta: {
            count: { lowerBound: Long("4821") },
              facet: {
                releasedFacet: {
                  buckets: [
                    {
                      _id: ISODate("2010-01-01T00:00:00.000Z"),
                      count: Long("857")
                    },
                    {
                      _id: ISODate("2011-01-01T00:00:00.000Z"),
                      count: Long("909")
                    },
                    {
                      _id: ISODate("2012-01-01T00:00:00.000Z"),
                      count: Long("903")
                    },
                    {
                      _id: ISODate("2013-01-01T00:00:00.000Z"),
                      count: Long("1063")
                    },
                    {
                      _id: ISODate("2014-01-01T00:00:00.000Z"),
                      count: Long("1089")
                    }
                  ]
                },
                awardsFacet: {
                  buckets: [
                    { _id: 1, count: Long("2330") },
                    { _id: 5, count: Long("604") },
                    { _id: 10, count: Long("233") }
                  ]
                }
              }
            }
          }
        }
      ]

.. _sort-by-score-egs:

Sort by Score
~~~~~~~~~~~~~

The following examples demonstrate how to sort the results by the score
of the documents in the results. The examples demonstrate how to perform
the following actions: 

- Retrieve the lowest scoring documents first by sorting the results in
  ascending order.
- Sort the results by score in descending order and for results with
  identical scores, sort arbitrarily. 
- Sort the results by score and for results with identical scores, sort
  using a unique field. 

.. tabs:: 

   .. tab:: Ascending Sort 
      :tabid: ascending-sort

      The following query uses the :pipeline:`$search` stage to perform
      the following actions: 

      - Search for movies that have the term ``story`` in the title.  
      - Sort the results by score in ascending order. 

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``title`` in the results.
      - Add a field named ``score``.

      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "story"
                  },
                  "sort": {unused: {$meta: "searchScore", order: 1}}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 0,
                  "title": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json
            :emphasize-lines: 12-21

            [
              {
                title: 'Do You Believe in Miracles? The Story of the 1980 U.S. Hockey Team',
                score: 0.8674521446228027
              },
              {
                title: 'Once in a Lifetime: The Extraordinary Story of the New York Cosmos',
                score: 0.9212141036987305
              },
              {
                title: 'The Source: The Story of the Beats and the Beat Generation',
                score: 0.9820802211761475
              },
              {
                title: 'If These Knishes Could Talk: The Story of the NY Accent',
                score: 0.9820802211761475
              },
              {
                title: 'Dream Deceivers: The Story Behind James Vance vs. Judas Priest',
                score: 1.051558256149292
              }
            ]

   .. tab:: Default (Descending) Sort 
      :tabid: descending-sort

      The following query uses the :pipeline:`$search` stage to perform
      the following actions: 

      - Search for movies that have the term ``summer`` in the title.  
      - Sort the results by score in descending order and for results
        with identical scores, sort arbitrarily. 

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``_id`` and ``title`` in the results.
      - Add a field named ``score``.

      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "summer"
                  },
                  "sort": {unused: {$meta: "searchScore"}}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 1,
                  "title": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json

            [
              {
                _id: ObjectId("573a1398f29313caabcea21e"),
                title: 'Summer',
                score: 3.5844719409942627
              },
              {
                _id: ObjectId("573a13a6f29313caabd18eca"),
                title: 'Summer Things',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a13b8f29313caabd4c1d0"),
                title: 'Summer Palace',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a1394f29313caabcde8e8"),
                title: 'Summer Stock',
                score: 3.000213623046875
              },
              {
                _id: ObjectId("573a13acf29313caabd284fa"),
                title: 'Wolf Summer',
                score: 3.000213623046875
              }
            ]

   .. tab:: Sort by Unique Field
      :tabid: unique-field-sort

      The following query uses the :pipeline:`$search` stage to perform the
      following actions: 

      - Search for movies that have the term ``prince`` in the title.  
      - Sort the results first by score and then by the value of the
        ``released`` field in ascending order for results with identical
        scores.  

      The query uses the :pipeline:`$limit` stage to limit the output to ``5``
      documents. It also uses the :pipeline:`$project` stage to perform the
      following actions: 

      - Omit all fields except ``title`` and ``released`` in the results.
      - Add a field named ``score``.
 
      .. io-code-block::
         :copyable: true 

         .. input:: 
            :language: json 
            :emphasize-lines: 8

            db.movies.aggregate([
              {
                "$search": {
                  "text": {
                    "path": "title",
                    "query": "prince"
                  },
                  "sort": {unused: {$meta: "searchScore"}, "released": 1}
                }
              },
              {
                "$limit": 5
              },
              {
                "$project": {
                  "_id": 0,
                  "title": 1,
                  "released": 1,
                  "score": {$meta: "searchScore"}
                }
              }
            ])

         .. output::
            :language: json

            [
              {
                title: 'Prince',
                released: ISODate("2015-08-14T00:00:00.000Z"),
                score: 4.168826103210449
              },
              {
                title: 'Prince Avalanche',
                released: ISODate("2013-09-19T00:00:00.000Z"),
                score: 3.4893198013305664
              },
              {
                title: 'The Prince',
                released: ISODate("2014-08-22T00:00:00.000Z"),
                score: 3.4893198013305664
              },
              {
                title: 'Prince of Foxes',
                released: ISODate("1949-12-23T00:00:00.000Z"),
                score: 3.0002830028533936
             },
              {
                title: 'The Oil Prince',
                released: ISODate("1966-01-01T00:00:00.000Z"),
                score: 3.0002830028533936
              }
            ]
