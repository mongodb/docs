======================
db.collection.update()
======================

.. default-domain:: mongodb

.. role:: red(strong)
   :class: text-danger

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. method:: db.collection.update(query, update, options)

   .. include:: /includes/fact-mongo-shell-method.rst

   Modifies an existing document or documents in a collection. The
   method can modify specific fields of an existing document or documents
   or replace an existing document entirely, depending on the
   :ref:`update parameter <update-parameter>`.

   By default, the :method:`db.collection.update()` method updates a
   **single** document. Include the option :ref:`multi: true <multi-parameter>`
   to update all documents that match the query criteria.

Syntax
------

The :method:`db.collection.update()` method has the following form:

.. code-block:: javascript

   db.collection.update(
      <query>,
      <update>,
      {
        upsert: <boolean>,
        multi: <boolean>,
        writeConcern: <document>,
        collation: <document>,
        arrayFilters: [ <filterdocument1>, ... ],
        hint:  <document|string>        // Available starting in MongoDB 4.2
      }
   )

Parameters
~~~~~~~~~~

The :method:`db.collection.update()` method takes the following
parameters:

.. list-table::
   :header-rows: 1
   :widths: 20 20 80

   * - Parameter

     - Type

     - Description

   * - :ref:`query <update-query>`

     - document

     - .. _update-query:

       The selection criteria for the update. The same :ref:`query
       selectors <query-selectors>` as in the :method:`find()
       <db.collection.find()>` method are available.

       .. include:: /includes/fact-upsert-id.rst
          :end-before: end-short-description

   * - :ref:`update <update-parameter>`

     - document or pipeline

     - .. _update-parameter:

       The modifications to apply. Can be one of the following:

       .. list-table::
          :widths: 40 80
          :class: border-table

          * - :ref:`Update document <update-method-update-document>`
            - .. _update-method-update-document:

              Contains only :ref:`update operator expressions
              <update-operators>`.

          * - :ref:`Replacement document
              <update-method-replacement-document>`
            - .. _update-method-replacement-document:

              Contains only ``<field1>: <value1>`` pairs.

          * - :ref:`Aggregation pipeline <update-method-agg-pipeline>`
              (*Starting in MongoDB 4.2*)

            - .. _update-method-agg-pipeline:

              Contains only the following aggregation stages:

              .. include:: /includes/list-update-agg-stages.rst

       For details and examples, see :ref:`update-method-examples`.

   * - :ref:`upsert <update-upsert>`

     - boolean

     - .. _update-upsert:

       Optional. If set to ``true``, creates a new document when no
       document matches the query criteria. The default value is
       ``false``, which does *not* insert a new document when no match
       is found.

   * - :ref:`multi <update-multi>`

     - boolean

     - .. _update-multi:

       Optional. If set to ``true``, updates multiple documents that
       meet the ``query`` criteria. If set to ``false``, updates one
       document. The default value is ``false``. For additional
       information, see :ref:`Update Multiple Documents Examples
       <multi-parameter>`.

   * - :ref:`writeConcern <update-wc>`

     - document

     - .. _update-wc:

       Optional. A document expressing the :doc:`write concern
       </reference/write-concern>`. Omit to use the default write
       concern ``w: 1``.

       .. include:: /includes/extracts/transactions-operations-write-concern.rst

       For an example using ``writeConcern``, see
       :ref:`example-update-write-concern`.

   * - :ref:`collation <update-collation>`

     - document

     - .. _update-collation:

       Optional.

       .. include:: /includes/extracts/collation-description.rst

       For an example using ``collation``, see
       :ref:`example-update-collation`.

       .. versionadded:: 3.4

   * - :ref:`arrayFilters <update-array-filters>`

     - array

     - .. _update-array-filters:

       Optional. An array of filter documents that determine which array
       elements to modify for an update operation on an array field.

       In the :ref:`update document <update-parameter>`, use the
       :update:`$[\<identifier\>]` to define an identifier to update
       only those array elements that match the corresponding filter
       document in the ``arrayFilters``.

       .. note::

          You cannot have an array filter document for an identifier if
          the identifier is not included in the update document.

       For examples, see :ref:`update-arrayFilters`.

       .. versionadded:: 3.6

   * - :ref:`hint <update-hint>`

     - Document or string

     - .. _update-hint:

       Optional. A document or string that specifies the :doc:`index
       </indexes>` to use to support the :ref:`query predicate
       <update-query>`.

       The option can take an index specification document or the index
       name string.

       If you specify an index that does not exist, the operation
       errors.

       For an example, see :ref:`ex-update-hint`.

       .. versionadded:: 4.2

Returns
~~~~~~~

The method returns a :ref:`writeresults-update` document that contains
the status of the operation.

Access Control
--------------

On deployments running with :setting:`~security.authorization`, the
user must have access that includes the following privileges:

- :authaction:`update` action on the specified collection(s).

- :authaction:`find` action on the specified collection(s).

- :authaction:`insert` action on the specified collection(s) if the
  operation results in an upsert.

The built-in role :authrole:`readWrite` provides the required
privileges.

.. _update-behavior:

Behavior
--------

.. _update-sharded-collection:

Sharded Collections
~~~~~~~~~~~~~~~~~~~

To use :method:`db.collection.update()` with ``multi: false`` on a
sharded collection, you must include an exact match on the ``_id``
field or target a single shard (such as by including the shard key).

When the :method:`db.collection.update()` performs update operations
(and not document replacement operations),
:method:`db.collection.update()` can target multiple shards.

.. seealso:: :method:`~db.collection.findAndModify()`

Replace Document Operations on a Sharded Collection
```````````````````````````````````````````````````

Starting in MongoDB 4.2, replace document operations attempt to target
a single shard, first by using the query filter. If the operation
cannot target a single shard by the query filter, it then attempts to target
by the replacement document.

In earlier versions, the operation attempts to target using the
replacement document.

.. _method-update-sharded-upsert:

``upsert`` on a Sharded Collection
``````````````````````````````````

For a :method:`db.collection.update()` operation that includes
:ref:`upsert: true <update-upsert>` and is on a sharded collection, you
must include the full shard key in the ``filter``:

- For an update operation.

- For a replace document operation (starting in MongoDB 4.2).

.. include:: /includes/extracts/missing-shard-key-equality-condition-update.rst

.. _method-update-shard-key-modification:

Shard Key Modification
``````````````````````

.. container::

   .. include:: /includes/limits-sharding-shardkey-document-immutable.rst

   To modify the **existing** shard key value with
   :method:`db.collection.update()`:

   - You :red:`must` run on a :binary:`~bin.mongos`. Do :red:`not`
     issue the operation directly on the shard.

   - You :red:`must` run either in a :doc:`transaction
     </core/transactions>` or as a :doc:`retryable write
     </core/retryable-writes>`.

   - You :red:`must` specify ``multi: false``.

   - You :red:`must` include an equality :ref:`query filter
     <update-query>` on the full shard key.

   .. tip::

      .. include:: /includes/extracts/missing-shard-key-equality-condition-abridged.rst

   See also :ref:`method-update-sharded-upsert`.

.. _method-update-missing-shard-key:

Missing Shard Key
`````````````````

.. container::

   Starting in version 4.4, documents in a sharded collection can be
   :ref:`missing the shard key fields <shard-key-missing>`. To use
   :method:`db.collection.update()` to set the document's
   **missing** shard key, you :red:`must` run on a
   :binary:`~bin.mongos`. Do :red:`not` issue the operation directly on
   the shard.

   In addition, the following requirements also apply:

   .. list-table::
      :header-rows: 1
      :widths: 30 70

      * - 

        - Requirements

      * - To set to ``null``

        - - Can specify ``multi: true``.

          - Requires equality filter on the full shard key if ``upsert:
            true``.

      * - To set to a non-``null`` value

        - - :red:`Must` be performed either inside a :doc:`transaction
            </core/transactions>` or as a :doc:`retryable write
            </core/retryable-writes>`.

          - :red:`Must` specify ``multi: false``.

          - Requires equality filter on the full shard key if either:

            - ``upsert: true``, or

            - if using a replacement document and the new shard key
              value belongs to a different shard.

   .. tip::

      .. include:: /includes/extracts/missing-shard-key-equality-condition-abridged.rst

   See also:

   - :ref:`method-update-sharded-upsert`

   - :ref:`shard-key-missing`

Transactions
~~~~~~~~~~~~

.. include:: /includes/extracts/transactions-supported-operation.rst

.. include:: /includes/extracts/transactions-usage.rst


Upsert within Transactions
``````````````````````````

.. include:: /includes/extracts/transactions-upsert-availability.rst


Write Concerns and Transactions
````````````````````````````````

.. include:: /includes/extracts/transactions-operations-write-concern.rst

.. |operation| replace:: :method:`db.collection.update()`

.. _update-method-examples:
.. _update-behavior-operator-expressions-document:
.. _multi-parameter:
.. _example-update-specific-fields:
.. _example-update-replace-fields:
.. _update-behavior-replacement-document:

Examples
--------

.. container::

   .. tabs::

      .. tab:: Use Update Operator Expressions ($inc, $set)
         :tabid: op-expr

         .. include:: /includes/fact-update-example-docs-intro.rst

         .. include:: /includes/fact-update-example-docs.rst

         If the ``<update>`` document contains :ref:`update operator
         <update-operators>` modifiers, such as those using the
         :update:`$set` modifier, then:

         - The ``<update>`` document must contain *only*
           :ref:`update operator <update-operators>` expressions.

         - The :method:`db.collection.update()` method updates only the
           corresponding fields in the document.

           - To update an embedded document or an array as a whole,
             specify the replacement value for the field.

           - To update particular fields in an embedded document or in
             an array, use :ref:`dot notation <document-dot-notation>`
             to specify the field.

         .. only:: website

            You can use the web shell below to insert the sample
            documents and execute the example update operation:

            .. include:: /includes/fact-mws.rst

         .. code-block:: javascript

            db.books.update(
               { _id: 1 },
               {
                 $inc: { stock: 5 },
                 $set: {
                   item: "ABC123",
                   "info.publisher": "2222",
                   tags: [ "software" ],
                   "ratings.1": { by: "xyz", rating: 3 }
                 }
               }
            )

         In this operation:

         - The ``<query>`` parameter of ``{ _id: 1 }`` specifies which
           document to update,

         - the :update:`$inc` operator increments the ``stock`` field,
           and

         - the :update:`$set` operator replaces the value of the

           - ``item`` field,
           - ``publisher`` field in the ``info`` embedded document,
           - ``tags`` field, and
           - second element in the ``ratings`` array.

         The updated document is the following:

         .. code-block:: javascript
            :emphasize-lines: 2,4-6

            {
              "_id" : 1,
              "item" : "ABC123",
              "stock" : 5,
              "info" : { "publisher" : "2222", "pages" : 430 },
              "tags" : [ "software" ],
              "ratings" : [ { "by" : "ijk", "rating" : 4 }, { "by" : "xyz", "rating" : 3 } ],
              "reorder" : false
            }

         This operation corresponds to the following SQL statement:

         .. code-block:: sql

             UPDATE books
             SET    stock = stock + 5
                    item = "ABC123"
                    publisher = 2222
                    pages = 430
                    tags = "software"
                    rating_authors = "ijk,xyz"
                    rating_values = "4,3"
             WHERE  _id = 1

         .. note::

            If the ``query`` parameter had matched multiple documents,
            this operation would only update one matching document. To
            update multiple documents, you must set the ``multi`` option
            to ``true``.

         .. seealso:: :update:`$set`, :update:`$inc`,
            :doc:`/reference/operator/update`,
            :ref:`dot notation <document-dot-notation>`

      .. tab:: Push Elements to Existing Array
         :tabid: push-elements-existing-array

         .. include:: /includes/fact-update-example-docs-intro.rst

         .. include:: /includes/fact-update-example-docs.rst

         The following operation uses the :update:`$push` update
         operator to append a new object to the ``ratings`` array.

         .. only:: website

            You can use the web shell below to insert the sample
            documents and execute the example update operation:

            .. include:: /includes/fact-mws.rst

         .. code-block:: javascript

            db.books.update(
               { _id: 2 },
               {
                 $push: { ratings: { "by" : "jkl", "rating" : 2 } }
               }
            )

         The updated document is the following:

         .. code-block:: javascript
            :emphasize-lines: 12

            {
              "_id" : 2,
              "item" : "XYZ123",
              "stock" : 15,
              "info" : {
               "publisher" : "5555",
               "pages" : 150
              },
              "tags" : [ ],
              "ratings" : [
               { "by" : "xyz", "rating" : 5 },
               { "by" : "jkl", "rating" : 2 }
              ],
              "reorder" : false
             }

         .. seealso::

            :update:`$push`

      .. tab:: Remove Fields ($unset)
         :tabid: remove-fields

         .. include:: /includes/fact-update-example-docs-intro.rst

         .. include:: /includes/fact-update-example-docs.rst

         The following operation uses the :update:`$unset` operator to remove
         the ``tags`` field from the document with ``{ _id: 1 }``.

         .. only:: website

            You can use the web shell below to insert the sample
            documents and execute the example update operation:

            .. include:: /includes/fact-mws.rst

         .. code-block:: javascript

            db.books.update( { _id: 1 }, { $unset: { tags: 1 } } )

         The updated document is the following:

         .. code-block:: javascript

            {
              "_id" : 1,
              "item" : "TBD",
              "stock" : 0,
              "info" : {
               "publisher" : "1111",
               "pages" : 430
              },
              "ratings" : [ { "by" : "ijk", "rating" : 4 }, { "by" : "lmn", "rating" : 5 } ],
              "reorder" : false
             }

         There is not a direct SQL equivalent to :update:`$unset`,
         however :update:`$unset` is similar to the following SQL
         command which removes the ``tags`` field from the ``books``
         table:

         .. code-block:: sql

            ALTER TABLE books
            DROP COLUMN tags

         .. seealso:: :update:`$unset`, :update:`$rename`, :doc:`/reference/operator/update`

      .. tab:: Replace Entire Document
         :tabid: replace-doc

         .. include:: /includes/fact-update-example-docs-intro.rst

         .. include:: /includes/fact-update-example-docs.rst

         If the ``<update>`` document contains *only* ``field:value``
         expressions, then:

         - The :method:`db.collection.update()` method *replaces* the matching
           document with the ``<update>`` document. The
           :method:`db.collection.update()` method *does not* replace the
           ``_id`` value.

         - :method:`db.collection.update()` *cannot* update multiple
           documents.

         The following operation passes an ``<update>`` document that contains
         only field and value pairs. The ``<update>`` document completely
         replaces the original document except for the ``_id`` field.

         .. only:: website

            You can use the web shell below to insert the sample
            documents and execute the example update operation:

            .. include:: /includes/fact-mws.rst

         .. code-block:: javascript

            db.books.update(
               { _id: 2 },
               {
                 item: "XYZ123",
                 stock: 10,
                 info: { publisher: "2255", pages: 150 },
                 tags: [ "baking", "cooking" ]
               }
            )

         The updated document contains *only* the fields from the
         replacement document and the ``_id`` field. As such, the fields
         ``ratings`` and ``reorder`` no longer exist in the updated
         document since the fields were not in the replacement document.

         .. code-block:: javascript

            {
               "_id" : 2,
               "item" : "XYZ123",
               "stock" : 10,
               "info" : { "publisher" : "2255", "pages" : 150 },
               "tags" : [ "baking", "cooking" ]
            }

         This operation corresponds to the following SQL statements:

         .. code-block:: sql

            DELETE from books WHERE _id = 2

            INSERT INTO books
                        (_id,
                         item,
                         stock,
                         publisher,
                         pages,
                         tags)
            VALUES     (2,
                        "xyz123",
                        10,
                        "2255",
                        150,
                        "baking,cooking")

      .. tab:: Update Multiple Documents
         :tabid: update-multiple

         .. include:: /includes/fact-update-example-docs-intro.rst

         .. include:: /includes/fact-update-example-docs.rst

         If ``multi`` is set to ``true``, the
         :method:`db.collection.update()` method updates *all* documents
         that meet the ``<query>`` criteria. The ``multi`` update
         operation may interleave with other read/write operations.

         The following operation sets the ``reorder`` field to ``true``
         for all documents where ``stock`` is less than or equal to
         ``10``. If the ``reorder`` field does not exist in the matching
         document(s), the :update:`$set` operator adds the field
         with the specified value.

         .. only:: website

            You can use the web shell below to insert the sample
            documents and execute the example update operation:

            .. include:: /includes/fact-mws.rst

         .. code-block:: javascript

            db.books.update(
               { stock: { $lte: 10 } },
               { $set: { reorder: true } },
               { multi: true }
            )

         The resulting documents in the collection are the following:

         .. code-block:: javascript
            :emphasize-lines: 11,19

            [
              {
                "_id" : 1,
                "item" : "ABC123",
                "stock" : 5,
                "info" : {
                 "publisher" : "2222",
                 "pages" : 430
                },
                "ratings" : [ { "by" : "ijk", "rating" : 4 }, { "by" : "xyz", "rating" : 3 } ],
                "reorder" : true
               }
               {
                 "_id" : 2,
                 "item" : "XYZ123",
                 "stock" : 10,
                 "info" : { "publisher" : "2255", "pages" : 150 },
                 "tags" : [ "baking", "cooking" ],
                 "reorder" : true
               }
            ]

         This operation corresponds to the following SQL statement:

         .. code-block:: sql

            UPDATE books
            SET reorder=true
            WHERE stock <= 10

         .. note::

            You cannot specify ``multi: true`` when performing a
            replacement, i.e., when the :ref:`\<update\>
            <update-parameter>` document contains *only*
            ``field:value`` expressions.

         .. seealso::

            :update:`$set`

.. _example-update-upsert:
.. _upsert-parameter:
.. _upsert-behavior:

Insert a New Document if No Match Exists (``Upsert``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you specify the option :ref:`upsert: true <update-upsert>`:

- If document(s) match the query criteria,
  :method:`db.collection.update()` performs an update.

- If no document matches the query criteria,
  :method:`db.collection.update()` inserts a *single* document.

If you specify ``upsert: true`` on a sharded collection, you must
include the full shard key in the ``filter``. For additional
:method:`db.collection.update()` behavior on a sharded collection, see
:ref:`update-sharded-collection`.

.. container::

   .. tabs::

      .. tab:: Upsert with Replacement Document
         :tabid: upsert-example

         If no document matches the query criteria and the ``<update>``
         parameter is a replacement document (i.e., contains only field
         and value pairs), the update inserts a new document with the
         fields and values of the replacement document.

         - If you specify an ``_id`` field in either the query parameter
           or replacement document, MongoDB uses that ``_id`` field in the
           inserted document.

         - If you do not specify an ``_id`` field in either the query
           parameter or replacement document, MongoDB generates adds the
           ``_id`` field with a randomly generated :ref:`objectid`
           value.

           .. note::

              You cannot specify different ``_id`` field values in the
              query parameter and replacement document. If you do, the
              operation errors.

         For example, the following update sets the :ref:`upsert
         <upsert-parameter>` option to ``true``:

         .. code-block:: javascript
            :emphasize-lines: 8

            db.books.update(
               { item: "ZZZ135" },   // Query parameter
               {                     // Replacement document
                 item: "ZZZ135",
                 stock: 5,
                 tags: [ "database" ]
               },
               { upsert: true }      // Options
            )

         If no document matches the ``<query>`` parameter, the update
         operation inserts a document with *only* the replacement
         document. Because no ``_id`` field was specified in the
         replacement document or query document, the operation creates a
         new unique ``ObjectId`` for the new document's ``_id`` field.
         You can see the ``upsert`` reflected in the :ref:`WriteResult
         <writeresults-update>` of the operation:

         .. code-block:: javascript
            :copyable: false

            WriteResult({
              "nMatched" : 0,
              "nUpserted" : 1,
              "nModified" : 0,
              "_id" : ObjectId("5da78973835b2f1c75347a83")
             })

         The operation inserts the following document into the ``books``
         collection (your :ref:`objectid` value will differ):

         .. code-block:: javascript

            {
              "_id" : ObjectId("5da78973835b2f1c75347a83"),
              "item" : "ZZZ135",
              "stock" : 5,
              "tags" : [ "database" ]
            }

      .. tab:: Upsert with Operator Expressions
         :tabid: upsert-op-expr

         If no document matches the query criteria and the ``<update>``
         parameter is a document with :ref:`update operator expressions
         <update-operators>`, then the operation creates a base document
         from the equality clauses in the ``<query>`` parameter and
         applies the expressions from the ``<update>`` parameter.

         :doc:`Comparison </reference/operator/query>` operations from
         the ``<query>`` will not be included in the new document. If
         the new document does not include the ``_id`` field, MongoDB
         adds the ``_id`` field with an :ref:`objectid` value.

         For example, the following update sets the :ref:`upsert
         <upsert-parameter>` option to ``true``:

         .. code-block:: javascript

            db.books.update(
               { item: "BLP921" },   // Query parameter
               {                     // Update document
                  $set: { reorder: false },
                  $setOnInsert: { stock: 10 }
               },
               { upsert: true }      // Options
            )

         If no documents match the query condition, the operation
         inserts the following document (your :ref:`objectid` value
         will differ):

         .. code-block:: javascript

            {
              "_id" : ObjectId("5da79019835b2f1c75348a0a"),
              "item" : "BLP921",
              "reorder" : false,
              "stock" : 10
            }

         .. seealso:: :update:`$setOnInsert`

      .. tab:: Aggregation Pipeline using Upsert
         :tabid: agg-pipeline-upsert

         If the ``<update>`` parameter is an :ref:`aggregation pipeline
         <update-behavior-agg-pipeline>`, the update creates a base
         document from the equality clauses in the ``<query>``
         parameter, and then applies the pipeline to the document to
         create the document to insert. If the new document does not
         include the ``_id`` field, MongoDB adds the ``_id`` field with
         an :ref:`objectid` value.

         For example, the following :ref:`upsert: true
         <upsert-parameter>` operation specifies an aggregation pipeline that uses

         - the :pipeline:`$replaceRoot` stage which can provide
           somewhat similar behavior to a :update:`$setOnInsert`
           update operator expression,

         - the :pipeline:`$set` stage which can provide similar
           behavior to the :update:`$set` update operator expression,

         - the aggregation variable :variable:`NOW`, which resolves to
           the current datetime and can provide similar behavior to the
           :update:`$currentDate` update operator expression.

         .. code-block:: javascript

            db.books.update(
               { item: "MRQ014", ratings: [2, 5, 3] }, // Query parameter
               [                                       // Aggregation pipeline
                  { $replaceRoot: { newRoot: { $mergeObjects: [ { stock: 0 }, "$$ROOT"  ] } } },
                  { $set: { avgRating: { $avg: "$ratings" }, tags: [ "fiction", "murder" ], lastModified: "$$NOW" } }
               ],
               { upsert: true }   // Options
            )

         If no document matches the ``<query>`` parameter, the
         operation inserts the following document into the ``books``
         collection (your :ref:`objectid` value will differ):

         .. code-block:: javascript

            {
               "_id" : ObjectId("5e2921e0b4c550aad59d1ba9"),
               "stock" : 0,
               "item" : "MRQ014",
               "ratings" : [ 2, 5, 3 ],
               "avgRating" : 3.3333333333333335,
               "tags" : [ "fiction", "murder" ],
               "lastModified" : ISODate("2020-01-23T04:32:32.951Z")
            }

         .. seealso:: For additional examples of updates using
            aggregation pipelines, see :ref:`update-behavior-agg-pipeline`.

      .. tab:: Combine Upsert and Multi Options
         :tabid: combine-upsert-multi

         Combine Upsert and Multi Options (Match)
         ````````````````````````````````````````

         From the :binary:`~bin.mongo` shell, insert the following
         documents into a ``books`` collection:

         .. code-block:: javascript

            db.books.insertMany([
              {
                _id: 5,
                item: "RQM909",
                stock: 18,
                info: { publisher: "0000", pages: 170 },
                reorder: true
              },
              {
                _id: 6,
                item: "EFG222",
                stock: 15,
                info: { publisher: "1111", pages: 72 },
                reorder: true
              }
            ])

         The following operation specifies both the ``multi`` option and
         the ``upsert`` option. If matching documents exist, the
         operation updates all matching documents. If no matching
         documents exist, the operation inserts a new document.

         .. code-block:: javascript

            db.books.update(
               { stock: { $gte: 10 } },        // Query parameter
               {                               // Update document
                 $set: { reorder: false, tags: [ "literature", "translated" ] }
               },
               { upsert: true, multi: true }   // Options
            )

         The operation updates all matching documents and results in the
         following:

         .. code-block:: javascript

            {
               "_id" : 5,
               "item" : "RQM909",
               "stock" : 18,
               "info" : { "publisher" : "0000", "pages" : 170 },
               "reorder" : false,
               "tags" : [ "literature", "translated" ]
            }
            {
               "_id" : 6,
               "item" : "EFG222",
               "stock" : 15,
               "info" : { "publisher" : "1111", "pages" : 72 },
               "reorder" : false,
               "tags" : [ "literature", "translated" ]
            }

         Combine Upsert and Multi Options (No Match)
         ```````````````````````````````````````````

         If the collection had *no* matching document, the operation
         would result in the insertion of a single document using the
         fields from both the ``<query>`` and the ``<update>``
         specifications. For example, consider the following operation:

         .. code-block:: javascript

            db.books.update(
              { "info.publisher": "Self-Published" },   // Query parameter
              {                                         // Update document
                $set: { reorder: false, tags: [ "literature", "hardcover" ], stock: 25 }
              },
              { upsert: true, multi: true }             // Options
            )

         The operation inserts the following document into the ``books``
         collection (your :ref:`objectid` value will differ):

         .. code-block:: javascript

            {
              "_id" : ObjectId("5db337934f670d584b6ca8e0"),
              "info" : { "publisher" : "Self-Published" },
              "reorder" : false,
              "stock" : 25,
              "tags" : [ "literature", "hardcover" ]
            }

      .. tab:: Upsert with Dotted _id Query
         :tabid: upsert-dotted-id

         .. include:: /includes/fact-upsert-id.rst

         The ``WriteResult`` of the operation returns the following
         error:

         .. code-block:: javascript
            :copyable: false

            WriteResult({
              "nMatched" : 0,
              "nUpserted" : 0,
              "nModified" : 0,
              "writeError" : {
                "code" : 111,
                "errmsg" : "field at '_id' must be exactly specified, field at sub-path '_id.name'found"
              }
            })

         .. seealso:: :method:`WriteResult()`

.. _update-with-unique-indexes:

Use Unique Indexes
``````````````````

.. warning:: To avoid inserting the same document more than once,
   only use ``upsert: true`` if the ``query`` field is uniquely
   indexed.

Given a collection named ``people`` where no documents have
a ``name`` field that holds the value ``Andy``, consider when multiple
clients issue the following :method:`db.collection.update()` with
``upsert: true`` at the same time:

.. code-block:: javascript

   db.people.update(
      { name: "Andy" },   // Query parameter
      {                   // Update document
         name: "Andy",
         rating: 1,
         score: 1
      },
      { upsert: true }    // Options
   )

If all :method:`db.collection.update()` operations complete the
``query`` portion before any client successfully inserts data, **and**
there is no unique index on the ``name`` field, then each update
operation may result in an insert.

To prevent MongoDB from inserting the same document more than once,
create a :ref:`unique index <index-type-unique>` on the ``name`` field.
With a unique index, if multiple applications issue the same update
with ``upsert: true``, *exactly one*
:method:`db.collection.update()` would successfully insert a new
document.

The remaining operations would either:

- update the newly inserted document, or

- fail when they attempted to insert a duplicate.

  If the operation fails because of a duplicate index key error,
  applications may retry the operation which will succeed as an update
  operation.

.. seealso:: :update:`$setOnInsert`

.. _update-behavior-agg-pipeline:
.. _update-example-agg:

Update with Aggregation Pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting in MongoDB 4.2, the :method:`db.collection.update()` method
can accept an :doc:`aggregation pipeline
</core/aggregation-pipeline>` ``[ <stage1>, <stage2>, ... ]`` that
specifies the modifications to perform. The pipeline can consist of
the following stages:

.. include:: /includes/list-update-agg-stages.rst

Using the aggregation pipeline allows for a more expressive update
statement, such as expressing conditional updates based on current
field values or updating one field using the value of another field(s).

Modify a Field Using the Values of the Other Fields in the Document
```````````````````````````````````````````````````````````````````

.. container::

   Create a ``members`` collection with the following documents:

   .. code-block:: javascript

      db.members.insertMany([
         { "_id" : 1, "member" : "abc123", "status" : "A", "points" : 2, "misc1" : "note to self: confirm status", "misc2" : "Need to activate", "lastUpdate" : ISODate("2019-01-01T00:00:00Z") },
         { "_id" : 2, "member" : "xyz123", "status" : "A", "points" : 60, "misc1" : "reminder: ping me at 100pts", "misc2" : "Some random comment", "lastUpdate" : ISODate("2019-01-01T00:00:00Z") }
      ])

   Assume that instead of separate ``misc1`` and ``misc2`` fields, you
   want to gather these into a new ``comments`` field. The following
   update operation uses an aggregation pipeline to:

   - add the new ``comments`` field and set the ``lastUpdate`` field.

   - remove the ``misc1`` and ``misc2`` fields for all documents in the
     collection.

   .. code-block:: javascript

      db.members.update(
         { },
         [
            { $set: { status: "Modified", comments: [ "$misc1", "$misc2" ], lastUpdate: "$$NOW" } },
            { $unset: [ "misc1", "misc2" ] }
         ],
         { multi: true }
      )

   .. note::

      The ``$set`` and ``$unset`` used in the pipeline refers to the
      aggregation stages :pipeline:`$set` and :pipeline:`$unset`
      respectively, and not the update operators :update:`$set` and
      :update:`$unset`.

   First Stage
      The :pipeline:`$set` stage:

      - creates a new array field ``comments`` whose elements are the current
        content of the ``misc1`` and ``misc2`` fields and

      - sets the field ``lastUpdate`` to the value of the aggregation
        variable :variable:`NOW`. The aggregation variable
        :variable:`NOW` resolves to the current datetime value and remains
        the same throughout the pipeline. To access aggregation
        variables, prefix the variable with double dollar signs ``$$``
        and enclose in quotes.

   Second Stage
      The :pipeline:`$unset` stage removes the ``misc1`` and ``misc2`` fields.

   After the command, the collection contains the following documents:

   .. code-block:: javascript

      { "_id" : 1, "member" : "abc123", "status" : "Modified", "points" : 2, "lastUpdate" : ISODate("2020-01-23T05:11:45.784Z"), "comments" : [ "note to self: confirm status", "Need to activate" ] }
      { "_id" : 2, "member" : "xyz123", "status" : "Modified", "points" : 60, "lastUpdate" : ISODate("2020-01-23T05:11:45.784Z"), "comments" : [ "reminder: ping me at 100pts", "Some random comment" ] }

   .. seealso:: :doc:`/tutorial/update-documents-with-aggregation-pipeline`

Perform Conditional Updates Based on Current Field Values
`````````````````````````````````````````````````````````

.. container::

   Create a ``students3`` collection with the following documents:

   .. code-block:: javascript

      db.students3.insert([
         { "_id" : 1, "tests" : [ 95, 92, 90 ], "lastUpdate" : ISODate("2019-01-01T00:00:00Z") },
         { "_id" : 2, "tests" : [ 94, 88, 90 ], "lastUpdate" : ISODate("2019-01-01T00:00:00Z") },
         { "_id" : 3, "tests" : [ 70, 75, 82 ], "lastUpdate" : ISODate("2019-01-01T00:00:00Z") }
      ]);

   Using an aggregation pipeline, you can update the documents with the
   calculated grade average and letter grade.

   .. code-block:: javascript

      db.students3.update(
         { },
         [
           { $set: { average : { $trunc: [ { $avg: "$tests" }, 0 ] }, lastUpdate: "$$NOW" } },
           { $set: { grade: { $switch: {
                                 branches: [
                                     { case: { $gte: [ "$average", 90 ] }, then: "A" },
                                     { case: { $gte: [ "$average", 80 ] }, then: "B" },
                                     { case: { $gte: [ "$average", 70 ] }, then: "C" },
                                     { case: { $gte: [ "$average", 60 ] }, then: "D" }
                                 ],
                                 default: "F"
           } } } }
         ],
         { multi: true }
      )

   .. note::

      The ``$set`` used in the pipeline refers to the aggregation stage
      :pipeline:`$set`, and not the update operators :update:`$set`.

   First Stage
      The :pipeline:`$set` stage:

      - calculates a new field ``average`` based on the average of the
        ``tests`` field. See :group:`$avg` for more information on the
        ``$avg`` aggregation operator and :expression:`$trunc` for more
        information on the  ``$trunc`` truncate aggregation operator.

      - sets the field ``lastUpdate`` to the value of the aggregation
        variable :variable:`NOW`. The aggregation variable
        :variable:`NOW` resolves to the current datetime value and remains
        the same throughout the pipeline. To access aggregation
        variables, prefix the variable with double dollar signs ``$$``
        and enclose in quotes.

   Second Stage
      The :pipeline:`$set` stage calculates a new field ``grade`` based on
      the ``average`` field calculated in the previous stage. See
      :expression:`$switch` for more information on the ``$switch``
      aggregation operator.

   After the command, the collection contains the following documents:

   .. code-block:: javascript

      { "_id" : 1, "tests" : [ 95, 92, 90 ], "lastUpdate" : ISODate("2020-01-24T17:29:35.340Z"), "average" : 92, "grade" : "A" }
      { "_id" : 2, "tests" : [ 94, 88, 90 ], "lastUpdate" : ISODate("2020-01-24T17:29:35.340Z"), "average" : 90, "grade" : "A" }
      { "_id" : 3, "tests" : [ 70, 75, 82 ], "lastUpdate" : ISODate("2020-01-24T17:29:35.340Z"), "average" : 75, "grade" : "C" }

   .. seealso:: :doc:`/tutorial/update-documents-with-aggregation-pipeline`

.. _update-arrayFilters:

Specify ``arrayFilters`` for Array Update Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include::  /includes/extracts/arrayFilters-details.rst

.. include:: /includes/extracts/arrayFilters-update-aggregation-restriction.rst

Update Elements Match ``arrayFilters`` Criteria
```````````````````````````````````````````````

To update all array elements which match a specified criteria, use the
:ref:`arrayFilters <update-array-filters>` parameter.

From the :binary:`~bin.mongo` shell, create a ``students``
collection with the following documents:

.. code-block:: javascript

   db.students.insertMany([
      { "_id" : 1, "grades" : [ 95, 92, 90 ] },
      { "_id" : 2, "grades" : [ 98, 100, 102 ] },
      { "_id" : 3, "grades" : [ 95, 110, 100 ] }
   ])

To update all elements that are greater than or equal to ``100`` in the
``grades`` array, use the filtered positional operator
:update:`$[\<identifier\>]` with the ``arrayFilters`` option:

.. code-block:: javascript

   db.students.update(
      { grades: { $gte: 100 } },
      { $set: { "grades.$[element]" : 100 } },
      {
        multi: true,
        arrayFilters: [ { "element": { $gte: 100 } } ]
      }
   )

After the operation, the collection contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "grades" : [ 95, 92, 90 ] }
   { "_id" : 2, "grades" : [ 98, 100, 100 ] }
   { "_id" : 3, "grades" : [ 95, 100, 100 ] }

Update Specific Elements of an Array of Documents
`````````````````````````````````````````````````

You can also use the :ref:`arrayFilters <update-array-filters>`
parameter to update specific document fields within an array of
documents.

From the :binary:`~bin.mongo` shell, create a ``students2``
collection with the following documents:

.. code-block:: javascript

   db.students2.insertMany([
     {
       "_id" : 1,
       "grades" : [
          { "grade" : 80, "mean" : 75, "std" : 6 },
          { "grade" : 85, "mean" : 90, "std" : 4 },
          { "grade" : 85, "mean" : 85, "std" : 6 }
       ]
     }
     {
        "_id" : 2,
        "grades" : [
           { "grade" : 90, "mean" : 75, "std" : 6 },
           { "grade" : 87, "mean" : 90, "std" : 3 },
           { "grade" : 85, "mean" : 85, "std" : 4 }
        ]
     }
   ])

To modify the value of the ``mean`` field for all elements in the
``grades`` array where the grade is greater than or equal to ``85``,
use the filtered positional operator :update:`$[\<identifier\>]` with
the ``arrayFilters``:

.. code-block:: javascript

   db.students2.update(
      { },
      { $set: { "grades.$[elem].mean" : 100 } },
      {
        multi: true,
        arrayFilters: [ { "elem.grade": { $gte: 85 } } ]
      }
   )

After the operation, the collection has the following documents:

.. code-block:: javascript

   {
      "_id" : 1,
      "grades" : [
         { "grade" : 80, "mean" : 75, "std" : 6 },
         { "grade" : 85, "mean" : 100, "std" : 4 },
         { "grade" : 85, "mean" : 100, "std" : 6 }
      ]
   }
   {
      "_id" : 2,
      "grades" : [
         { "grade" : 90, "mean" : 100, "std" : 6 },
         { "grade" : 87, "mean" : 100, "std" : 3 },
         { "grade" : 85, "mean" : 100, "std" : 4 }
      ]
   }

.. _ex-update-hint:

Specify ``hint`` for Update Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 4.2

From the :binary:`~bin.mongo` shell, create a ``members``
collection with the following documents:

.. code-block:: javascript

   db.members.insertMany([
      { "_id" : 1, "member" : "abc123", "status" : "P", "points" :  0,  "misc1" : null, "misc2" : null },
      { "_id" : 2, "member" : "xyz123", "status" : "A", "points" : 60,  "misc1" : "reminder: ping me at 100pts", "misc2" : "Some random comment" },
      { "_id" : 3, "member" : "lmn123", "status" : "P", "points" :  0,  "misc1" : null, "misc2" : null },
      { "_id" : 4, "member" : "pqr123", "status" : "D", "points" : 20,  "misc1" : "Deactivated", "misc2" : null },
      { "_id" : 5, "member" : "ijk123", "status" : "P", "points" :  0,  "misc1" : null, "misc2" : null },
      { "_id" : 6, "member" : "cde123", "status" : "A", "points" : 86,  "misc1" : "reminder: ping me at 100pts", "misc2" : "Some random comment" }
   ])

Create the following indexes on the collection:

.. code-block:: javascript

   db.members.createIndex( { status: 1 } )
   db.members.createIndex( { points: 1 } )

The following update operation explicitly :ref:`hints <update-hint>` to
use the index ``{status: 1 }``:

.. note::

   If you specify an index that does not exist, the operation errors.

.. code-block:: javascript

   db.members.update(
      { points: { $lte: 20 }, status: "P" },     // Query parameter
      { $set: { misc1: "Need to activate" } },   // Update document
      { multi: true, hint: { status: 1 } }       // Options
   )

The update command returns the following:

.. code-block:: javascript

   WriteResult({ "nMatched" : 3, "nUpserted" : 0, "nModified" : 3 })

To see the index used, run :dbcommand:`explain` on the operation:

.. code-block:: javascript

   db.members.explain().update(
      { "points": { $lte: 20 }, "status": "P" },
      { $set: { "misc1": "Need to activate" } },
      { multi: true, hint: { status: 1 } }
   )

The :method:`db.collection.explain().update() <db.collection.explain>`
does not modify the documents.

.. _example-update-write-concern:

Override Default Write Concern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following operation on a replica set specifies a :doc:`write
concern </reference/write-concern>` of ``"w: majority"`` with a
``wtimeout`` of 5000 milliseconds such that the method returns after
the write propagates to a majority of the voting replica set members or
the method times out after 5 seconds.

.. code-block:: javascript

   db.books.update(
      { stock: { $lte: 10 } },
      { $set: { reorder: true } },
      {
        multi: true,
        writeConcern: { w: "majority", wtimeout: 5000 }
      }
   )

.. _example-update-collation:

Specify Collation
~~~~~~~~~~~~~~~~~

.. include:: /includes/extracts/collation-option.rst

From the :binary:`~bin.mongo` shell, create a collection named
``myColl`` with the following documents:

.. code-block:: javascript

   db.myColl.insertMany(
     [
       { _id: 1, category: "café", status: "A" },
       { _id: 2, category: "cafe", status: "a" },
       { _id: 3, category: "cafE", status: "a" }
     ])

The following operation includes the :ref:`collation <collation>`
option and sets ``multi`` to ``true`` to update all matching documents:

.. code-block:: javascript

   db.myColl.update(
      { category: "cafe" },
      { $set: { status: "Updated" } },
      {
        collation: { locale: "fr", strength: 1 },
        multi: true
      }
   );

The :ref:`write result <writeresults-update>` of the operation returns the following document, indicating that all three documents in the
collection were updated:

.. code-block:: none
   :copyable: false

   WriteResult({ "nMatched" : 3, "nUpserted" : 0, "nModified" : 3 })

After the operation, the collection contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "category" : "café", "status" : "Updated" }
   { "_id" : 2, "category" : "cafe", "status" : "Updated" }
   { "_id" : 3, "category" : "cafE", "status" : "Updated" }

.. _writeresults-update:

WriteResult
-----------

Successful Results
~~~~~~~~~~~~~~~~~~

The :method:`db.collection.update()` method returns a
:method:`WriteResult` object that contains the status of the operation.
Upon success, the :method:`WriteResult` object contains the number of
documents that matched the query condition, the number of documents
inserted by the update, and the number of documents modified:

.. code-block:: javascript

   WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

.. see:: :data:`WriteResult.nMatched`, :data:`WriteResult.nUpserted`,
   :data:`WriteResult.nModified`

Write Concern Errors
~~~~~~~~~~~~~~~~~~~~

If the :method:`db.collection.update()` method encounters write
concern errors, the results include the
:data:`WriteResult.writeConcernError` field:

.. versionchanged:: 4.4

.. code-block:: javascript

   WriteResult({
      "nMatched" : 1,
      "nUpserted" : 0,
      "nModified" : 1,
      "writeConcernError": {
        "code" : 64,
        "errmsg" : "waiting for replication timed out",
        "errInfo" : {
          "wtimeout" : true,
          "writeConcern" : {
            "w" : "majority",
            "wtimeout" : 100,
            "provenance" : "getLastErrorDefaults"
          }
      }
   })

The following table explains the possible values of
``WriteResult.writeConcernError.provenance``:

.. include:: /includes/fact-wc-provenance-table.rst

.. seealso:: :method:`WriteResult.hasWriteConcernError()`

Errors Unrelated to Write Concern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the :method:`db.collection.update()` method encounters a non-write
concern error, the results include the :data:`WriteResult.writeError`
field:

.. code-block:: javascript

   WriteResult({
      "nMatched" : 0,
      "nUpserted" : 0,
      "nModified" : 0,
      "writeError" : {
         "code" : 7,
         "errmsg" : "could not contact primary for replica set shard-a"
      }
   })

.. seealso:: :method:`WriteResult.hasWriteError()`
