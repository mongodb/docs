===================
$last (aggregation)
===================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. expression:: $last

   .. versionadded:: 4.4

   Returns the last element in an array. 

   .. admonition:: Disambiguation
      :class: note
   
      The following page describes the array element operator
      :expression:`$last`. For the accumulator :group:`$last`,
      available only with the :pipeline:`$group` stage, see
      :group:`$last (accumulator) <$last>` instead.

Syntax
------


The :expression:`$last` operator has the following syntax:

.. code-block:: javascript

   { $last: <expression> }

The ``<expression>`` can be any valid :ref:`expression
<aggregation-expressions>` as long as it resolves to an array, null, or
missing. For more information on expressions, see
:ref:`aggregation-expressions`.

The :expression:`$last` operator is an alias for the following
:expression:`$arrayElemAt` expression:

.. code-block:: javascript

   { $arrayElemAt: [ <array expression>, -1 ] }

Behavior
--------

Valid Operands
~~~~~~~~~~~~~~

Valid operand for :expression:`$last` must resolve to an array, null,
or missing.

- If the operand resolves to a non-empty array, :expression:`$last`
  returns the first element in the array:

- If the operand resolves to an empty array ``[]``,
  :expression:`$last` does not return a value.

- If the operand is null or missing, :expression:`$last` returns null.

For example, create a test collection ``example1`` with the following
documents:

.. code-block:: javascript

   db.example1.insertMany([
        { "_id" : 1, "x" : [ 1, 2, 3 ] },      // Non-empty array
        { "_id" : 2, "x" : [ [ ] ] },          // Non-empty array
        { "_id" : 3, "x" : [ null ] },         // Non-empty array
        { "_id" : 4, "x" : [ ] },              // Empty array
        { "_id" : 5, "x" : null },             // Is null
        { "_id" : 6 }                          // Is Missing
   ])

Then, the following adds a new field ``lastElem`` whose value is
derived from applying the :expression:`$last` operator to the ``x``
field:

.. code-block:: javascript

   db.example1.aggregate([
      { $addFields: { lastElem: { $last: "$x" } } }
   ])

The operator returns the following documents:

.. code-block:: javascript
   :copyable: false
   
   { "_id" : 1, "x" : [ 1, 2, 3 ], "lastElem" : 3 }
   { "_id" : 2, "x" : [ [ ] ], "lastElem" : [ ] }
   { "_id" : 3, "x" : [ null ], "lastElem" : null }
   { "_id" : 4, "x" : [ ] }                         // No output
   { "_id" : 5, "x" : null, "lastElem" : null }
   { "_id" : 6, "lastElem" : null }

Invalid Operands
~~~~~~~~~~~~~~~~

If the operand does not resolve to an array, null, or missing, the
aggregation operation as a whole errors.

For example, create a test collection ``example2`` with the following
documents:

.. code-block:: javascript

   db.example2.insertMany([
      { "_id" : 1, "x" : [ 1, 2, 3 ] },
      { "_id" : 2, "x" : 2 },             // x is not an array/null or missing
   ])

Then, the following aggregation operation returns an error because of
the ``{ "_id" : 2, "x" : 2 }`` document:

.. code-block:: javascript

   db.example2.aggregate( { $addFields: { lastElem: { $last: "$x" } } } )

That is, the operation returns the following:

.. code-block:: javascript
   :copyable: false

   2020-01-20T21:12:26.713-0500 E  QUERY    [js] uncaught exception: Error: command failed: {
      "ok" : 0,
      "errmsg" : "$last's argument must be an array, but is double",
      "code" : 28689,
      "codeName" : "Location28689"
   } : aggregate failed :


Example
-------

Create a sample collection ``runninglog`` with the following documents:

.. code-block:: javascript

   db.runninglog.insertMany([
      { "_id" : 1, "team" : "Anteater", log: [ { run: 1, distance: 8 }, { run2: 2, distance: 7.5 }, { run: 3, distance: 9.2 } ] },
      { "_id" : 2, "team" : "Bears", log: [ { run: 1, distance: 18 }, { run2: 2, distance: 17 }, { run: 3, distance: 16 } ] },
      { "_id" : 3, "team" : "Cobras", log: [ { run: 1, distance: 2 } ] }
   ])

The following aggregation uses the :expression:`$first` and
:expression:`$last` operator on the ``log`` array to retrieve the
information for the first run and the last run:

.. code-block:: javascript

  db.runninglog.aggregate([
     { $addFields: { firstrun: { $first: "$log" }, lastrun: { $last: "$log" } } }
  ])

The operation returns the following results:

.. code-block:: javascript

   { "_id" : 1, "team" : "Anteater", "log" : [ { "run" : 1, "distance" : 8 }, { "run2" : 2, "distance" : 7.5 }, { "run" : 3, "distance" : 9.2 } ],
         "firstrun" : { "run" : 1, "distance" : 8 }, "lastrun" : { "run" : 3, "distance" : 9.2 } }
   { "_id" : 2, "team" : "Bears", "log" : [ { "run" : 1, "distance" : 18 }, { "run2" : 2, "distance" : 17 }, { "run" : 3, "distance" : 16 } ],
         "firstrun" : { "run" : 1, "distance" : 18 }, "lastrun" : { "run" : 3, "distance" : 16 } }
   { "_id" : 3, "team" : "Cobras", "log" : [ { "run" : 1, "distance" : 2 } ],
         "firstrun" : { "run" : 1, "distance" : 2 }, "lastrun" : { "run" : 1, "distance" : 2 } }
   
To calculate the change between the first and the last distances, the
following operation uses :expression:`$cond` and :expression:`$size`
operators to calculate the difference (i.e. :expression:`$subtract`)
the two distances if there are two or more elements in the ``log``
array:

.. code-block:: javascript

   db.runninglog.aggregate([
     { $addFields: { firstrun: { $first: "$log" }, lastrun: { $last: "$log" } } },
     { $project: { team: 1, progress: 
         {
           $cond: { 
              if: { $gt: [ { $size:"$log" }, 1 ] } , 
              then: { $subtract: [ "$lastrun.distance", "$firstrun.distance"] }, 
              else: "Not enough data." }
         }
     
     }}
   ])

The operation returns the following documents:

.. code-block:: javascript
   :copyable: false

   { "_id" : 1, "team" : "Anteater", "progress" : 1.1999999999999993 }
   { "_id" : 2, "team" : "Bears", "progress" : -2 }
   { "_id" : 3, "team" : "Cobras", "progress" : "Not enough data." }

By default, the :binary:`~bin.shell` uses the 64-bit floating-point
double for numbers. To improve precision, you can use :ref:`shell-type-decimal`
instead.

See Also
--------

- :expression:`$first`

- :expression:`$arrayElemAt`

- :expression:`$slice`

- :ref:`agg-quick-ref-operator-array`

