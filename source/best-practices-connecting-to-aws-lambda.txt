=========================================
Best Practices Connecting from AWS Lambda
=========================================

.. default-domain:: mongodb

.. meta::
   :keywords: lambda connection

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Use the following best practices to properly manage connections
between :aws:`AWS Lambda </lambda/latest/dg/welcome.html>`
and |service|:

- Define the client to the MongoDB server outside
  the :aws:`AWS Lambda handler function </lambda/latest/dg/nodejs-prog-model-handler.html>`.

  Don't define a new MongoClient object each time you invoke your
  function. Doing so causes the driver to create a new database
  connection with each function call. This can be expensive and
  can result in your application exceeding database connection limits.
  As an alternative, do the following:

  1. Create the MongoClient object once.
  2. Store the object so your function can reuse the MongoClient across
     function invocations.

  The :ref:`Connection Example <lambda-aws-example>` reuses existing
  database connections to speed up communication with the database and
  keep connection counts to the database at a reasonable level with
  respect to application traffic.

- If your handler takes a callback as its last argument, set the
  ``callbackWaitsForEmptyEventLoop`` property on the
  :aws:`AWS Lambda Context </lambda/latest/dg/nodejs-context.html#nodejs-prog-model-context-properties>`
  object to **false**.

  .. code-block:: java
      
     context.callbackWaitsForEmptyEventLoop = false;

  This allows a Lambda function to return its result to the caller
  without requiring that the MongoDB database connection be closed.
  Setting this property is not applicable for `async handlers
  <https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html>`__.

- Restrict network access to your |service| cluster.
  
  Connect to your |service| cluster over private networking using a
  :doc:`Network Peering connection </security-vpc-peering>` 
  between your |service| cluster and your |aws| Lambda function, or,
  alternatively, a :doc:`private endpoint </security-private-endpoint/>`,
  so that you can allow only private IP addresses to your
  :doc:`IP access list </security/ip-access-list/>`.

  If private networking is not an option, consider connecting to your
  |service| cluster via a `NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html>`__
  with a mapped Elastic IP address. Otherwise, you must
  allow all IP addresses (0.0.0.0/0) to access your service cluster.

.. _lambda-aws-example:

Connection Examples
```````````````````

This section includes examples for two approaches:

- In the first Node.js example, the ``index.js`` file shows how to reuse
  ``Mongoclient.connect`` across function invocations.
- In the second Node.js example, the ``index.js`` and
  ``mongodb-client.js`` files show how to isolate the call to
  ``MongoClient.connect`` into its own module so that the connections
  can be reused across functions. Use this approach if you package
  multiple logical functions together in a single Lambda handler function.


The following example shows the best practice of defining the
``MongoClient.connect`` function in your application's Node.js code
outside the handler so it can be reused across function invocations.

.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";

   // Import the dependency.
   const { MongoClient } = require('mongodb');

   // Create a module-scoped connection promise.
   // CRITICAL: You must call connect outside the handler so that the client
   // can be reused across function invocations.
   const clientPromise = MongoClient.connect(process.env.MONGODB_URI,
      { useNewUrlParser: true,  useUnifiedTopology: true });

   // Handler
   module.exports.handler = async function(event, context) {

      // Get the MongoClient by calling await on the connection promise. Because
      // this is a promise it will only resolve once.
      const client = await clientPromise;

      // Use the client to return the name of the connected database.
      return client.db().databaseName;
   }


Some serverless frameworks that run on top of Lambda allow for
multiple logical functions to be packaged together in a single
Lambda handler function. If your application runs multiple functions
within the same Lambda process, we recommend isolating the call to
the ``MongoClient.connect`` function into its own module so that
the connections can be reused across functions.

In the following code examples:

- ``mongo-client.js`` organizes the ``MongoClient.connect`` function
  into its own module (mongo-client).
- ``index.js`` imports that module and uses it to connect.

.. code-block:: javascript
   :caption: mongodb-client.js
   :linenos:

   "use strict";

   // Import the dependency.
   const { MongoClient } = require('mongodb');

   // Export a module-scoped connection promise. By doing this in a separate
   // module, the client can be shared across functions.
   module.exports = MongoClient.connect(process.env.MONGODB_URI,
     { useNewUrlParser: true,  useUnifiedTopology: true });


.. code-block:: javascript
   :caption: index.js
   :linenos:

   "use strict";

   // Import the dependency.
   const clientPromise = require('./mongodb-client');

   // Handler
   module.exports.handler = async function(event, context) {

      // Get the MongoClient by calling await on the connection promise. Because
      // this is a promise, it will only resolve once.
      const client = await clientPromise;

      // Use the connection to return the name of the connected database.
      return client.db().databaseName;
   }
