# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2014, MongoDB, Inc.
# This file is distributed under the same license as the mongodb-manual
# package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: MongoDB Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-12-08 12:02-0500\n"
"PO-Revision-Date: 2014-04-08 19:28+0000\n"
"Last-Translator: tychoish <tychoish@gmail.com>\n"
"Language: es\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/mongodb-"
"manual/language/es/)\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# 224fdec54c27469180b393ca78c7130c
#: ../source/core/capped-collections.txt:3
msgid "Capped Collections"
msgstr ""

# db835008cddf40d79634a76b91adcfc2
#: ../source/core/capped-collections.txt
msgid "On this page"
msgstr ""

# 77aeecb75c124157aa9e1dbfc086458f
#: ../source/core/capped-collections.txt:14
msgid "Overview"
msgstr ""

# 5f04822f98eb414797141f2a37ab9984
#: ../source/core/capped-collections.txt:16
msgid ""
":term:`Capped collections <capped collection>` are fixed-size collections"
" that support high-throughput operations that insert and retrieve "
"documents based on insertion order. Capped collections work in a way "
"similar to circular buffers: once a collection fills its allocated space,"
" it makes room for new documents by overwriting the oldest documents in "
"the collection."
msgstr ""

# 74abdf25852e45839aaa981063dd6aec
#: ../source/core/capped-collections.txt:23
msgid ""
"See :method:`~db.createCollection()` or :dbcommand:`create` for more "
"information on creating capped collections."
msgstr ""

# 538cf94cec3243a39c976ded8c04f462
#: ../source/core/capped-collections.txt:27
msgid "Behavior"
msgstr ""

# a886e491e4704d2d801be86fd78198d9
#: ../source/core/capped-collections.txt:30
msgid "Insertion Order"
msgstr ""

# 79a7e1447d3b4e0d818b000e5f2d8cea
#: ../source/core/capped-collections.txt:32
msgid ""
"Capped collections guarantee preservation of the insertion order. As a "
"result, queries do not need an index to return documents in insertion "
"order. Without this indexing overhead, capped collections can support "
"higher insertion throughput."
msgstr ""

# 296bdaac6ee54d3fb3298fc4686aec00
#: ../source/core/capped-collections.txt:38
msgid "Automatic Removal of Oldest Documents"
msgstr ""

# 707579f353584b839d8a9ef2946279c6
#: ../source/core/capped-collections.txt:40
msgid ""
"To make room for new documents, capped collections automatically remove "
"the oldest documents in the collection without requiring scripts or "
"explicit remove operations."
msgstr ""

# c630416b5a5b48a89781ab336f38b244
#: ../source/core/capped-collections.txt:44
msgid ""
"For example, the :term:`oplog.rs <oplog>` collection that stores a log of"
" the operations in a :term:`replica set` uses a capped collection. "
"Consider the following potential use cases for capped collections:"
msgstr ""

# 6b4e444f3a5c4c81b4106ac89445d8ce
#: ../source/core/capped-collections.txt:49
msgid ""
"Store log information generated by high-volume systems. Inserting "
"documents in a capped collection without an index is close to the speed "
"of writing log information directly to a file system. Furthermore, the "
"built-in *first-in-first-out* property maintains the order of events, "
"while managing storage use."
msgstr ""

# 01c166b944574cdeb4199f9082f4e7da
#: ../source/core/capped-collections.txt:55
msgid ""
"Cache small amounts of data in a capped collections. Since caches are "
"read rather than write heavy, you would either need to ensure that this "
"collection *always* remains in the working set (i.e. in RAM) *or* accept "
"some write penalty for the required index or indexes."
msgstr ""

# bd108e05728d4d83b3a81abff8ff40c7
#: ../source/core/capped-collections.txt:62
msgid "``_id`` Index"
msgstr ""

# 09c0c09a1f8042e79a64f1009d21448d
#: ../source/core/capped-collections.txt:64
msgid ""
"Capped collections have an ``_id`` field and an index on the ``_id`` "
"field by default."
msgstr ""

# 7ca3000be0364817bc5d35a63cb02c0f
#: ../source/core/capped-collections.txt:70
msgid "Restrictions and Recommendations"
msgstr ""

# ffa856023b254cd884fc4159c78aa6c8
#: ../source/core/capped-collections.txt:73
msgid "Updates"
msgstr ""

# b247fbb0ac4747999e206332cb181145
#: ../source/core/capped-collections.txt:75
msgid ""
"If you plan to update documents in a capped collection, create an index "
"so that these update operations do not require a collection scan."
msgstr ""

# d503d14473e94de2b7197b08091f0659
#: ../source/core/capped-collections.txt:79
msgid "Document Size"
msgstr ""

# 92c6b18e72a04be3a01719cd9748fe9e
#: ../source/includes/extracts/capped-collection-immutable-document-size.rst:1
msgid ""
"If an update or a replacement operation changes the document size, the "
"operation will fail."
msgstr ""

# 32f4c76ec504449ea4f89ad5f85a47d2
#: ../source/core/capped-collections.txt:86
msgid "Document Deletion"
msgstr ""

# 79e145b345ec4f6cbf9165626a56859d
#: ../source/core/capped-collections.txt:88
msgid ""
"You cannot delete documents from a capped collection. To remove all "
"documents from a collection, use the :method:`~db.collection.drop()` "
"method to drop the collection and recreate the capped collection."
msgstr ""

# 37804282f50e44fe8257e9cb6632d250
#: ../source/core/capped-collections.txt:93
msgid "Sharding"
msgstr ""

# fe676cfc4ccb4ac7bef4f6df9939a3f0
#: ../source/core/capped-collections.txt:95
msgid "You cannot shard a capped collection."
msgstr ""

# ef91e52f3375420fa1317375f1e64332
#: ../source/core/capped-collections.txt:98
msgid "Query Efficiency"
msgstr ""

# e3a79f06082941f2ad0a625ed7157524
#: ../source/core/capped-collections.txt:100
msgid ""
"Use natural ordering to retrieve the most recently inserted elements from"
" the collection efficiently. This is (somewhat) analogous to tail on a "
"log file."
msgstr ""

# e6a66fa217ed47919cc2c9583a084ff7
#: ../source/core/capped-collections.txt:105
msgid "Aggregation ``$out``"
msgstr ""

# 41f5a2ca58bf4dd78524b4ecdc703333
#: ../source/core/capped-collections.txt:107
msgid ""
"The aggregation pipeline operator :pipeline:`$out` cannot write results "
"to a capped collection."
msgstr ""

# f27866c9dd8f41feb733500dd119cfd1
#: ../source/core/capped-collections.txt:113
msgid "Procedures"
msgstr ""

# bf74dbcdf9af4dac8ae98100356f1134
#: ../source/core/capped-collections.txt:116
msgid "Create a Capped Collection"
msgstr ""

# 3554071fc9ec47f98b32bb7ca1b830e4
#: ../source/core/capped-collections.txt:118
msgid ""
"You must create capped collections explicitly using the "
":method:`db.createCollection()` method, which is a helper in the "
":program:`mongo` shell for the :dbcommand:`create` command. When creating"
" a capped collection you must specify the maximum size of the collection "
"in bytes, which MongoDB will pre-allocate for the collection. The size of"
" the capped collection includes a small amount of space for internal "
"overhead."
msgstr ""

# 8949e51bc20249caa6211d59e97d0dae
#: ../source/core/capped-collections.txt:130
msgid ""
"If the ``size`` field is less than or equal to 4096, then the collection "
"will have a cap of 4096 bytes. Otherwise, MongoDB will raise the provided"
" size to make it an integer multiple of 256."
msgstr ""

# 15df8466d33b43c5bb0e3cea72172e93
#: ../source/core/capped-collections.txt:134
msgid ""
"Additionally, you may also specify a maximum number of documents for the "
"collection using the ``max`` field as in the following document:"
msgstr ""

# ffa175815ac54bb699e67b5030f0991e
#: ../source/core/capped-collections.txt:141
msgid ""
"The ``size`` argument is *always* required, even when you specify ``max``"
" number of documents. MongoDB will remove older documents if a collection"
" reaches the maximum size limit before it reaches the maximum document "
"count."
msgstr ""

# 55c3ca14d08f4319ade72061c2035645
#: ../source/core/capped-collections.txt
msgid "See"
msgstr ""

# 6a38ffac9a244d639ca31d15ae583667
#: ../source/core/capped-collections.txt:151
msgid "Query a Capped Collection"
msgstr ""

# 64bd71ae6db84974943f0a5602110883
#: ../source/core/capped-collections.txt:153
msgid ""
"If you perform a :method:`~db.collection.find()` on a capped collection "
"with no ordering specified, MongoDB guarantees that the ordering of "
"results is the same as the insertion order."
msgstr ""

# 9f5bf3620ed349b5afeb413c6654951c
#: ../source/core/capped-collections.txt:157
msgid ""
"To retrieve documents in reverse insertion order, issue "
":method:`~db.collection.find()` along with the :method:`~cursor.sort()` "
"method with the :operator:`$natural` parameter set to ``-1``, as shown in"
" the following example:"
msgstr ""

# eb4098ede9764ec68404be29933a022c
#: ../source/core/capped-collections.txt:167
msgid "Check if a Collection is Capped"
msgstr ""

# d0571afbbf464aad86082f27cdda06c7
#: ../source/core/capped-collections.txt:169
msgid ""
"Use the :method:`~db.collection.isCapped()` method to determine if a "
"collection is capped, as follows:"
msgstr ""

# 5b08039454724556b19b99fbd749d8f1
#: ../source/core/capped-collections.txt:177
msgid "Convert a Collection to Capped"
msgstr ""

# 01ffa118aa4946dfa0922863c2820896
#: ../source/core/capped-collections.txt:179
msgid ""
"You can convert a non-capped collection to a capped collection with the "
":dbcommand:`convertToCapped` command:"
msgstr ""

# a91bfdf4b70a49e2b94d7d6dba2fec5d
#: ../source/core/capped-collections.txt:186
msgid ""
"The ``size`` parameter specifies the size of the capped collection in "
"bytes."
msgstr ""

# 3134687355ef40a6ae0c78be63f25c21
#: ../source/includes/warning-blocking-global.rst:3
msgid ""
"This command obtains a global write lock and will block other operations "
"until it has completed."
msgstr ""

# 97f40140214c4c71a6e70056b2096eb8
#: ../source/core/capped-collections.txt:192
msgid "Automatically Remove Data After a Specified Period of Time"
msgstr ""

# 135629d2843442f8bc5ba068d91d2fc7
#: ../source/core/capped-collections.txt:194
msgid ""
"For additional flexibility when expiring data, consider MongoDB's "
":term:`TTL` indexes, as described in :doc:`/tutorial/expire-data`. These "
"indexes allow you to expire and remove data from normal collections using"
" a special type, based on the value of a date-typed field and a TTL value"
" for the index."
msgstr ""

# 97d759f6d3b043dcb37b09b1e39960b0
#: ../source/core/capped-collections.txt:200
msgid ""
":doc:`TTL Collections </tutorial/expire-data>` are not compatible with "
"capped collections."
msgstr ""

# 6e7ed059c167498994d0999ba073d6be
#: ../source/core/capped-collections.txt:204
msgid "Tailable Cursor"
msgstr ""

# 8e6d18691c08492db19679fa56b320fe
#: ../source/core/capped-collections.txt:206
msgid ""
"You can use a :term:`tailable cursor` with capped collections. Similar to"
" the Unix ``tail -f`` command, the tailable cursor \"tails\" the end of a"
" capped collection. As new documents are inserted into the capped "
"collection, you can use the tailable cursor to continue retrieving "
"documents."
msgstr ""

# 7279b773dc5146798d89eb2cced94225
#: ../source/core/capped-collections.txt:212
msgid ""
"See :doc:`/core/tailable-cursors` for information on creating a tailable "
"cursor."
msgstr ""

#~ msgid ""
#~ "See :method:`~db.createCollection()` or "
#~ ":dbcommand:`createCollection` for more information"
#~ " on creating capped collections."
#~ msgstr ""

#~ msgid ""
#~ "You *can* update documents in a "
#~ "collection after inserting them. *However,*"
#~ " these updates **cannot** cause the "
#~ "documents to grow. If the update "
#~ "operation causes the document to grow"
#~ " beyond their original size, the "
#~ "update operation will fail."
#~ msgstr ""

#~ msgid ""
#~ "You can use a tailable cursor with"
#~ " capped collections. Similar to the "
#~ "Unix ``tail -f`` command, the tailable"
#~ " cursor \"tails\" the end of a "
#~ "capped collection. As new documents are"
#~ " inserted into the capped collection, "
#~ "you can use the tailable cursor to"
#~ " continue retrieving documents."
#~ msgstr ""

# 147e7ea0a3c44167b39df3eea824c3fc
#~ msgid ""
#~ ":term:`Capped collections <capped collection>` "
#~ "are fixed-size collections that support"
#~ " high-throughput operations that insert,"
#~ " retrieve, and delete documents based "
#~ "on insertion order. Capped collections "
#~ "work in a way similar to circular"
#~ " buffers: once a collection fills its"
#~ " allocated space, it makes room for"
#~ " new documents by overwriting the "
#~ "oldest documents in the collection."
#~ msgstr ""

# ac21964830ed479db45f7ace697dbb02
#~ msgid "Capped collections have the following behaviors:"
#~ msgstr ""

# 217720f9f2014ca19d835823fad10e75
#~ msgid ""
#~ "Capped collections guarantee preservation of"
#~ " the insertion order. As a result,"
#~ " queries do not need an index "
#~ "to return documents in insertion order."
#~ " Without this indexing overhead, they "
#~ "can support higher insertion throughput."
#~ msgstr ""

# 1bb593430d52442ab7c5e47c96c23448
#~ msgid ""
#~ "Capped collections guarantee that insertion"
#~ " order is identical to the order "
#~ "on disk (:term:`natural order`) and do"
#~ " so by prohibiting updates that "
#~ "increase document size. Capped collections "
#~ "only allow updates that fit the "
#~ "original document size, which ensures a"
#~ " document does not change its "
#~ "location on disk."
#~ msgstr ""

# 5ad7527aedde4028acee852a122f6426
#~ msgid ""
#~ "Capped collections automatically remove the"
#~ " oldest documents in the collection "
#~ "without requiring scripts or explicit "
#~ "remove operations."
#~ msgstr ""

# 32a5204209894641a051a6f4e35bdfe2
#~ msgid "Recommendations and Restrictions"
#~ msgstr ""

# b6252b1b648d4d408eb6524d36d14a54
#~ msgid ""
#~ "If you plan to update documents in"
#~ " a capped collection, create an index"
#~ " so that these update operations do"
#~ " not require a table scan."
#~ msgstr ""

# ad7a10a56b1048bfa3c37a42418e7ea7
#~ msgid ""
#~ "You cannot delete documents from a "
#~ "capped collection. To remove all records"
#~ " from a capped collection, use the"
#~ " 'emptycapped' command. To remove the "
#~ "collection entirely, use the "
#~ ":method:`~db.collection.drop()` method."
#~ msgstr ""

# d327dfd5561a43a18328c77f16b25dcd
#~ msgid ""
#~ "Capped collections created after 2.2 "
#~ "have an ``_id`` field and an index"
#~ " on the ``_id`` field by default. "
#~ "Capped collections created before 2.2 do"
#~ " not have an index on the "
#~ "``_id`` field by default. If you "
#~ "are using capped collections with "
#~ "replication prior to 2.2, you should "
#~ "explicitly create an index on the "
#~ "``_id`` field."
#~ msgstr ""

# e2c3b9520ca948a9812cad71b26e266b
#~ msgid ""
#~ "If you have a capped collection in"
#~ " a :term:`replica set` outside of the"
#~ " ``local`` database, before 2.2, you "
#~ "should create a unique index on "
#~ "``_id``. Ensure uniqueness using the "
#~ "``unique: true`` option to the "
#~ ":method:`~db.collection.ensureIndex()` method or by"
#~ " using an :term:`ObjectId` for the "
#~ "``_id`` field. Alternately, you can use"
#~ " the ``autoIndexId`` option to "
#~ ":dbcommand:`create` when creating the capped"
#~ " collection, as in the :ref:`capped-"
#~ "collections-options` procedure."
#~ msgstr ""

# 7a065ae7189742d29eef0edce02e743d
#~ msgid ""
#~ "You must create capped collections "
#~ "explicitly using the "
#~ ":method:`~db.createCollection()` method, which is"
#~ " a helper in the :program:`mongo` "
#~ "shell for the :dbcommand:`create` command. "
#~ "When creating a capped collection you"
#~ " must specify the maximum size of "
#~ "the collection in bytes, which MongoDB"
#~ " will pre-allocate for the "
#~ "collection. The size of the capped "
#~ "collection includes a small amount of"
#~ " space for internal overhead."
#~ msgstr ""

# 7e130d78cbc04f2cbfac42c046362b87
#~ msgid ""
#~ "Before 2.2, capped collections did not"
#~ " have an index on ``_id`` unless "
#~ "you specified ``autoIndexId`` to the "
#~ ":dbcommand:`create`, after 2.2 this became "
#~ "the default."
#~ msgstr ""

# 254a2b382bf84a1a938e809dc870eab0
#~ msgid ""
#~ "See :doc:`/tutorial/create-tailable-cursor` "
#~ "for information on creating a tailable"
#~ " cursor."
#~ msgstr ""

#~ msgid ""
#~ "You can only make in-place updates"
#~ " of documents. If the update "
#~ "operation causes the document to grow"
#~ " beyond their original size, the "
#~ "update operation will fail."
#~ msgstr ""

#~ msgid ""
#~ "If you update a document in a "
#~ "capped collection to a size smaller "
#~ "than its original size, and then a"
#~ " secondary resyncs from the primary, "
#~ "the secondary will replicate and "
#~ "allocate space based on the current "
#~ "smaller document size. If the primary"
#~ " then receives an update which "
#~ "increases the document back to its "
#~ "original size, the primary will accept"
#~ " the update but the secondary will"
#~ " fail with a ``failing update: "
#~ "objects in a capped ns cannot "
#~ "grow`` error message."
#~ msgstr ""

#~ msgid ""
#~ "To prevent this error, create your "
#~ "secondary from a snapshot of one "
#~ "of the other up-to-date members"
#~ " of the replica set. Follow :doc:`our"
#~ " tutorial on filesystem snapshots "
#~ "</tutorial/backup-with-filesystem-snapshots>` "
#~ "to seed your new secondary."
#~ msgstr ""

#~ msgid ""
#~ "Seeding the secondary with a filesystem"
#~ " snapshot is the only way to "
#~ "guarantee the primary and secondary "
#~ "binary files are compatible. MMS Backup"
#~ " snapshots are insufficient in this "
#~ "situation since you need more than "
#~ "the content of the secondary to "
#~ "match the primary."
#~ msgstr ""

