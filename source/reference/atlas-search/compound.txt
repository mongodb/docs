.. _compound-ref:

========
compound
========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. expression:: compound

   The ``compound`` operator combines two or more operators into a
   single query. Each element of a ``compound`` query is called a
   clause, and each clause consists of one or more sub-queries.

   Documents in the result set are returned with a match score, which
   is calculated by summing the score that each document received for
   each individual clause which generated a match. The result set is
   ordered by score, highest to lowest.

.. _compound-syntax:

Syntax
------

``compound`` has the following syntax:

.. code-block:: javascript
   :linenos:

   {
     $search: {
       "index": <index name>, // optional, defaults to "default"
       "compound": {
         <must | mustNot | should | filter>: [ { <clauses> } ]
       }
     }
   }

Each ``must``, ``mustNot``, ``should``, and ``filter`` clause contains an
array of sub-clauses. Use array syntax even if the array contains only one
sub-clause. See the :ref:`examples <compound-examples>` on this page.

.. _compound-options:

Options
-------

``compound`` uses the following terms to construct a query:

.. list-table::
   :widths: 15 85

   * - .. data:: must
     - Clauses which must match to produce results.

   * - .. data:: mustNot
     - Clauses which must not match for a document to be included in
       the results.

   * - .. data:: should
     - Clauses which cause documents in the result set to be
       scored higher if they match.

       ``minimumShouldMatch`` is an option of ``should``. If you use
       more than one ``should`` clause, you can use the
       ``minimumShouldMatch`` option to specify a minimum number of
       ``should`` clauses which must be satisfied for a document to
       be included in the result set.

       See an :ref:`example <min-example>`.

   * - .. data:: filter
     - Clauses which must all match all for a document to be
       included in the results. ``filter`` clauses do not contribute
       to a returned document's score.

       See an :ref:`example <filter-example>`.

Any of the above clauses may contain query criteria using any
top-level operator, such as :ref:`term <term-ref>`,
:ref:`search <search-ref>`, or :ref:`span <span-ref>`.

.. _compound-examples:

Examples
--------

The examples on this page use a collection called ``fruit`` which contains
the following documents:

.. code-block:: json
   :linenos:

   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   },
   {
     "_id" : 2,
     "type" : "banana",
     "description" : "Bananas are usually sold in bunches of five or six.",
     "category" : "nonorganic",
     "in_stock" : true
   },
   {
     "_id" : 3,
     "type" : "pear",
     "description" : "Bosc and Bartlett are the most common varieties of 
     pears.",
     "category" : "organic",
     "in_stock" : true
   }

The ``fruit`` collection has an |fts| index on the ``description``
field which uses the :ref:`standard <ref-standard-analyzer>` analyzer.
The ``standard`` analyzer lower-cases all words and disregards common
stop words (``"the", "a", "and",`` etc).

``must`` and ``mustNot`` Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example uses a combination of ``must`` and ``mustNot``
clauses to contruct a query. The ``must`` clause uses the 
:ref:`text <text-ref>` operator to search for the term ``varieties`` 
in the ``description`` field. For a document to match, it must fulfill 
the ``must`` clause. The ``mustNot`` clause performs a search operation 
for the term ``apples`` in the ``description`` field. For a document to
match, it must *not* fulfill the ``mustNot`` clause.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
               "query": "varieties",
               "path": "description"
             }
           }],
           "mustNot": [{
             "text": {
               "query": "apples",
               "path": "description"
             }
           }]
         }
       }
     }
   ])

The above query returns the document with ``_id: 3`` because its
``description`` field contains the word ``varieties`` and does not
contain ``apples``.

.. _must-should-example:

``must`` and ``should`` Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following query uses ``must`` to specify search conditions
which must be met and ``should`` to specify preference for documents
containing the word ``Fuji``. The ``$project`` pipeline stage excludes
all document fields except ``_id`` and adds a ``score`` field, which
displays the document's relevance score.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
               "query": "varieties",
               "path": "description"
             }
           }],
           "should": [{
             "text": {
               "query": "Fuji",
               "path": "description"
             }
           }]
         }
       }
     },
     {
       $project: {
         "score": { "$meta": "searchScore" }
       }
     }
   ])

The above query returns the following results:

.. code-block:: json
   :copyable: false

   { "_id" : 1, "score" : 0.6425117254257202 }
   { "_id" : 3, "score" : 0.21649497747421265 }

The document with ``_id: 1`` has a higher score because its
``description`` field contains the word ``Fuji``, satisfying the
``should`` clause.

.. _min-example:

minimumShouldMatch Example
~~~~~~~~~~~~~~~~~~~~~~~~~~

In a query with multiple ``should`` clauses, you can use the
``miniumumShouldMatch`` option to specify a minimum number of clauses
which must match to return a result.

The following query has one ``must`` clause and two ``should`` clauses,
with a ``minimumShouldMatch`` value of ``1``. A document must include
the term ``varieties`` in the ``description`` field and must include
either ``Fuji`` or ``Golden Delicious`` in the description field to be
included in the result set.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
                "query": "varieties",
                "path": "description"
             }
           }],
           "should": [
             {
               "text": {
                 "query": "Fuji",
                 "path": "description"
               }
             },
             {
               "text": {
                 "query": "Golden Delicious",
                 "path": "description"
               }
             }],
             "minimumShouldMatch": 1
           }
         }
       }
   ])

The above query returns the following result:

.. code-block:: json
   :copyable: false

   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   }

The document with ``_id: 1`` matches the ``must`` clause and the first
of the two ``should`` clauses.

.. _filter-example:

``filter`` Example
~~~~~~~~~~~~~~~~~~

``filter`` behaves the same as ``must``, except that the ``filter``
clause is not considered in a returned document's score, and therefore
does not affect the order of the returned documents.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
               "query": "varieties",
               "path": "description"
             }
           }],
           "should": [{
             "text": {
               "query": "banana",
               "path": "description"
             }
           }],
           "filter": [{
             "text": {
               "query": "granny",
               "path": "description"
             }
           }]
         }
       }
     }
   ])

The above query returns the following result:

.. code-block:: json
   :copyable: false

   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   }

The above document fulfills all the requirements for inclusion:

- Both the ``must`` clause and the ``filter`` clause match.
- The ``minimumShouldMatch`` value is not specified, so it defaults to
  ``0``, which allows the ``should`` clause to fail and still return
  a document.

Nested Example 
~~~~~~~~~~~~~~

The following example uses nested ``compound`` clauses to construct a 
query. For this example, the ``fruit`` collection has an index on the 
``type``, ``category``, and ``in_stock`` fields, whose text fields use the 
:ref:`default <ref-standard-analyzer>` analyzer. The query requires 
documents to only satisfy one of the following  ``should`` clauses: 

- Contain the word ``apple`` in the ``type`` field.
- Contain the term ``organic`` in the ``category`` field and have the 
  value ``true`` in the ``in_stock`` field.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "should": [
             {
               "text": {
                 "query": "apple",
                 "path": "type"
               }
             },
             {
               "compound": {
                 "must": [
                   {
                     "text": {
                       "query": "organic",
                       "path": "category"
                     }
                   },
                   {
                     "equals": {
                       "value": true,
                       "path": "in_stock"
                     }
                   }
                 ]
               }
             }
           ],
           "minimumShouldMatch": 1
         }
       }
     }
   ])

The above query returns the following result:

.. code-block:: json
   :copyable: false
   
   { 
     "_id" : 3, 
     "type" : "pear", 
     "description" : "Bosc and Bartlett are the most common varieties of pears.", 
     "category" : "organic", 
     "in_stock" : true 
   }
   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   }

The above document fulfills all the requirements for inclusion: 

- The document with ``_id: 3`` matches the ``must`` clause nested within 
  the second ``should`` clause.
- The document with ``_id: 1`` matches the first ``should`` clause.
