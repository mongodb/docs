.. _ref-path:

=================
Path Construction
=================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _ref-path-intro:

Overview 
--------

The ``path`` parameter is used by the |fts| 
:ref:`operators <query-syntax-ref>` to specify the field or fields
to be searched. It may contain:

- A string
- An array of strings
- A :ref:`multi analyzer <ref-multi-analyzer>` specification
- An array containing a combination of strings and multi analyzer
  specifications

.. _ref-path-usage:

Usage 
-----

To search only a single indexed field, use a quoted string in the
``path`` parameter. The following example searches a field named
``description``.

.. code-block:: javascript

   "path": "description"

To search multiple indexed fields, use an array of quoted strings
in the ``path`` parameter. Documents which match on any of the
specified fields are included in the result set. The following
example searches the ``description`` and ``type`` fields.

.. code-block:: javascript

   "path": ["description", "type"]

If your :ref:`index definition <index-config-example>` contains a field
with multiple analyzers, you can specify which one to use. The ``path``
parameter can take an object with the following fields:

.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - Field
     - Description

   * - ``value``
     - The name of the field to search.

   * - ``multi``
     - The name of the alternate analyzer specified in a
       ``multi`` object in an index definition.

In the following index definition, fields named ``names`` and ``notes``
use the :ref:`standard <ref-standard-analyzer>` analyzer.
A field named ``comments`` uses ``standard`` as its default analyzer, and
it also specifies a ``multi`` named ``mySecondaryAnalyzer`` which uses
the :ref:`lucene.whitespace <ref-whitespace-analyzer>` analyzer.

.. code-block:: json

   {
     "mappings": {
       "dynamic": false,
       "fields": {
         "names": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "notes": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "comments": {
           "type": "string",
           "analyzer": "lucene.standard",
           "multi": {
             "mySecondaryAnalyzer": {
               "analyzer": "lucene.whitespace",
               "type": "string"
             }
           }
         }
       }
     }
   }

The following ``path`` example searches the ``comments`` field using
the ``multi`` named ``mySecondaryAnalyzer`` in the index definition.

.. code-block:: javascript

   "path": { "value": "comments", "multi": "mySecondaryAnalyzer" }

To search a combination of indexed fields and fields with multiple
analyzers, use an array. The following example searches the
``names`` and ``notes`` fields with the default analyzer, and the
``comments`` field using the ``multi`` named
``mySecondaryAnalyzer`` in the index definition.

.. code-block:: javascript

   "path": [ "names", "notes", { "value": "comments", "multi": "mySecondaryAnalyzer" } ]

.. _ref-path-egs:

Examples
--------

.. _ref-path-static-egs:

Static Mapping Examples
~~~~~~~~~~~~~~~~~~~~~~~

The following examples use a collection named ``cars`` which has the
following documents:

.. code-block:: json

   {
     "_id" : 1,
     "type" : "sedan",
     "make" : "Toyota",
     "description" : "Blue four-door sedan, lots of trunk space. Three to four 
     passengers."
   }
   { 
     "_id" : 2,
     "type" : "coupe",
     "make" : "BMW",
     "description" : "Red two-door convertible, driver's-side airbag."
   }
   { 
     "_id" : 3,
     "type" : "SUV",
     "make" : "Ford",
     "description" : "Black four-door SUV, three rows of seats."
   }

.. _ref-multi-analyzer:

:ref:`Static field mappings <static-dynamic-mappings>` allow you to
specify how individual fields within a collection should be indexed
and searched.

The index definition for the ``cars`` collection is as follows:

.. code-block:: json

   {
     "mappings": {
       "dynamic": false,
       "fields": {
         "make": {
           "type": "string",
           "analyzer": "lucene.standard"
         },
         "description": {
           "type": "string",
           "analyzer": "lucene.standard",
           "multi": {
             "simpleAnalyzer": {
               "analyzer": "lucene.simple",
               "type": "string"
             }
           }
         }
       }
     }
   }

The preceding index definition specifies that the ``make`` field is
indexed with the :ref:`standard analyzer <ref-standard-analyzer>`.
The ``description`` field uses the ``standard`` analyzer by
default, but it can also use the :ref:`simple analyzer
<ref-simple-analyzer>` by specifying ``simpleAnalyzer`` with the
``multi`` parameter.

.. _ref-path-single-field-egs:

Single Field Search
~~~~~~~~~~~~~~~~~~~

The following example searches for the string ``Ford`` in the
``make`` field:

.. code-block:: javascript

   db.cars.aggregate([
     {
       $searchBeta: {
         "search": { 
           "query": "Ford", 
           "path": "make"
         }
       }
     }
   ])

The preceding example returns the document with ``_id: 3``.

.. _ref-path-multi-field-egs:

Multiple Field Search
~~~~~~~~~~~~~~~~~~~~~

The following example uses an array of fields in the ``path``
parameter to search for the string ``blue`` in either the ``make``
or the ``description`` field.

.. code-block:: javascript

   db.cars.aggregate([
     {
       $searchBeta: {
         "search": { 
           "query": "blue", 
           "path": [ "make", "description" ]
         }
       }
     }
   ])

The preceding query returns the following result:

.. code-block:: json
   :copyable: false

   { 
     "_id" : 1,
     "type" : "sedan",
     "make" : "Toyota",
     "description" : "Blue four-door sedan, lots of trunk space. Three to four 
     passengers."
   }

.. _ref-path-alt-analyzer-egs:

Alternate Analyzer Search
~~~~~~~~~~~~~~~~~~~~~~~~~

Simple analyzer Example 
#######################

The following example uses the ``multi`` named ``simpleAnalyzer``
in the index definition, which uses the :ref:`simple analyzer
<ref-simple-analyzer>`. 

The query searches the ``description`` field for the string ``driver``.

.. code-block:: javascript

   db.cars.aggregate([
     {
       $searchBeta: {
         "search": { 
           "query": "driver", 
           "path": { "value": "description", "multi": "simpleAnalyzer" }
         }
       }
     }
   ])

The preceding query returns the following result:

.. code-block:: json
   :copyable: false

   {
     "_id" : 2,
     "type" : "coupe",
     "make" : "BMW",
     "description" : "Red two-door convertible, driver's-side airbag."
   }

The :ref:`simple analyzer <ref-simple-analyzer>` indexes ``driver's
side airbag`` as ``[driver s side airbag``], so it matches on ``driver``.

By contrast, the default :ref:`standard analyzer <ref-standard-analyzer>` 
indexes ``driver's side airbag`` as ``[driver's side airbag``], so it would 
match on ``driver's`` or ``side`` but not ``driver``.

Whitespace Analyzer Example 
###########################

Suppose the ``multi`` object in the index definition for the ``cars`` 
collection is the following:

.. code-block:: json 

   "multi": {
     "simpleAnalyzer": {
       "analyzer": "lucene.whitespace",
       "type": "string"
     }
   }

The following example uses the ``multi`` named ``simpleAnalyzer``
in the index definition, which uses the :ref:`whitespace analyzer
<ref-whitespace-analyzer>`. 

.. code-block:: json 

   db.cars.aggregate([
     {
       $searchBeta: {
         "text": {
           "query": "Three",
           "path": { "value": "description", "multi": "simpleAnalyzer" }
         }
       }
     }
   ])

The preceding query returns the following result:

.. code-block:: json
   :copyable: false

   { 
     "_id" : 1, 
     "type" : "sedan", 
     "make" : "Toyota", 
     "description" : "Blue four-door sedan, lots of trunk space. Three to 
     four passengers." 
   }

For the above query on the term ``Three``, |fts| only returns documents 
matching the term ``Three`` and not ``three`` becuase the 
:ref:`whitespace analyzer <ref-simple-analyzer>` is case-sensitive. By 
contrast, the default :ref:`standard analyzer <ref-standard-analyzer>` is 
not case-sensitive and returns all documents matching the term in the 
query in the order that they are listed in the collection. 

Now, consider the following query:

.. code-block:: json 

   db.cars.aggregate([
     {
       $searchBeta: {
         "compound": {
           "should": [
             { 
               "text": { 
                 "path": "description", 
                 "query": "Three" 
               }
             },
             {
               "text": {
                 "query": "Three",
                 "path": {"value" : "description", "multi" : "simpleAnalyzer"},
                 score: { boost: { value: 2 }}
               }
             }
           ]
         }
       }
     },
     {
       $project: {
         "_id": 0,
         "type": 1,
         "description": 1,
         "score": { "$meta": "searchScore" }
       }
     }
   ])

The preceding query returns the following results:

.. code-block:: json
   :copyable: false

   { 
     "type" : "sedan", 
     "description" : "Blue four-door sedan, lots of trunk space. Three to four passengers seats.", 
     "score" : 1.1092689037322998 
   }
   { 
     "type" : "SUV", 
     "description" : "Black four-door SUV, three rows of seats.", 
     "score" : 0.17812025547027588 
   }

For the above query, |fts| returns documents with both ``Three`` and 
``three``. However, the score of the result with ``Three`` is higher 
because while the document with ``three`` was matched using the default 
:ref:`standard analyzer <ref-standard-analyzer>`, the document with 
``Three`` was matched by both the specified ``simpleAnalyzer`` and the 
default :ref:`standard analyzer <ref-standard-analyzer>`.

.. _ref-path-dynamic-egs:

Dynamic Mappings Example
~~~~~~~~~~~~~~~~~~~~~~~~

The following example uses a collection called ``posts`` with the
following documents:

.. code-block:: json

   { 
    "_id": 1, 
    "username": "pinto",
    "post": {
      "date": "12-03-2018",
      "forum": "Tofu Recipes",
      "body": "Spicy Garlic Tofu cooks up crispy in 10 minutes or less.
               Serve with broccoli and rice for a delicious vegetarian meal."
    }
  }
  { 
    "_id": 2, 
    "username": "paloma",
    "post": {
      "date": "12-08-2018",
      "forum": "Tofu Recipes",
      "body": "Crispy Tofu in Shiitake Broth has flavors of citrus and
               umami. Great as an appetizer or entree."
    }
  }

:ref:`Dynamic field mappings <static-dynamic-mappings>` allow
you to index all fields in a collection as needed.

The index definition for the ``posts`` collection is as follows:

.. code-block:: json

   {
     "mappings": {
       "dynamic": true
     }
   }

.. _ref-path-nested-field-egs:

Nested Field Example
~~~~~~~~~~~~~~~~~~~~

The following :ref:`compound query <compound-ref>` searches the field
``post.body`` for the string ``broccoli``, and also specifies that the
field must not contain the string ``cauliflower``.

.. code-block:: javascript

   db.posts.aggregate([
     {
       $searchBeta: {
         "compound": {
           "must": {
             "search": {
               "query": "broccoli",
               "path": "post.body"
             }
           },
           "mustNot": {
             "search": {
               "query": "cauliflower",
               "path": "post.body"
             }
           }
         }
       }
     }
   ])

The preceding query returns the document with ``_id: 1``, in which the
``posts.body`` field contains the string ``broccoli``.
