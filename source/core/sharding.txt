.. index:: fundamentals; sharding
.. _sharding-fundamentals:

=================
Sharding Overview
=================

.. default-domain:: mongodb

Sharding is MongoDBâ€™s approach to scaling out. Sharding partitions
database collections and stores the different portions of a collection
on different machines. When your collections become too large for
existing storage, you need only add a new machine and MongoDB
automatically distributes data to the new server.

Sharding automatically balances the data and load across machines. By
splitting a collection across multiple machines, sharding increases
write capacity, provides the ability to support larger working sets, and
raises the limits of total data size beyond the physical resources of a
single node.

How Sharding Works
------------------

Sharding is enabled on a per-database basis. Once a database is enabled
for sharding, you then choose which collections to shard.

MongoDB distributes documents among :term:`shards <shard>` based on the
value of the :ref:`shard key <sharding-shard-key>`. Each :term:`chunk`
represents a block of :term:`documents <document>` with values that fall
within a specific range. When chunks grow beyond the :ref:`chunk size
<sharding-chunk-size>`, MongoDB divides the chunks into smaller chunks
(i.e. :term:`splitting <split>`) based on the shard key.

The sharding system automatically balances data across the cluster
without intervention from the application layer. Effective automatic
sharding depends on a well chosen :ref:`shard key <sharding-shard-key>`,
but requires no additional complexity, modifications, or intervention
from developers.

Sharding is completely transparent to the application layer, because all
connections to a cluster go through :program:`mongos`. Sharding in
MongoDB requires some :ref:`basic initial configuration
<sharding-procedure-setup>`, but ongoing function is entirely
transparent to the application.

Sharding increases capacity in two ways:

#. Effective partitioning of data can provide additional write
   capacity by distributing the write load over a number of
   :program:`mongod` instances.

#. Given a shard key with sufficient :ref:`cardinality
   <sharding-shard-key-cardinality>`, partitioning data allows users to
   increase the potential amount of data to manage with MongoDB and
   expand the :term:`working set`.

.. index:: shard key
   single: sharding; shard key

.. _sharding-shard-key:
.. _shard-key:

Shard Keys
----------

MongoDB distributes documents among :term:`shards <shard>` based on
:term:`shard keys <shard key>`. A shard key must be :term:`field` that
exists in every :term:`document` in the collection. Shard keys, like
:term:`indexes <index>`, can be either a single field, or may be a
compound key, consisting of multiple fields.

MongoDB's sharding is range-based. Each :term:`chunk` holds
documents having specific range of values for the "shard key". Thus,
choosing the correct shard key can have a great impact on the
performance, capability, and functioning of your database and cluster.

Appropriate shard key choice depends on the schema of your data and
the way that your application queries and writes data to the database.

The ideal shard key:

- is easily divisible which makes it easy for MongoDB to distribute
  content among the shards. Shard keys that have a limited number of
  possible values are not ideal as they can result in some chunks that
  are "unsplitable." See the :ref:`sharding-shard-key-cardinality`
  section for more information.

- will distribute write operations among the cluster, to prevent any
  single shard from becoming a bottleneck. Shard keys that have a high
  correlation with insert time are poor choices for this reason;
  however, shard keys that have higher "randomness" satisfy this
  requirement better. See the :ref:`sharding-shard-key-write-scaling`
  section for additional background.

- will make it possible for the :program:`mongos` to return most query
  operations directly from a single *specific* :program:`mongod`
  instance. Your shard key should be the primary field used by your
  queries, and fields with a high degree of "randomness" are poor
  choices for this reason. See the :ref:`sharding-shard-key-query-isolation`
  section for specific examples.

The challenge when selecting a shard key is that there is not always
an obvious choice. Often, an existing field in your collection may not be
the optimal key. In those situations, computing a special purpose
shard key into an additional field or using a compound shard key may
help produce one that is more ideal.

.. index:: balancing
.. _sharding-balancing:

Balancing and Distribution
--------------------------

Balancing is the process MongoDB uses to redistribute data within a
:term:`sharded cluster`. When a :term:`shard` has a too many:
term:`chunks <chunk>` when compared to other shards, MongoDB balances
the shards.

The
balancing process attempts to minimize the impact that balancing can
have on the cluster, by:

- Moving only one chunk at a time.

- Only initiating a balancing round when the difference in number of
  chunks between the shard with the greatest and the shard with the
  least number of chunks exceeds the :ref:`migration threshold
  <sharding-migration-thresholds>`.

You may disable the balancer on a temporary basis for
maintenance and limit the window during which it runs to prevent the
balancing process from impacting production traffic.

.. seealso:: :ref:`sharding-balancing-operations` and
   :ref:`sharding-balancing-internals`.

.. note::

   The balancing procedure for :term:`sharded clusters <sharded cluster>`
   is entirely transparent to the user and application layer. This
   documentation is only included for your edification and possible
   troubleshooting purposes.
