.. _read-operations-indexing:
.. _optimize-query-performance:

==================
Query Optimization
==================

.. meta::
   :description: Optimize MongoDB queries by creating indexes, using projections, limiting results, and utilizing covered queries.

.. facet::
   :name: genre
   :values: reference

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

.. dismissible-skills-card::
   :skill: Query Optimization
   :url: https://learn.mongodb.com/skills?openTab=query

Query optimization improves the efficiency of read operations by 
reducing the amount of data that query operations need to process. 
Use indexes, projections, and query limits to enhance query 
performance and reduce resource consumption.

Create Indexes to Support Queries
---------------------------------

Create :ref:`indexes <indexes>` for commonly issued queries. If a query
searches multiple fields, create a :ref:`compound index
<index-type-compound>`. Using an index improves performance because
without an index the query must scan every document in the collection.

For example, consider the following query on the ``type`` field in the
``inventory`` collection:

.. code-block:: javascript

   let typeValue = <someUserInput>;
   db.inventory.find( { type: typeValue } );

To improve performance for this query, add an index to the ``inventory``
collection on the ``type`` field. [#ensureIndexOrder]_ In
:binary:`~bin.mongosh`, create indexes using the
:method:`db.collection.createIndex()` method:

.. code-block:: javascript

   db.inventory.createIndex( { type: 1 } )

To analyze query performance, see :doc:`/tutorial/analyze-query-plan`.

.. [#ensureIndexOrder]
   For single-field indexes, the order of the index does not matter. For
   compound indexes, the field order impacts what queries the index
   supports. For details, see :ref:`index-ascending-and-descending`.

.. _read-operations-query-selectivity:

Create Selective Queries
------------------------

Query selectivity refers to how well the query predicate filters out
documents in a collection. Query selectivity determines whether queries
can use indexes effectively.

More selective queries match a smaller percentage of documents. For
instance, an equality match on the unique ``_id`` field is highly
selective as it can match at most one document.

Less selective queries match a larger percentage of documents and
cannot use indexes effectively.

.. include:: /includes/extracts/inequality_operators_selectivity.rst

The selectivity of :query:`regular expressions <$regex>` depends on the
expressions themselves. For details, see :ref:`regular expression and
index use <regex-index-use>`.

Project Only Necessary Data
---------------------------

When you need a subset of fields from documents, you can improve
performance by returning only the fields you need. Projections reduce
network traffic and processing time.

For example, if your query to the ``posts`` collection needs only the
``timestamp``, ``title``, ``author``, and ``abstract`` fields, specify
those fields in the projection:

.. code-block:: javascript

   db.posts.find( 
      {}, 
      { timestamp : 1, title : 1, author : 1, abstract : 1} 
   ).sort( { timestamp : -1 } )

.. |$project| replace:: :pipeline:`$project` aggregation

.. include:: /includes/aggregation/fact-project-stage-placement.rst

For more information on using projections, see
:ref:`read-operations-projection`.

Limit Query Results
-------------------

MongoDB :term:`cursors <cursor>` return results in batches. If you know
the number of results you want, specify that value in the
:method:`~cursor.limit()` method. Limiting results reduces the demand on
network resources.

Generally, limiting results is most useful when results are sorted so
you know which documents will be returned. For example, if you need only
10 results from your query to the ``posts`` collection, run the
following query:

.. code-block:: javascript

   db.posts.find().sort( { timestamp : -1 } ).limit(10)

For more information on limiting results, see :method:`~cursor.limit()`.

Use Index Hints
---------------

The :ref:`query optimizer <read-operations-query-optimization>`
typically selects the optimal index for a specific operation. However,
you can force MongoDB to use a specific index using the
:method:`~cursor.hint()` method. Use :method:`~cursor.hint()` to support
performance testing or when you are querying a field that appears in
several indexes to guarantee that MongoDB uses the correct index.

Use Server-Side Operations
--------------------------

Use MongoDB's :update:`$inc` operator to increment or decrement
values in documents. The operator increments the value of the field on
the server side, as an alternative to selecting a document, making
simple modifications in the client, and then writing the entire
document to the server. The :update:`$inc` operator can also help
avoid race conditions that occur when two application instances query
for a document, manually increment a field, and save the entire
document back at the same time.

.. _covered-queries:
.. _indexes-covered-queries:
.. _read-operations-covered-query:

Run Covered Queries
-------------------

A covered query is a query that can be satisfied entirely using an 
index and does not have to examine any documents. An index covers a 
query when all of the following apply:

- All the fields in the query (both as specified by the application and
  as needed internally such as for sharding purposes) are part of an
  index.

- All the fields returned in the results are in the same index.

- No fields in the query are equal to ``null``. For example, the
  following query predicates cannot result in covered queries:
  
  - ``{ "field": null }``
  - ``{ "field": { $eq: null } }``

Example
~~~~~~~

An ``inventory`` collection has the following index on the ``type`` and
``item`` fields:

.. code-block:: javascript

   db.inventory.createIndex( { type: 1, item: 1 } )

The index covers the following operation which queries on the ``type``
and ``item`` fields and returns only the ``item`` field:

.. code-block:: javascript

   db.inventory.find(
      { type: "food", item:/^c/ },
      { item: 1, _id: 0 }
   )

For the specified index to cover the query, the projection document
must explicitly specify ``_id: 0`` to exclude the ``_id`` field from
the result since the index does not include the ``_id`` field.

Embedded Documents
~~~~~~~~~~~~~~~~~~

An index can cover a query on fields within embedded documents.

For example, consider a ``userdata`` collection with documents of the
following form:

.. code-block:: javascript

   db.userdata.insertOne(
      { _id: 1, user: { login: "tester" } }
   )

The collection has the following index:

.. code-block:: javascript

   db.userdata.createIndex(
      { "user.login": 1 }
   )

The ``{ "user.login": 1 }`` index covers the following query:

.. code-block:: javascript

   db.userdata.find(
      { "user.login": "tester" },
      { "user.login": 1, _id: 0 }
   )

.. note::

   To index fields in embedded documents, use :term:`dot notation`. See
   :ref:`index-embedded-fields`.

.. _multikey-covering:

Multikey Covering
~~~~~~~~~~~~~~~~~

Multikey indexes can cover queries over the non-array fields
if the index tracks which field or fields cause the index to be multikey.

.. include:: /includes/fact-multikey-index-covered-query.rst

For an example of a covered query with a multikey index, see
:ref:`multikey-covered-queries` on the multikey indexes page.

Performance
~~~~~~~~~~~

Because the index contains all fields required by the query, MongoDB can both
match the :ref:`query conditions <read-operations-query-document>`
and return the results using only the index.

Querying *only* the index can be much faster than querying documents
outside of the index. Index keys are typically smaller than the
documents they catalog, and indexes are typically available in RAM or
located sequentially on disk.

Limitations
~~~~~~~~~~~

Index Types
```````````

Not all :ref:`index types <index-types>` can cover queries. For details
on covered index support, refer to the documentation page for the
corresponding index type.

.. _covered-index-sharded-collection:

Sharded Collections
```````````````````

.. include:: /includes/extracts/fact-covered-query-sharded-collection-cover.rst

Explain Results
~~~~~~~~~~~~~~~

To determine whether a query is a covered query, use the
:method:`db.collection.explain()` or the :method:`~cursor.explain()`
method. See :ref:`explain-output-covered-queries`.

.. toctree::
   :titlesonly:

   Analyze Performance </tutorial/evaluate-operation-performance>
   Write Performance </core/write-performance>
