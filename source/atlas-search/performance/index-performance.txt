.. _index-perf:

=================
Index Performance
=================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 3
   :class: singlecol

Resource Requirements
---------------------

.. _index-size-and-config:

Index Size and Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. important::
   
   If you create an |fts| index for a collection that has or will soon 
   have more than two billion documents, you must 
   :ref:`shard your cluster <create-cluster-sharding>`.

When you :ref:`create <ref-create-index>` an |fts| index, the default
configuration sets field mapping to :ref:`dynamic
<static-dynamic-mappings>`, which means that all the data in your
collection is actively added to your |fts| index. Other options
such as enabling highlights can also result in your index taking up more
disk space. You can reduce the size and performance footprint of your
|fts| index by:

- Specifying a custom :ref:`index definition
  <ref-index-definitions>` to narrow the amount and type of data that is
  indexed.

- Setting the ``store`` option to ``false`` when specifying a 
  :ref:`string <bson-data-types-string>` type in an index definition.

.. note::

   Some limitations apply to |fts| on ``M0``, ``M2``, and ``M5``
   clusters only. To learn more, see 
   :ref:`Atlas Search Free and Shared Tier Limitations 
   <atlas-fts-shared-tier-limitations>`.

Considerations
``````````````

Some index configuration options can lead to indexes that take up a 
significant proportion of your disk space. In some cases, your index 
could be many times larger than the size of your data. Although this is 
expected behavior, it's important to be aware of the following 
indexing-intensive features:

Autocomplete
++++++++++++

The :ref:`bson-data-types-autocomplete` |fts| field type can cause 
large indexes, especially in the following cases:

- Using ``nGram`` tokenization.
- Setting a wide ``minGrams`` to ``maxGrams``  range.
- Setting a ``minGram`` value of ``1`` on a collection with millions of 
  documents.

``multi`` Analyzers
+++++++++++++++++++

Using a ``multi`` analyzer to analyze the same field multiple 
different ways can cause large indexes, especially when analyzing 
fields with very long values.

Synonym Collections
+++++++++++++++++++

Inserts and updates to a synonym source collection are fast only if the 
synonym source collection is small. For best performance, we recommend 
batching inserts and updates to synonym source collections. 

A :ref:`synonym mapping <synonyms-ref>` definition doesn't require 
additional disk space aside from the disk space utilized by the synonym 
collection in the database. However, synonym mappings create artifacts 
in memory and therefore, for synonym collections with many documents, 
|fts| creates artifacts that occupy more memory.

.. _index-create-and-update:

Creating and Updating an Atlas Search Index
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Creating an |fts| index is resource-intensive. The performance of your
|service| cluster may be impacted while the index builds. 

|service| replicates all writes on the collection. This means that for 
each collection with |fts| indexes, the writes are amplified to the 
amount of |fts| indexes defined for that collection. 

In some instances, your |fts| index must be rebuilt. Rebuilding the 
|fts| index also consumes resources and may affect database 
performance. |fts| automatically rebuilds the index only in the event 
of:

- :ref:`Changes <ref-edit-index>` to the index definition
- |fts| version updates that include breaking changes
- Hardware-related problems such as index corruption

.. note:: 

   |fts| supports no-downtime indexing, which means you can continue to 
   run search queries while |fts| rebuilds your index. |fts| keeps your 
   old index up-to-date while the new index is being built. We 
   recommend allocating *free* disk space equal to 125% of the disk 
   space used by your old index for this operation. You can view the 
   amount of disk space currently used by your index in the 
   :doc:`Search Disk Space Used </review-atlas-search-metrics/>` 
   metric.

   If your index rebuild fails due to insufficient disk space, we 
   recommend that you temporarily expand your cluster capacity to meet 
   the increased demand. You can make this change manually as described in 
   :doc:`Fix Storage Issues </reference/alert-resolutions/disk-space-used/>`, 
   even for clusters with autoscaling enabled.

   Once |fts| rebuilds the index, the old index is automatically 
   replaced without any further action from your side.

.. _index-eventual-consistency-and-latency:

Eventual Consistency and Indexing Latency 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

|fts| supports eventual consistency and does not provide any stronger 
consistency guarantees. This means that data inserted into a MongoDB 
collection and indexed by |fts| will not be available immediately for 
``$search`` queries.

|fts| reads data from MongoDB :manual:`change streams 
</changeStreams/>` and indexes that data in an asynchronous process. 
This process is typically very fast, but may sometimes be impacted by 
replication latency, system resource availability, and index definition 
complexity.

.. _index-document-mapping-explosions:

Document Mapping Explosions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

`Mapping explosions <https://en.wikipedia.org/wiki/Combinatorial_explosion#:~:text=In%20mathematics%2C%20a%20combinatorial%20explosion,the%20intractability%20of%20certain%20problems>`__
occur when |fts| indexes a document with arbitrary 
keys and you have a :ref:`dynamic mapping <static-dynamic-mappings>`. 
The ``mongot`` process might consume increasing amounts of memory and 
could crash. If you add too many fields to an index, mapping explosions 
can occur. To address this issue, you can upgrade your cluster or use a 
:ref:`static mapping <static-dynamic-mappings>` that does not index all 
fields in your data.

When searching over fields using a wildcard path, design your search to use 
a tuple-like schema. If you perform a wildcard path search that uses a 
key-value schema, |fts| indexes each key as its own field, 
which can cause mapping explosions.

.. example::

   An example of a key-value schema 
   is as follows:

   .. code-block::

      ruleBuilder: {
        ruleName1: <data>, 
        ruleName2: <data>,
        ..... 
        ruleName1025: <data>
      }
   
   An example of the same data
   restructured to use a tuple-like schema is as follows:

   .. code-block::

      {
        ruleBuilder: [
          {name: ruleName1, data: <data>},
          {name: ruleName2, data: <data>},
          ...
          {name: ruleName1025, data: <data>}
        ]
      } 

.. _perf-ref-stored-source:

Storing Source Fields 
~~~~~~~~~~~~~~~~~~~~~

You can :ref:`configure <fts-stored-source-definition>` fields to 
store on |fts| and improve performance of subsequent aggregation 
pipeline stages like :pipeline:`$sort`, :pipeline:`$match`, 
:pipeline:`$group`, and :pipeline:`$skip`. Use this optimization if 
your original documents and matched dataset are so large that a full 
data lookup is inefficient. To learn more about storing specific fields 
on |fts| and returning those stored fields only, see 
:ref:`fts-stored-source-definition` and 
:ref:`fts-return-stored-source-option`.

We recommend storing only the minimum number of fields required for 
subsequent stages. If necessary, you can use :pipeline:`$lookup` at 
the end of the pipeline stage to retrieve entire documents as shown in 
the :ref:`fts-return-stored-source-egs`. Storing unnecessary fields 
increases disk utilization and could negatively impact performance 
during indexing and querying. 

Scaling Considerations
----------------------

.. _index-fts-upgrade:

|fts| Upgrade 
~~~~~~~~~~~~~

|fts| is deployed on your |service| cluster. When a new version of 
|fts| is deployed, your |service| cluster might experience brief 
network failures in returning query results. To mitigate issues during 
deployment and minimize impact to your application, consider the 
following: 

- Implement retry logic in your application.
- Configure |service| :ref:`maintenance windows 
  <configure-maintenance-window>`.

To learn more about the changes in each release, see :doc:`Atlas 
Search Changelog </atlas-search/changelog/>`.

.. _index-scaling-up-perf:

Scaling Up Indexing Performance 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can scale up your initial sync and steady state indexing for an 
|fts| index by upgrading your cluster to a higher :ref:`tier 
<create-cluster-instance>` with more cores. |fts| uses a percentage of 
all available cores to run both initial sync and steady state indexing 
and performance improves as new cores are made available by upgrading 
your cluster.
