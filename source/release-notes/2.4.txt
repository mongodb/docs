======================================================
Release Notes for MongoDB 2.4 (2.3 Development Series)
======================================================

.. default-domain:: mongodb

MongoDB 2.4 is currently in development, as part of the 2.3
development release series. While 2.3-series releases are currently
available, these versions of MongoDB, including the 2.4 release 
candidate builds, are for *testing only and
not for production use*.

This document will eventually contain the full release notes for
MongoDB 2.4; before its release this document covers the 2.3
development series as a work-in-progress.

.. contents:: See the :doc:`full index of this page <2.4-changes>` for
              a complete list of changes included in 2.4.
   :backlinks: none
   :local:
   :depth: 3

Downloading
-----------

You can download the 2.4 release candidate on the `downloads page`_ in the
:guilabel:`Development Release (Unstable)` section. There are no
distribution packages for development releases, but you can use the
binaries provided for testing purposes. See
:doc:`/tutorial/install-mongodb-on-linux`,
:doc:`/tutorial/install-mongodb-on-windows`, or
:doc:`/tutorial/install-mongodb-on-os-x` for the basic installation
process.

.. _`downloads page`: http://www.mongodb.org/downloads

Upgrade Process
---------------

.. toctree::
   :hidden:

   /release-notes/2.4-upgrade

See :doc:`/release-notes/2.4-upgrade` for full upgrade instructions.

Supported Platforms
-------------------

MongoDB 2.4 only supports OS X versions 10.6 (Snow Leopard) and later.

Changes
-------

Major Features
++++++++++++++

Text Indexes
~~~~~~~~~~~~

.. note::

   The ``text`` index type is currently an experimental feature.
   To use a ``text`` index, you need to enable it at run time or
   startup.

Background
``````````

MongoDB 2.4 includes a new ``text`` index type. ``text`` indexes
support boolean text search queries:

- Any set of fields containing string data may be text indexed.

- You may only maintain a **single** ``text`` index per collection.

- ``text`` indexes are fully consistent and updated in real-time as
  applications insert, update, or delete documents from the database.

- The ``text`` index and query system supports language specific
  stemming and stop words. Additionally:

  - Indexes and queries drop stop words (i.e. "the," "an," "a," "and,"
    etc.)

  - MongoDB stores words stemmed during insertion, using simple suffix
    stemming, and includes support for a number of languages. MongoDB
    automatically stems :dbcommand:`text` queries before beginning the
    query.

However, ``text`` indexes have large storage requirements and incur
**significant** performance costs:

- Text indexes can be large. They contain one index entry for each
  unique post-stemmed word in each indexed field for each document
  inserted.

- Building a ``text`` index is very similar to building a large
  multi-key index, and therefore may take longer than building a
  simple ordered (scalar) index.

- ``text`` indexes will impede insertion throughput, because MongoDB
  must add an index entry for each unique post-stemmed word in each
  indexed field of each new source document.

- Some :dbcommand:`text` searches may affect performance on your
  :program:`mongod`, particularly for negation queries and phrase
  matches that cannot use the index as effectively as other kinds of
  queries.

Additionally, the current *experimental* implementation of ``text``
indexes have the following limitations and behaviors:

- ``text`` indexes do not store phrases or information about the
  proximity of words in the documents. As a result, phrase queries
  will run much more effectively when the entire collection fits in
  RAM.

- MongoDB does not stem phrases or negations in :dbcommand:`text`
  queries.

- The index is case-insensitive.

- A collection may only have a single ``text`` index at a time.

.. warning::

   Do **not** enable or use ``text`` indexes on production systems.

.. May be worth including this:

   For production-grade search requirements consider using a
   third-party search tool, and the `mongo-connector
   <https://github.com/10gen-labs/mongo-connector>`_ or a similar
   integration strategy to provide more advanced search capabilities.

Test ``text`` Indexes
`````````````````````

The ``text`` index type is an experimental feature and you need to
enable the feature before creating or accessing a text index.

To enable text indexes, issue the following command in the
:program:`mongo` shell:

.. warning::

   Do **not** enable or use ``text`` indexes on production systems.

.. code-block:: javascript

   db.adminCommand( { setParameter: 1, textSearchEnabled: 1 } )

You can also start the :program:`mongod` with the following
invocation:

.. code-block:: sh

   mongod --setParameter textSearchEnabled=1

Create Text Indexes
^^^^^^^^^^^^^^^^^^^

To create a ``text`` index, use the following syntax of
:method:`~db.collection.ensureIndex()`:

.. code-block:: javascript

   db.collection.ensureIndex( { <field>: "text" } )

Consider the following example:

.. code-block:: javascript

   db.collection.ensureIndex( { content: "text" } )

This ``text`` index catalogs all string data in the ``content`` field
where the ``content`` field contains a string or an array of string
elements. To index fields in sub-documents, you need to specify the
individual fields from the sub-documents using the :term:`dot
notation`. A ``text`` index can include multiple fields, as in the
following:

.. code-block:: javascript

   db.collection.ensureIndex( { content: "text",
                                "users.comments": "text",
                                "users.profiles": "text" } )

The default name for the index consists of the ``<field name>``
concatenated with ``_text`` for the indexed fields, as in the following:

.. code-block:: javascript

   "content_text_users.comments_text_users.profiles_text"

These indexes may run into the :limit:`Index Name Length` limit. To
avoid creating an index with a too-long name, you can specify a name
in the options parameter, as in the following:

.. code-block:: javascript

   db.collection.ensureIndex( { content: "text",
                                "users.profiles": "text" },
                              { name: "TextIndex" } )

When creating ``text`` indexes you may specify *weights* for specific
fields. *Weights* are factored into the relevant score for each
document. The score for a given word in a document is the weighted sum
of the frequency for each of the indexed fields in that document.
Consider the following:

.. code-block:: javascript

   db.collection.ensureIndex( { content: "text",
                                "users.profiles": "text" },
                              { name: "TextIndex",
                                weights: { content: 1,
                                           "users.profiles": 2 } } )

This example creates a ``text`` index on the top-level field named
``content`` and the ``profiles`` field in the ``users``
sub-documents. Furthermore, the ``content`` field has a weight of 1 and
the ``users.profiles`` field has a weight of 2.

You can add a conventional ascending or descending index field(s) as a
prefix or suffix of the index. You cannot include :ref:`multi-key
<index-type-multi-key>` index field nor :ref:`geospatial
<index-feature-geospatial>` index field.

If you create an ascending or descending index as a prefix of a
``text`` index:

- MongoDB will only index documents that have the prefix field
  (i.e. ``username``) and

- The :dbcommand:`text` query can limit the number of index entries to
  review in order to perform the query.

- All :dbcommand:`text` queries using this index must include the
  ``filter`` option that specifies an equality condition for the prefix
  field or fields.

Create this index with the following operation:

.. code-block:: javascript

   db.collection.ensureIndex( { username: 1,
                                "users.profiles": "text" } )

Alternatively you create an ascending or descending index as a suffix
to a ``text`` index. Then the ``text`` index can support
:ref:`covered queries <indexes-covered-queries>` if the
:dbcommand:`text` command specifies a ``project`` option.

Create this index with the following operation:

.. code-block:: javascript

   db.collection.ensureIndex( { "users.profiles": "text",
                                username: 1 } )

Finally, you may use the special wild card field specifier (i.e.
``$**``) to specify index weights and fields. Consider the following
example that indexes any string value in the data of every field of
every document in a collection and names it ``TextIndex``:

.. code-block:: javascript

   db.collection.ensureIndex( { "$**": "text",
                                username: 1 },
                              { name: "TextIndex" } )

By default, an index field has a weight of ``1``. You may specify
weights for a ``text`` index with compound fields, as in the following:

.. code-block:: javascript

   db.collection.ensureIndex( { content: "text",
                                "users.profiles": "text",
                                comments: "text",
                                keywords: "text",
                                about: "text" },
                              { name: "TextIndex",
                                weights:
                                { content: 10,
                                  "user.profiles": 2,
                                  keywords: 5,
                                  about: 5 } } )

This index, named ``TextIndex``, includes a number of fields, with the
following weights:

- ``content`` field that has a weight of 10,
- ``users.profiles`` that has a weight of 2,
- ``comments`` that has a weight of 1,
- ``keywords`` that has a weight of 5, and
- ``about`` that has a weight of 5.

This means that documents that match words in the ``content`` field
will appear in the result set more than all other fields in the index,
and that the ``user.profiles`` and ``comments`` fields will be less
likely to appear in responses than words from other fields.

.. note::

   You must drop a ``text`` index using the name specified when you
   created the index. Alternatively, if you did not specify a name
   when creating the index, you can find the name using
   :method:`db.collection.getIndexes()`

.. _text-index-specify-language:

Specify Languages for Text Index
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default language associated with the indexed data determines the
list of stop words and the rules for the stemmer and tokenizer. The
default language for the indexed data is ``english``.

Use the ``default_language`` option when creating the ``text`` index to
specify a different language. See :ref:`text-search-languages`.

The following example creates a ``text`` index on the
``content`` field and sets the ``default_language`` to
``spanish``:

.. code-block:: javascript

   db.collection.ensureIndex( { content : "text" },
                              { default_language: "spanish" } )

If a collection contains documents that are in different languages, the
individual documents can specify the language to use.

- By default, if the documents in the collection contain a field named
  ``language``, the value of the ``language`` field overrides the
  default language.

  For example, the following document overrides the default language
  ``spanish`` with ``portuguese``, the value in its ``language`` field.

  .. code-block:: javascript

     { content: "A sorte protege os audazes", language: "portuguese" }

- To use a different field to override the default language, specify the
  field with the ``language_override`` option when creating the index.

  For example, if the documents contain the field named ``myLanguage``
  instead of ``language``, create the ``text`` index with the
  ``language_override`` option.

  .. code-block:: javascript

     db.collection.ensureIndex( { content : "text" },
                                { language_override: "myLanguage" } )

.. .. note::
.. If you specify a ``default_language`` of ``"none"``, or the override
   language is ``"none"``, the :dbcommand:`text` command will not stem
   the words. The command will also consider all words, i.e., it will not
   drop the stop words.

Text Queries
^^^^^^^^^^^^

MongoDB 2.3.2 introduces the :dbcommand:`text` command to provide
query support for ``text`` indexes. Unlike normal MongoDB queries,
:dbcommand:`text` returns a document rather than a
cursor.

.. dbcommand:: text

   The :dbcommand:`text` provides an interface to search text context
   stored in the ``text`` index. Consider the following prototype:
   :dbcommand:`text`:

   .. code-block:: javascript

      db.collection.runCommand( "text", { search: <string>,
                                          filter: <document>,
                                          project: <document>,
                                          limit: <number>,
                                          language: <string> } )

   The :dbcommand:`text` command has the following parameters:

   :param string search:

      A text string that MongoDB stems and uses to query the ``text``
      index. In the :program:`mongo` shell, to specify a phrase to
      match, you can either:

      - enclose the phrase in *escaped* double quotes and use double
        quotes to specify the ``search`` string, as in ``"\"coffee
        table\""``, or

      - enclose the phrase in double quotes and use *single* quotes to
        specify the ``search`` string, as in ``'"coffee table"'``

   :param document filter:

      Optional. A :ref:`query document <mongodb-query-document>` to
      further limit the results of the query using another database
      field. You can use any valid MongoDB query in the filter
      document, except if the index includes an ascending or descending
      index field as a prefix.

      If the index includes an ascending or descending index field as a
      prefix, the ``filter`` is required and the ``filter`` query must be
      an equality match.

   :param document project:

      Optional. Allows you to limit the fields returned by the query
      to only those specified.

   :param number limit:

      Optional. Specify the maximum number of documents to include in
      the response. The :dbcommand:`text` sorts the results before
      applying the ``limit``.

      The default limit is 100.

   :param string language:

      Optional. Specify, for the search, the language that determines
      the list of stop words and the rules for the stemmer and
      tokenizer. The default language is the value of the
      ``default_language`` field specified during the index creation.
      See :ref:`text-search-languages` for the supported languages.

   :return:

      :dbcommand:`text` returns results, in descending order by score,
      in the form of a document. Results must fit within the
      :limit:`BSON Document Size`. Use the ``limit`` and the
      ``project`` parameters to limit the size of the result set.

   The implicit connector between the terms of a multi-term search is a
   disjunction (``OR``). Search for ``"first second"`` searches
   for ``"first"`` or ``"second"``. The scoring system will prefer
   documents that contain all terms.

   However, consider the following behaviors of :dbcommand:`text`
   queries:

   - With phrases (i.e. terms enclosed in escaped quotes), the search
     performs an ``AND`` with any other terms in the search string;
     e.g. search for ``"\"twinkle twinkle\" little star"`` searches for
     ``"twinkle twinkle"`` and (``"little"`` or ``"star"``).

   - :dbcommand:`text` adds all negations to the query with the
     logical ``AND`` operator.

.. example::

   Consider the following examples of :dbcommand:`text` queries. All
   examples assume that you have a ``text`` index on the field named
   ``content`` in a collection named ``collection``.

   #. Create a ``text`` index on the ``content`` field to enable text
      search on the field:

      .. code-block:: javascript

         db.collection.ensureIndex( { content: "text" } )

   #. Search for a single word ``coffee``:

      .. code-block:: javascript

         db.collection.runCommand( "text", { search: "coffee" } )

      This query returns documents that contain the word ``coffee``,
      case-insensitive, in the ``content`` field.

   #. Search for multiple words, ``bake`` or ``coffee`` or  ``cake``:

      .. code-block:: javascript

         db.collection.runCommand( "text", { search: "bake coffee cake" } )

      This query returns documents that contain the either ``bake``
      **or** ``coffee`` **or** ``cake`` in the ``content`` field.

   #. Search for the exact phrase ``bake coffee cake``:

      .. code-block:: javascript

         db.collection.runCommand( "text", { search: "\"bake coffee cake\"" } )

      This query returns documents that contain the exact phrase
      ``bake coffee cake``.

   #. Search for documents that contain the words ``bake`` or ``coffee``,
      but **not** ``cake``:

      .. code-block:: javascript

         db.collection.runCommand( "text", { search: "bake coffee -cake" } )

      Use the ``-`` as a prefix to terms to specify negation in the
      search string. The query returns documents that contain the
      either ``bake`` **or** ``coffee``, but **not** ``cake``, all
      case-insensitive, in the ``content`` field. Prefixing a word
      with a hyphen (``-``) negates a word:

      - The negated word filters out documents from the result set,
        after selecting documents.

      - A ``<search string>`` that only contains negative words returns no match.

      - A hyphenated word, such as ``case-insensitive``, is not a
        negation. The :dbcommand:`text` command treats the hyphen as a
        delimiter.

   #. Search for a single word ``coffee`` with an additional ``filter`` on
      the ``about`` field, but **limit** the results to 2 documents with the
      highest score and return only the ``comments`` field in the matching
      documents:

      .. code-block:: javascript

         db.collection.runCommand( "text", {
                                             search: "coffee",
                                             filter: { about: /desserts/ },
                                             limit: 2,
                                             project: { comments: 1, _id: 0 }
                                           }
                                 )

      - The ``filter`` :ref:`query document <mongodb-query-document>`
        may use any of the available :doc:`query operators
        </reference/operator>`.

      - Because the ``_id`` field is implicitly included, in order to
        return **only** the ``comments`` field, you must explicitly
        exclude (``0``) the ``_id`` field. Within the ``project``
        document, you cannot mix inclusions (i.e. ``<fieldA>: 1``) and
        exclusions (i.e. ``<fieldB>: 0``), except for the ``_id`` field.

.. _text-search-languages:

Languages Supported in Text Search
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``text`` index and the :dbcommand:`text` command support the
following languages:

- ``danish``
- ``dutch``
- ``english``
- ``finnish``
- ``french``
- ``german``
- ``hungarian``
- ``italian``
- ``norwegian``
- ``portuguese``
- ``romanian``
- ``russian``
- ``spanish``
- ``swedish``
- ``turkish``

New Geospatial Indexes with GeoJSON and Improved Spherical Geometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::

   In 2.3.2, the index type for Spherical Geospatial Indexes
   become ``2dsphere``.

The 2.3 series adds a new type of geospatial index that supports
improved spherical queries and GeoJSON. Create the index by specifying
``2dsphere`` as the value of the field in the index specification, as
any of the following:

.. code-block:: javascript

   db.collection.ensureIndex( { geo: "2dsphere" } )
   db.collection.ensureIndex( { type: 1, geo: "2dsphere" } )
   db.collection.ensureIndex( { geo: "2dsphere", type: 1 } )

In the first example you create a spherical geospatial index on the
field named ``geo``, in the second example, you create a compound
index where the first field is a normal index, and the index of the
second field is a spherical geospatial index. Unlike ``2d`` indexes,
fields indexed using the ``2dsphere`` type do not have to be the first
field in a compound index.

You must store data in the fields indexed using the ``2dsphere`` index
using the `GeoJSON`_ specification, at the moment. Support for storing
points, in the form used by the existing ``2d`` (i.e. geospatial)
indexes is forthcoming. Currently, ``2dsphere`` indexes only support
the following GeoJSON shapes:

- ``Point``, as in the following:

  .. code-block:: javascript

     { "type": "Point", "coordinates": [ 40, 5 ] }

- ``LineString``, as in the following:

  .. code-block:: javascript

     { "type": "LineString", "coordinates": [ [ 40, 5 ], [ 41, 6 ] ] }

- ``Polygon``, as in the following:

  .. code-block:: javascript

     {
       "type": "Polygon",
       "coordinates": [ [ [ 40, 5 ], [ 40, 6 ], [ 41, 6 ], [ 41, 5 ], [ 40, 5 ] ] ]
     }

To query ``2dsphere`` indexes, all current geospatial :ref:`query operators
<query-selectors-geospatial>` with an additional
:operator:`$geoIntersects` operator. Currently, all queries using the
``2dsphere`` index must pass the query selector (e.g. :operator:`$near`,
:operator:`$geoIntersects`) a GeoJSON document. With the exception of the
GeoJSON requirement, the operation of :operator:`$near` is the same
for ``2dsphere`` indexes as ``2d`` indexes.

.. operator:: $geoIntersects

   The :operator:`$geoIntersects` selects all indexed points that
   intersect with the provided geometry. (i.e. ``Point``, ``LineString``,
   and ``Polygon``.) You must pass :operator:`$geoIntersects` a document
   in GeoJSON format.

   .. code-block:: javascript

      db.collection.find( { loc: { $geoIntersects:
                                   { $geometry: { "type": "Point",
                                                  "coordinates": [ 40, 5 ]
                                   } } } } )

   This query will select all indexed objects that intersect with the
   ``Point`` with the coordinates ``[ 40, 5 ]``. MongoDB will return
   documents as intersecting if they have a shared edge.

   The :operator:`$geometry` operator takes a single `GeoJSON
   document`_.

.. operator:: $geometry

.. _`GeoJSON document`: http://www.geojson.org/geojson-spec.html#appendix-a-geometry-examples

.. _`GeoJSON`: http://geojson.org/geojson-spec.html

New Hashed Index and Sharding with a Hashed Shard Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To support an easy to configure and evenly distributed shard key, version 2.3 adds a
new "``hashed``" index type that indexes based on hashed values. This
section introduces and documents both the new index type and its use
in sharding:

Hashed Index
````````````

The new ``hashed`` index exists primarily to support automatically
hashed shard keys. Consider the following properties of hashed
indexes:

- Hashed indexes must only have a single field, and cannot be compound
  indexes.

- Fields indexed with hashed indexes must *not* hold arrays. Hashed
  indexes cannot be multikey indexes.

- Hashed indexes cannot have a ``unique`` constraint.

  You *may* create hashed indexes with the ``sparse`` property.

- MongoDB can use the hashed index to support equality queries, but
  cannot use these indexes for range queries.

- Hashed indexes offer no performance advantage over normal indexes.
  *However*, hashed indexes may be smaller than a normal index when
  the values of the indexed field are larger than 64 bits. [#hash-size]_

- it's possible to have a hashed and non-hashed index on the same
  field: MongoDB will use the non-hashed for range queries.

.. _hashed-index-warning:

.. warning::

   Hashed indexes round floating point numbers to 64-bit integers
   before hashing. For example, a hashed index would store the same
   value for a field that held a value of ``2.3`` and ``2.2``. To
   prevent collisions do not use a hashed index for floating point
   numbers that cannot be consistently converted to 64-bit integers (and
   then back to floating point.) Hashed indexes do not support
   floating point values larger than 2\ :sup:`53`.

Create a hashed index using an operation that resembles the
following:

.. code-block:: javascript

   db.active.ensureIndex( { a: "hashed" } )

This operation creates a hashed index for the ``active`` collection on
the ``a`` field.

.. [#hash-size] The hash stored in the hashed index is 64 bits long.

Hashed Sharding
```````````````

To shard a collection using a hashed shard key, issue an operation in
the :program:`mongo` shell that resembles the following:

.. code-block:: javascript

   sh.shardCollection( "records.active", { a: "hashed" } )

This operation shards the ``active`` collection in the ``records``
database, using a hash of the ``a`` field as the shard
key. Consider the following properties when using a hashed shard key:

- As with other kinds of shard key indexes, if your collection has
  data, you must create the hashed index before sharding. If your
  collection does not have data, sharding the collection will create
  the appropriate index.

- The :program:`mongos` will route all equality queries to a specific
  shard or set of shards; however, the :program:`mongos` must route
  range queries to all shards.

- When using a hashed shard key on a new collection, MongoDB
  automatically pre-splits the range of 64-bit hash values into
  chunks. By default, the initial number of chunks is equal to twice
  the number of shards at creation time. You can change the number of
  chunks created, using the ``numInitialChunks`` option, as in the
  following invocation of :dbcommand:`shardCollection`:

  .. code-block:: javascript

     db.adminCommand( { shardCollection: "test.collection",
                        key: { a: "hashed"},
                        numInitialChunks: 2001 } )

  MongoDB will only pre-split chunks in a collection when sharding
  empty collections. MongoDB will not create chunk splits in a
  collection sharding collections that have data.

  .. note::

     ``numInititalChanks`` allows you to create, at most ``8192``
     chunks when sharding a collection.

.. warning::

   Avoid using hashed shard keys when the hashed field has non-integral floating
   point values, see :ref:`hashed indexes <hashed-index-warning>` for
   more information.

Security Improvements
+++++++++++++++++++++

.. _kerberos-authentication:

New Modular Authentication System with Support for Kerberos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::

   Kerberos authentication is only present in the `MongoDB Subscriber
   Edition <https://www.10gen.com/mongodb-subscriber-edition-download>`_.
   To download the 2.4.0 release candidate the Subscriber Edition, use
   the following resources:

   - `Amazon Linux 6.4 <http://s3.amazonaws.com/downloads.10gen.com/linux/mongodb-linux-x86_64-subscription-amzn64-2.4.0-rc0.tgz>`_
   - `Red Hat Enterprise Linux 6.2 <http://s3.amazonaws.com/downloads.10gen.com/linux/mongodb-linux-x86_64-subscription-rhel62-2.4.0-rc0.tgz>`_
   - `Ubuntu 11.04 <http://s3.amazonaws.com/downloads.10gen.com/linux/mongodb-linux-x86_64-subscription-ubuntu1104-2.4.0-rc0.tgz>`_
   - `SUSE 11 <http://s3.amazonaws.com/downloads.10gen.com/linux/mongodb-linux-x86_64-subscription-suse11-2.4.0-rc0.tgz>`_

In 2.4 the MongoDB Subscriber edition now supports authentication via
a Kerberos mechanism. See
:doc:`/tutorial/control-access-to-mongodb-with-kerberos-authentication`
for more information.

Also consider the following documents that address authenticating to
MongoDB using Kerberos:

- :ecosystem:`Authenticate to MongoDB using Kerberos and the Java
  Driver </tutorial/authenticate-with-java-driver/>`

- :ecosystem:`Authenticate to MongoDB using Kerberos and the C# Driver
  </tutorial/authenticate-with-csharp-driver/>`

.. see:: :doc:`MongoDB Security Practices and Procedures </security>`.

Role Based Access Control and New Privilege Documents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MongoDB 2.4 introduces a role based access control system that
provides more granular privileges to MongoDB users. See
:doc:`/reference/user-privileges` for more information.

To support the new access control system, 2.4 also introduces a new
format for documents in a database's :data:`system.user
<<database>.system.user>` collection. See
:doc:`/reference/privilege-documents` for more information.

Use :parameter:`supportCompatibilityFormPrivilegeDocuments` to disable
the legacy privilege documents, which MongoDB continues to support in
2.4.

Administration Changes
++++++++++++++++++++++

``--setParameter`` Option Available on the ``mongos`` and ``mongod`` Command Line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can now use :option:`--setParameter <mongod>` on the command line
and :setting:`setParameter` in the configuration file. Currently
:setting:`setParameter` provides the following options:

.. include:: /includes/list-set-parameters.rst

See :doc:`/reference/parameters` for full documentation of available
parameters and their use.

Changes to ``serverStatus`` Output Including Additional Metrics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In 2.4 MongoDB adds a number of counters and system metrics to the
output of the :dbcommand:`serverStatus` command, including:

- a :ref:`working set estimator <server-status-workingset>`.

- operation counters, in :data:`~serverStatus.metrics.document`
  and :data:`~serverStatus.metrics.operation`.

- record allocation, in :data:`~serverStatus.metrics.record`.

- thorough metrics of the replication process,
  in :data:`~serverStatus.metrics.repl`.

- metrics on the :doc:`ttl index </tutorial/expire-data>`
  documentation.

Additionally, in 2.4, the :dbcommand:`serverStatus` command can
dynamically construct the :data:`serverStatus` document by excluding
any top-level sections included by default, or including any top-level
section not included by default (e.g. :data:`~serverStatus.workingSet`.)

See :method:`db.serverStatus()` and :dbcommand:`serverStatus` for more
information.

Increased Chunk Migration Write Concern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, all insert and delete operations that occur as part of a
:term:`chunk` migration in a :term:`sharded cluster` will have an
increased write concern, to ensure that at least one secondary
acknowledges each insert and deletion operation. This change slows the
potential speed of a chunk migration, but increases reliability and
ensures that a large number of chunk migrations *cannot* affect the
availability of a sharded cluster.

BSON Document Validation Enabled by Default for ``mongod`` and ``mongorestore``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting in 2.4, MongoDB enables basic :term:`BSON` object validation
for :program:`mongod` and :program:`mongorestore` when writing to
MongoDB data files. This prevents any client from inserting invalid or
malformed BSON into a MongoDB database. For objects with a high degree
of sub-document nesting this validation may have a small performance
impact. :setting:`objcheck`, which was previously disabled by default,
provides this validation.

Indexing Changes
++++++++++++++++

Support for Multiple Concurrent Index Builds
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A single :program:`mongod` instance can build multiple indexes in the
background at the same time. See :ref:`building indexes in the
background <index-creation-background>` for more information on
background index builds. Foreground index builds hold a database lock
and must proceed one at a time.

``db.killOp()`` Can Now Kill Foreground Index Builds
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :method:`db.killOp()` method will now terminate a foreground index
build, in addition to the other operations supported in previous
versions.

Interface Changes
+++++++++++++++++

``$setOnInsert`` -- New Update Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. Properly restructure this section after adding $push...

To set fields *only* when an :method:`upsert <db.collection.update()>`
performs an insert, use the :operator:`$setOnInsert` operator with the
:method:`upsert <db.collection.update()>` .

.. example::

   A collection named ``coll`` has no documents with ``_id`` equal to
   ``1``.

   The following :method:`upsert <db.collection.update()>` operation
   inserts a document and applies the :operator:`$setOnInsert` operator
   to set the fields ``x`` and ``y``:

   .. code-block:: javascript

      db.coll.update( { _id: 1 },
                      { $setOnInsert: { x: 25, y: 30 } },
                      { upsert: true } )

   The newly-inserted document has the field ``x`` set to ``25`` and
   the field ``y`` set to 30:

   .. code-block:: javascript

      { "_id" : 1, "x" : 25, "y" : 30 }

.. note::

   The :operator:`$setOnInsert` operator performs no operation for
   :method:`upserts <db.collection.update()>` that only perform an
   update and for :method:`updates <db.collection.update()>` when the
   ``upsert`` option is ``false``.

Limit Number of Elements in an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider a situation where you only want to maintain a fixed number of
elements in an array.

In 2.4, by using the :operator:`$push` operator with the
:operator:`$each`, the :operator:`$sort`, and the :operator:`$slice`
modifiers, you can add multiple elements to an array, sort and limit
the number of elements in the modified array to maintain an array with
a fixed number of elements.

See :doc:`/tutorial/limit-number-of-elements-in-updated-array` for an
example where an update maintains the top three scores for a student.

.. seealso::

   The following pages provide additional information and examples:

   - :operator:`$push` operator

   - :operator:`$each` modifier

   - :operator:`$sort` modifier

   - :operator:`$slice` modifier

.. _rn-2.4-javascript-change:

JavaScript Engine Changed to V8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. toctree::
   :hidden:

   /release-notes/2.4-javascript


In 2.4 the default JavaScript engine in the :program:`mongo` shell
:program:`mongod` is now V8. This change affects all JavaScript
behavior including the :dbcommand:`mapReduce`, :dbcommand:`group`, and
:dbcommand:`eval` commands, as well as the :operator:`$where` query
operator.

Use the new :method:`interpreterVersion()` method in the
:program:`mongo` shell and the
:data:`~serverBuildInfo.interpreterVersion` field in the output of
:method:`db.serverBuildInfo()` to determine which JavaScript engine a
MongoDB binary uses.

The primary impacts of the change from the previous JavaScript engine,
SpiderMonkey, to V8 are:

- improved concurrency for JavaScript operations,
- modernized JavaScript implementation, and
- removed non-standard SpiderMonkey features.

See :doc:`/release-notes/2.4-javascript` for more information about
all changes .

Additional Limitations for Map-Reduce and ``$where`` Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: /includes/fact-group-map-reduce-where-limitations-in-24.rst

.. DOCS-752

Improvements to the Aggregation Framework
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :agg:pipeline:`$match` queries support the :operator:`$within` operator.

- New :agg:expression:`$millisecond` operator to return the millisecond
  portion of a date.
