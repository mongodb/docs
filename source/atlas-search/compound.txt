.. _compound-ref:

========
compound
========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. expression:: compound

   The ``compound`` operator combines two or more operators into a
   single query. Each element of a ``compound`` query is called a
   clause, and each clause consists of one or more sub-queries.

   Documents in the result set are returned with a match score, which
   is calculated by summing the score that each document received for
   each individual clause which generated a match. The result set is
   ordered by score, highest to lowest.

.. _compound-syntax:

Syntax
------

``compound`` has the following syntax:

.. code-block:: javascript
   :linenos:

   {
     $search: {
       "index": <index name>, // optional, defaults to "default"
       "compound": {
         <must | mustNot | should | filter>: [ { <clauses> } ]
       }
     }
   }

Each ``must``, ``mustNot``, ``should``, and ``filter`` clause contains an
array of sub-clauses. Use array syntax even if the array contains only one
sub-clause. See the :ref:`examples <compound-examples>` on this page.

.. _compound-options:

Options
-------

``compound`` uses the following terms to construct a query:

.. list-table::
   :widths: 15 85

   * - .. data:: must
     - Clauses that must match to for a document to be included in the
       results.

       Maps to the ``AND`` boolean operator.

   * - .. data:: mustNot
     - Clauses that must not match for a document to be included in
       the results.

       Maps to the ``AND NOT`` boolean operator.

   * - .. data:: should
     - Clauses that you prefer to match in documents that are included
       in the results. Documents that contain a match for a ``should`` 
       clause have higher scores than documents that don't contain a
       ``should`` clause.

       If you use more than one ``should`` clause, you can use the
       ``minimumShouldMatch`` option to specify a minimum number of
       ``should`` clauses that must match to include a document in the 
       results. If omitted, the ``minimumShouldMatch`` option defaults
       to ``0``.

       See an :ref:`example <min-example>`.

       Maps to the ``OR`` boolean operator.

   * - .. data:: filter
     - Clauses that must all match for a document to be
       included in the results. ``filter`` clauses do not contribute
       to a returned document's score.

       .. example:: 

          For example, you can replace the :pipeline:`$match` stage 
          with the ``compound`` operator ``filter`` condition in the 
          ``$search`` stage: 

          .. code-block:: json 
             :copyable: false 

             {
               "$match": {
                 "role": { "$in": [ "CLIENT", "PROFESSIONAL" ] }
               }
             }

          You can use the ``filter`` option instead: 

          .. code-block:: json 
             :copyable: false 

             $search: {
               "compound": {
                 "filter": [{
                   "text": { 
                     "query": ["CLIENT", "PROFESSIONAL"], 
                     "path": "role" 
                   }
                 }]
               }
             }

       See another :ref:`filter-example`.

Any of the above clauses may contain query criteria using any
top-level operator, such as :ref:`term <term-ref>`,
:ref:`search <search-ref>`, or :ref:`span <span-ref>`.

.. _compound-examples:

Examples
--------

The examples on this page use a collection called ``fruit`` which contains
the following documents:

.. code-block:: json
   :linenos:

   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   },
   {
     "_id" : 2,
     "type" : "banana",
     "description" : "Bananas are usually sold in bunches of five or six.",
     "category" : "nonorganic",
     "in_stock" : true
   },
   {
     "_id" : 3,
     "type" : "pear",
     "description" : "Bosc and Bartlett are the most common varieties of 
     pears.",
     "category" : "organic",
     "in_stock" : true
   }

The ``fruit`` collection has an |fts| index on the ``description``
field which uses the :ref:`standard <ref-standard-analyzer>` analyzer.
The ``standard`` analyzer lower-cases all words and disregards common
stop words (``"the", "a", "and",`` etc).

.. _must-must-not-example-ref:

``must`` and ``mustNot`` Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example uses a combination of ``must`` and ``mustNot``
clauses to contruct a query. The ``must`` clause uses the 
:ref:`text <text-ref>` operator to search for the term ``varieties`` 
in the ``description`` field. For a document to match, it must fulfill 
the ``must`` clause. The ``mustNot`` clause performs a search operation 
for the term ``apples`` in the ``description`` field. For a document to
match, it must *not* fulfill the ``mustNot`` clause.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
               "query": "varieties",
               "path": "description"
             }
           }],
           "mustNot": [{
             "text": {
               "query": "apples",
               "path": "description"
             }
           }]
         }
       }
     }
   ])

The above query returns the document with ``_id: 3`` because its
``description`` field contains the word ``varieties`` and does not
contain ``apples``.

.. _must-should-example:

``must`` and ``should`` Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following query uses ``must`` to specify search conditions
which must be met and ``should`` to specify preference for documents
containing the word ``Fuji``. The ``$project`` pipeline stage excludes
all document fields except ``_id`` and adds a ``score`` field, which
displays the document's relevance score.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
               "query": "varieties",
               "path": "description"
             }
           }],
           "should": [{
             "text": {
               "query": "Fuji",
               "path": "description"
             }
           }]
         }
       }
     },
     {
       $project: {
         "score": { "$meta": "searchScore" }
       }
     }
   ])

The above query returns the following results:

.. code-block:: json
   :copyable: false

   { "_id" : 1, "score" : 0.6425117254257202 }
   { "_id" : 3, "score" : 0.21649497747421265 }

The document with ``_id: 1`` has a higher score because its
``description`` field contains the word ``Fuji``, satisfying the
``should`` clause.

.. _min-example:

minimumShouldMatch Example
~~~~~~~~~~~~~~~~~~~~~~~~~~

In a query with multiple ``should`` clauses, you can use the
``miniumumShouldMatch`` option to specify a minimum number of clauses
which must match to return a result.

The following query has one ``must`` clause and two ``should`` clauses,
with a ``minimumShouldMatch`` value of ``1``. A document must include
the term ``varieties`` in the ``description`` field and must include
either ``Fuji`` or ``Golden Delicious`` in the description field to be
included in the result set.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "must": [{
             "text": {
                "query": "varieties",
                "path": "description"
             }
           }],
           "should": [
             {
               "text": {
                 "query": "Fuji",
                 "path": "description"
               }
             },
             {
               "text": {
                 "query": "Golden Delicious",
                 "path": "description"
               }
             }],
             "minimumShouldMatch": 1
           }
         }
       }
   ])

The above query returns the following result:

.. code-block:: json
   :copyable: false

   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   }

The document with ``_id: 1`` matches the ``must`` clause and the first
of the two ``should`` clauses.

.. _filter-example:

``filter`` Examples
~~~~~~~~~~~~~~~~~~~

``filter`` behaves the same as ``must``, except that the ``filter`` 
clause is not considered in a returned document's score, and therefore 
does not affect the order of the returned documents.

.. tabs:: 

   .. tab:: Basic Example 
      :tabid: basic

      The following query uses the following clauses: 
      
      - ``must`` and ``filter`` to specify search conditions which must 
        be met.
      - ``should`` to specify preference for documents containing the 
        word  ``banana``. The ``should`` clause doesn't include the 
        ``minimumShouldMatch`` option. When you omit 
        ``minimumShouldMatch``, it defaults to ``0``.

      .. code-block:: javascript
         :linenos:

         db.fruit.aggregate([
           {
             "$search": {
               "compound": {
                 "must": [{
                   "text": {
                     "query": "varieties",
                     "path": "description"
                   }
                 }],
                 "should": [{
                   "text": {
                     "query": "banana",
                     "path": "description"
                   }
                 }],
                 "filter": [{
                   "text": {
                     "query": "granny",
                     "path": "description"
                   }
                 }]
               }
             }
           }
         ])

      The query returns the following result:

      .. code-block:: json
         :copyable: false

         {
           "_id" : 1,
           "type" : "apple",
           "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
           "category" : "nonorganic",
           "in_stock" : false
         }

      The returned document fulfills all the requirements for inclusion:

      - Both the ``must`` clause and the ``filter`` clause match.
      - The ``minimumShouldMatch`` value is not specified, so it 
        defaults to ``0``. As a result, the ``should`` clause fails 
        and still returns a document.

   .. tab:: $match Replacement Example 
      :tabid: match

      You can replace the :pipeline:`$match` with :query:`$in` in your 
      queries against data on your |service| cluster with the 
      ``filter`` clause. The following query demonstrates how to use 
      ``filter`` in the :pipeline:`$search` stage to specify the search 
      terms that must match. The query also uses ``should`` to specify 
      preference for documents containing the term ``varieties``. The 
      query includes the ``$project`` pipeline stage to do the 
      following:
      
      - Exclude all fields except ``_id`` and ``description``. 
      - Add a ``score`` field, which displays the document's relevance 
        score.

      .. code-block:: json 

         db.fruit.aggregate([
           {
             "$search": {
               "compound": {
                 "filter": [{
                   "text": {
                     "query": ["apples", "bananas"],
                     "path": "description"
                   }
                 }],
                 "should": [{
                   "text": {
                     "query": "varieties",
                     "path": "description"
                   }
                 }]
               }
             }
           },
           {
             "$project": {
               "description": 1,
               "score": { "$meta": "searchScore" }
             }
           }
         ])

      The query returns the following documents:

      .. code-block:: json
         :copyable: false

         [
           {
             _id: 1,
             description: 'Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp. The most popular varieties are McIntosh, Gala, and Granny Smith.',
             score: 0.36074575781822205
           },
           {
             _id: 2,
             description: 'Bananas are usually sold in bunches of five or six.',
             score: 0
           }
         ]

      The documents in the result fulfill all the requirements for 
      inclusion:

      - Both documents contain the term ``apples`` or ``bananas`` that 
        was specified in the ``filter`` clause of the query.
      - Document with ``_id: 1`` scores higher than document with 
        ``_id: 2`` because it contains the term ``varieties`` specified 
        in the ``should`` clause of the query.

Nested Example 
~~~~~~~~~~~~~~

The following example uses nested ``compound`` clauses to construct a 
query. For this example, the ``fruit`` collection has an index on the 
``type``, ``category``, and ``in_stock`` fields, whose text fields use the 
:ref:`default <ref-standard-analyzer>` analyzer. The query requires 
documents to only satisfy one of the following  ``should`` clauses: 

- Contain the word ``apple`` in the ``type`` field.
- Contain the term ``organic`` in the ``category`` field and have the 
  value ``true`` in the ``in_stock`` field.

.. code-block:: javascript
   :linenos:

   db.fruit.aggregate([
     {
       $search: {
         "compound": {
           "should": [
             {
               "text": {
                 "query": "apple",
                 "path": "type"
               }
             },
             {
               "compound": {
                 "must": [
                   {
                     "text": {
                       "query": "organic",
                       "path": "category"
                     }
                   },
                   {
                     "equals": {
                       "value": true,
                       "path": "in_stock"
                     }
                   }
                 ]
               }
             }
           ],
           "minimumShouldMatch": 1
         }
       }
     }
   ])

The above query returns the following result:

.. code-block:: json
   :copyable: false
   
   { 
     "_id" : 3, 
     "type" : "pear", 
     "description" : "Bosc and Bartlett are the most common varieties of pears.", 
     "category" : "organic", 
     "in_stock" : true 
   }
   {
     "_id" : 1,
     "type" : "apple",
     "description" : "Apples come in several varieties, including Fuji, Granny Smith, and Honeycrisp.",
     "category" : "nonorganic",
     "in_stock" : false
   }

The above document fulfills all the requirements for inclusion: 

- The document with ``_id: 3`` matches the ``must`` clause nested within 
  the second ``should`` clause.
- The document with ``_id: 1`` matches the first ``should`` clause.
