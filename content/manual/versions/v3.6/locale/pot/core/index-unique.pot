# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2019
# This file is distributed under the same license as the mongodb-manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/index-unique.txt:6
msgid "Unique Indexes"
msgstr ""

#: ../source/core/index-unique.txt:16
msgid "A unique index ensures that the indexed fields do not store duplicate values; i.e. enforces uniqueness for the indexed fields. By default, MongoDB creates a unique index on the :ref:`_id <document-id-field>` field during the creation of a collection."
msgstr ""

#: ../source/core/index-unique.txt:22
msgid "Create a Unique Index"
msgstr ""

#: ../source/core/index-unique.txt:24
msgid "To create a unique index, use the :method:`db.collection.createIndex()` method with the ``unique`` option set to ``true``."
msgstr ""

#: ../source/core/index-unique.txt:35
msgid "Unique Index on a Single Field"
msgstr ""

#: ../source/core/index-unique.txt:37
msgid "For example, to create a unique index on the ``user_id`` field of the ``members`` collection, use the following operation in the :binary:`~bin.mongo` shell:"
msgstr ""

#: ../source/core/index-unique.txt:48
msgid "Unique Compound Index"
msgstr ""

#: ../source/core/index-unique.txt:50
msgid "You can also enforce a unique constraint on :ref:`compound indexes <index-type-compound>`. If you use the unique constraint on a :ref:`compound index <index-type-compound>`, then MongoDB will enforce uniqueness on the *combination* of the index key values."
msgstr ""

#: ../source/core/index-unique.txt:55
msgid "For example, to create a unique index on ``groupNumber``, ``lastname``, and ``firstname`` fields of the ``members`` collection, use the following operation in the :binary:`~bin.mongo` shell:"
msgstr ""

#: ../source/core/index-unique.txt:63
msgid "The created index enforces uniqueness for the *combination* of ``groupNumber``, ``lastname``, and ``firstname`` values."
msgstr ""

#: ../source/core/index-unique.txt:66
msgid "For another example, consider a collection with the following document:"
msgstr ""

#: ../source/core/index-unique.txt:72
msgid "Create a unique compound :doc:`multikey </core/index-multikey>` index on ``a.loc`` and ``a.qty``:"
msgstr ""

#: ../source/core/index-unique.txt:79
msgid "The unique index permits the insertion of the following documents into the collection since the index enforces uniqueness for the *combination* of ``a.loc`` and ``a.qty`` values:"
msgstr ""

#: ../source/core/index-unique.txt:88
msgid ":ref:`unique-separate-documents` and :ref:`unique-index-and-missing-field`"
msgstr ""

#: ../source/core/index-unique.txt:91
msgid "Behavior"
msgstr ""

#: ../source/core/index-unique.txt:94
msgid "Restrictions"
msgstr ""

#: ../source/core/index-unique.txt:96
msgid "MongoDB cannot create a :ref:`unique index <index-type-unique>` on the specified index field(s) if the collection already contains data that would violate the unique constraint for the index."
msgstr ""

#: ../source/core/index-unique.txt:100
msgid "You may not specify a unique constraint on a :ref:`hashed index <index-type-hashed>`."
msgstr ""

#: ../source/core/index-unique.txt:104
msgid "Building Unique Index on Replica Sets and Sharded Clusters"
msgstr ""

#: ../source/core/index-unique.txt:106
msgid "For replica sets and sharded clusters, using a :doc:`rolling procedure </tutorial/build-indexes-on-replica-sets>` to create a unique index requires that you stop all writes to the collection during the procedure. If you cannot stop all writes to the collection during the procedure, do not use the rolling procedure. Instead, build your unique index on the collection by:"
msgstr ""

#: ../source/core/index-unique.txt:113
msgid "issuing :method:`db.collection.createIndex()` on the primary for a replica set, or"
msgstr ""

#: ../source/core/index-unique.txt:116
msgid "issuing :method:`db.collection.createIndex()` on the :binary:`~bin.mongos` for a sharded cluster."
msgstr ""

#: ../source/core/index-unique.txt:122
msgid "Unique Constraint Across Separate Documents"
msgstr ""

#: ../source/core/index-unique.txt:124
msgid "The unique constraint applies to separate documents in the collection. That is, the unique index prevents *separate* documents from having the same value for the indexed key."
msgstr ""

#: ../source/core/index-unique.txt:128
msgid "Because the constraint applies to separate documents, for a unique :doc:`multikey </core/index-multikey>` index, a document may have array elements that result in repeating index key values as long as the index key values for that document do not duplicate those of another document. In this case, the repeated index entry is inserted into the index only once."
msgstr ""

#: ../source/core/index-unique.txt:135
msgid "For example, consider a collection with the following documents:"
msgstr ""

#: ../source/core/index-unique.txt:143
msgid "Create a unique compound multikey index on ``a.loc`` and ``a.qty``:"
msgstr ""

#: ../source/core/index-unique.txt:149
msgid "The unique index permits the insertion of the following document into the collection if no other document in the collection has an index key value of ``{ \"a.loc\": \"B\", \"a.qty\": null }``."
msgstr ""

#: ../source/core/index-unique.txt:160
msgid "Unique Index and Missing Field"
msgstr ""

#: ../source/core/index-unique.txt:162
msgid "If a document does not have a value for the indexed field in a unique index, the index will store a null value for this document. Because of the unique constraint, MongoDB will only permit one document that lacks the indexed field. If there is more than one document without a value for the indexed field or is missing the indexed field, the index build will fail with a duplicate key error."
msgstr ""

#: ../source/core/index-unique.txt:169
msgid "For example, a collection has a unique index on ``x``:"
msgstr ""

#: ../source/core/index-unique.txt:175
msgid "The unique index allows the insertion of a document without the field ``x`` if the collection does not already contain a document missing the field ``x``:"
msgstr ""

#: ../source/core/index-unique.txt:183
msgid "However, the unique index errors on the insertion of a document without the field ``x`` if the collection already contains a document missing the field ``x``:"
msgstr ""

#: ../source/core/index-unique.txt:191
msgid "The operation fails to insert the document because of the violation of the unique constraint on the value of the field ``x``:"
msgstr ""

#: ../source/core/index-unique.txt:204
msgid ":ref:`unique-partial-indexes`"
msgstr ""

#: ../source/core/index-unique.txt:209
msgid "Unique Partial Indexes"
msgstr ""

#: ../source/core/index-unique.txt:213
msgid "Partial indexes only index the documents in a collection that meet a specified filter expression. If you specify both the ``partialFilterExpression`` and a :ref:`unique constraint <index-type-unique>`, the unique constraint only applies to the documents that meet the filter expression."
msgstr ""

#: ../source/core/index-unique.txt:219
msgid "A partial index with a unique constraint does not prevent the insertion of documents that do not meet the unique constraint if the documents do not meet the filter criteria. For an example, see :ref:`partial-index-with-unique-constraints`."
msgstr ""

#: ../source/core/index-unique.txt:225
msgid "Sharded Clusters and Unique Indexes"
msgstr ""

#: ../source/core/index-unique.txt:227
msgid "You cannot specify a unique constraint on a :ref:`hashed index <index-type-hashed>`."
msgstr ""

#: ../source/core/index-unique.txt:230
msgid "For a ranged sharded collection, only the following indexes can be :doc:`unique </core/index-unique>`:"
msgstr ""

#: ../source/core/index-unique.txt:233
msgid "the index on the shard key"
msgstr ""

#: ../source/core/index-unique.txt:235
msgid "a :term:`compound index` where the shard key is a :ref:`prefix <compound-index-prefix>`"
msgstr ""

#: ../source/core/index-unique.txt:238
msgid "the default ``_id`` index; **however**, the ``_id`` index only enforces the uniqueness constraint per shard **if** the ``_id`` field is **not** the shard key or the prefix of the shard key."
msgstr ""

#: ../source/core/index-unique.txt:242
msgid "Uniqueness and the ``_id`` Index"
msgstr ""

#: ../source/core/index-unique.txt:245
msgid "If the ``_id`` field is not the shard key or the prefix of the shard key, ``_id`` index only enforces the uniqueness constraint per shard and **not** across shards."
msgstr ""

#: ../source/core/index-unique.txt:249
msgid "For example, consider a sharded collection (with shard key ``{x: 1}``) that spans two shards A and B. Because the ``_id`` key is not part of the shard key, the collection could have a document with ``_id`` value ``1`` in shard A and another document with ``_id`` value ``1`` in shard B."
msgstr ""

#: ../source/core/index-unique.txt:255
msgid "If the ``_id`` field is not the shard key nor the prefix of the shard key, MongoDB expects applications to enforce the uniqueness of the ``_id`` values across the shards."
msgstr ""

#: ../source/core/index-unique.txt:259
msgid "The unique index constraints mean that:"
msgstr ""

#: ../source/core/index-unique.txt:261
msgid "For a to-be-sharded collection, you cannot shard the collection if the collection has other unique indexes."
msgstr ""

#: ../source/core/index-unique.txt:264
msgid "For an already-sharded collection, you cannot create unique indexes on other fields."
msgstr ""

