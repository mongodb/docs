=====================
CMS: Storing Comments
=====================

.. default-domain:: mongodb

Overview
--------



Problem
~~~~~~~

In your content management system (CMS), you would like to store
user-generated comments on the various types of content you generate.

Solution
~~~~~~~~

Rather than describing the One True Way to implement comments in this
solution, this use case explores different options and the trade-offs with
each. The three major designs discussed here are:

One document per comment
   This provides the greatest degree of
   flexibility, as it is relatively straightforward to display the
   comments as either threaded or chronological. There are also no
   restrictions on the number of comments that can participate in a
   discussion.
All comments embedded
   In this design, all the comments are
   embedded in their parent document, whether that be a blog article,
   news story, or forum topic. This can be the highest performance
   design, but is also the most restrictive, as the display format of
   the comments is tied to the embedded structure. There are also
   potential problems with extremely active discussions where the total
   data (topic data + comments) exceeds the 16MB limit of MongoDB
   documents.
Hybrid design
   Here, you store comments separately from their
   parent topic, but aggregate comments together into a few
   documents, each containing many comments.

Another decision that needs to be considered in designing a commenting
system is whether to support threaded commenting (explicit replies to a
parent comment). This threaded comment support
decision will also be discussed below.

One Document Per Comment
------------------------

Schema
~~~~~~
A comment in the one document per comment format might have a structure
similar to the following:

.. code-block:: javascript

   {
       _id: ObjectId(...),
       discussion_id: ObjectId(...),
       slug: '34db',
       posted: ISODateTime(...),
       author: { id: ObjectId(...), name: 'Rick' },
       text: 'This is so bogus ... '
   }

The format above is really only suitable for chronological display of
commentary. It maintains a reference to the discussion in which this
comment participates, a url-friendly ``slug`` to identify it, ``posted`` time
and ``author``, and the comment's ``text``. If you want to support threading in
this format, you need to maintain some notion of hierarchy in the comment
model as well:

.. code-block:: javascript

   {
       _id: ObjectId(...),
       discussion_id: ObjectId(...),
       parent_id: ObjectId(...),
       slug: '34db/8bda',
       full_slug: '34db:2012.02.08.12.21.08/8bda:2012.02.09.22.19.16',
       posted: ISODateTime(...),
       author: { id: ObjectId(...), name: 'Rick' },
       text: 'This is so bogus ... '
   }

Here, the schema includes some extra information into the document that
represents this document's position in the hierarchy. In addition to
maintaining the ``parent_id`` for the comment, the slug format has been modified
and a new field ``full_slug`` has been added. The slug is now a path
consisting of the parent's slug plus the comment's unique slug portion.
The ``full_slug`` is also included to facilitate sorting documents in a
threaded discussion by posting date.

Operations
~~~~~~~~~~

Here, some common operations that you might need for your CMS are
described in the context of the single comment per document schema. All of the
following examples use the Python programming language and the ``pymongo``
MongoDB driver, but implementations would be similar in other languages as well.

Post a New Comment
``````````````````

In order to post a new comment in a chronologically ordered (unthreaded)
system, all you need to do is ``insert()``:

.. code-block:: python

   slug = generate_psuedorandom_slug()
   db.comments.insert({
       'discussion_id': discussion_id,
       'slug': slug,
       'posted': datetime.utcnow(),
       'author': author_info,
       'text': comment_text })

In the case of a threaded discussion, there is a bit more work to do in
order to generate a "pathed" ``slug`` and ``full_slug``:

.. code-block:: python

   posted = datetime.utcnow()

   # generate the unique portions of the slug and full_slug
   slug_part = generate_psuedorandom_slug()
   full_slug_part = slug_part + ':' + posted.strftime(
       '%Y.%m.%d.%H.%M.%S')

   # load the parent comment (if any)
   if parent_slug:
       parent = db.comments.find_one(
           {'discussion_id': discussion_id, 'slug': parent_slug })
       slug = parent['slug'] + '/' + slug_part
       full_slug = parent['full_slug'] + '/' + full_slug_part
   else:
       slug = slug_part
       full_slug = full_slug_part

   # actually insert the comment
   db.comments.insert({
       'discussion_id': discussion_id,
       'slug': slug, 'full_slug': full_slug,
       'posted': posted,
       'author': author_info,
       'text': comment_text })

View the (Paginated) Comments for a Discussion
``````````````````````````````````````````````

To actually view the comments in the non-threaded design, you need merely
to select all comments participating in a discussion, sorted by ``posted``:

.. code-block:: python

   cursor = db.comments.find({'discussion_id': discussion_id})
   cursor = cursor.sort('posted')
   cursor = cursor.skip(page_num * page_size)
   cursor = cursor.limit(page_size)

Since the ``full_slug`` embeds both hierarchical information via the path
and chronological information, you can use a simple sort on the
``full_slug`` property to retrieve a threaded view:

.. code-block:: python

   cursor = db.comments.find({'discussion_id': discussion_id})
   cursor = cursor.sort('full_slug')
   cursor = cursor.skip(page_num * page_size)
   cursor = cursor.limit(page_size)

Indexing
````````

In order to efficiently support the queries above, you should maintain
two compound indexes, one on (``discussion_id``, ``posted``), and the other on
(``discussion_id``, ``full_slug``):

.. code-block:: pycon

   >>> db.comments.ensure_index([
   ...    ('discussion_id', 1), ('posted', 1)])
   >>> db.comments.ensure_index([
   ...    ('discussion_id', 1), ('full_slug', 1)])

Note that you must ensure that the final element in a compound index is
the field by which you are sorting to ensure efficient performance of
these queries.

Retrieve Comments via Direct Links
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

("Permalink")

Queries
```````

Suppose you wish to directly retrieve a comment (e.g. *not* requiring
paging through all preceeding pages of commentary). In this case, you'd
simply use the ``slug``:

.. code-block:: python

   comment = db.comments.find_one({
       'discussion_id': discussion_id,
       'slug': comment_slug})

You can also retrieve a sub-discussion (a comment and all of its
descendants recursively) by performing a prefix query on the ``full_slug``
field:

.. code-block:: python

   subdiscussion = db.comments.find_one({
       'discussion_id': discussion_id,
       'full_slug': re.compile('^' + re.escape(parent_slug)) })
   subdiscussion = subdiscussion.sort('full_slug')

Indexing
````````

Since you already have indexes on (``discussion_id``, ``full_slug``) necessary to
support retrieval of subdiscussions, all you need to add here is an index on
(``discussion_id``, ``slug``) to efficiently support retrieval of a comment by
'permalink':

.. code-block:: pycon

   >>> db.comments.ensure_index([
   ...    ('discussion_id', 1), ('slug', 1)])

Emending All Comments
---------------------

Schema
~~~~~~

In this design, you wish to embed an entire discussion within its topic
document, be it a blog article, news story, or discussion thread. A
topic document, then, might look something like the following:

.. code-block:: python

   {
       _id: ObjectId(...),
       ... lots of topic data ...
       comments: [
           { posted: ISODateTime(...),
             author: { id: ObjectId(...), name: 'Rick' },
             text: 'This is so bogus ... ' },
          ... ]
   }

The format above is really only suitable for chronological display of
commentary. The comments are embedded in chronological order, with their
posting date, author, and text. Note that, since you're storing the
comments in sorted order, there is no longer need to maintain a slug per
comment. If you wanted to support threading in the embedded format, you'd need
to embed comments within comments:

.. code-block:: python

   {
       _id: ObjectId(...),
       ... lots of topic data ...
       replies: [
           { posted: ISODateTime(...),
             author: { id: ObjectId(...), name: 'Rick' },


             text: 'This is so bogus ... ',
             replies: [
                 { author: { ... }, ... },
          ... ]
   }

Here, there is a ``replies`` property added to each comment which can hold
sub-comments and so on. One thing in particular to note about the
embedded document formats is you give up some flexibility when embedding
the comments, effectively "baking in" the decisions made about
the proper display format. If you (or your users) someday wish to switch
from chronological or vice-versa, this schema makes such a migration
quite expensive.

In popular discussions, you also might have an issue with document size.
If you have a particularly avid discussion, for example, it might
outgrow the 16MB limit that MongoDB places on document size. You can also
run into scaling issues, particularly in the threaded design, as
documents need to be frequently moved on disk as they outgrow the space
allocated to them.

Operations
~~~~~~~~~~

Here, some common operations that you might need for your CMS are
described in the context of embedded comment schema. Once again, the examples are
in Python. Note that, in all the cases below,
there is no need for additional indexes since all the operations are
intra-document, and the document itself (the "discussion") is retrieved
by its ``_id`` field, which is automatically indexed by MongoDB anyway.

Post a new comment
``````````````````

In order to post a new comment in a chronologically ordered (unthreaded)
system, you need the following ``update()``:

.. code-block:: python

   db.discussion.update(
       { 'discussion_id': discussion_id },
       { '$push': { 'comments': {
           'posted': datetime.utcnow(),
           'author': author_info,
           'text': comment_text } } } )

Note that since you used the ``$push`` operator, all the comments will be
inserted in their correct chronological order. In the case of a threaded
discussion, there si a good bit more work to do. In order to reply to a
comment, the code below assumes that it has access to the 'path' to the comment
you're replying to as a list of positions:

.. code-block:: python

   if path != []:
       str_path = '.'.join('replies.%d' % part for part in path)
       str_path += '.replies'
   else:
       str_path = 'replies'
   db.discussion.update(
       { 'discussion_id': discussion_id },
       { '$push': {
           str_path: {
               'posted': datetime.utcnow(),
               'author': author_info,
               'text': comment_text } } } )

Here, you first construct a field name of the form
``replies.0.replies.2...`` as ``str_path`` and then use that to ``$push`` the new
comment into its parent comment's ``replies`` property.

View the (Paginated) Comments for a Discussion
``````````````````````````````````````````````

To actually view the comments in the non-threaded design, you need to use
the ``$slice`` operator:

.. code-block:: python

   discussion = db.discussion.find_one(
       {'discussion_id': discussion_id},
       { ... some fields relevant to your page from the root discussion ...,
         'comments': { '$slice': [ page_num * page_size, page_size ] }
       })

If you wish to view paginated comments for the threaded design, you need
to retrieve the whole document and paginate in your application:

.. code-block:: python

   discussion = db.discussion.find_one({'discussion_id': discussion_id})

   def iter_comments(obj):
       for reply in obj['replies']:
           yield reply
           for subreply in iter_comments(reply):
               yield subreply

   paginated_comments = itertools.slice(
       iter_comments(discussion),
       page_size * page_num,
       page_size * (page_num + 1))

Retrieve a Comment Via Position or Path ("Permalink")
`````````````````````````````````````````````````````

Instead of using slugs as above, this example retrieves comments by their
position in the comment list or tree. In the case of the chronological
(non-threaded) design, you need simply to use the ``$slice`` operator to
extract the correct comment:

.. code-block:: python

   discussion = db.discussion.find_one(
       {'discussion_id': discussion_id},
       {'comments': { '$slice': [ position, position ] } })
   comment = discussion['comments'][0]

In the case of the threaded design, you're faced with the task of
finding the correct path through the tree in your application:

.. code-block:: python

   discussion = db.discussion.find_one({'discussion_id': discussion_id})
   current = discussion
   for part in path:
       current = current.replies[part]
   comment = current

Note that, since the replies to comments are embedded in their parents,
you've have actually retrieved the entire sub-discussion rooted in the
comment you were looking for as well.

Hybrid Schema Design
--------------------

Schema
~~~~~~

Comments in the hybrid format are stored in 'buckets' of about 100
comments each:

.. code-block:: python

   {
       _id: ObjectId(...),
       discussion_id: ObjectId(...),
       page: 1,
       count: 42,
       comments: [ {
           slug: '34db',
           posted: ISODateTime(...),
           author: { id: ObjectId(...), name: 'Rick' },
           text: 'This is so bogus ... ' },
       ... ]
   }

Here, you maintain a "page" of comment data, containing a bit of metadata
about the page (in particular, the page number and the comment count),
as well as the comment bodies themselves. Using a hybrid format actually
makes storing comments hierarchically quite complex, that approach is not covered
in this document.

Note that in this design, 100 comments is a 'soft' limit to the number
of comments per page, chosen mainly for performance reasons and to
ensure that the comment page never grows beyond the 16MB limit MongoDB
imposes on document size. There may be occasions when the number of
comments is slightly larger than 100, but this does not affect the
correctness of the design.

Operations
~~~~~~~~~~

Here, some common operations that you might need for your CMS are
described in the context of 100-comment "pages". Once again, the examples are
in Python.

Post a New Comment
``````````````````

Updating
^^^^^^^^

In order to post a new comment, you need to ``$push`` the comment onto the
last page and ``$inc`` that page's  comment count. If the page has more than 100
comments, you then must will insert a new page as well. This operation starts
with a reference to the discussion document, and assumes that the discussion
document has a property that tracks the number of
pages:

.. code-block:: python

   page = db.comment_pages.find_and_modify(
       { 'discussion_id': discussion['_id'],
         'page': discussion['num_pages'] },
       { '$inc': { 'count': 1 },
         '$push': {
             'comments': { 'slug': slug, ... } } },
       fields={'count':1},
       upsert=True,
       new=True )

Note that the ``find_and_modify()`` above is written as an upsert
operation; if MongoDB doesn't findfind the page number, the ``find_and_modify()``
will create it for you, initialized with appropriate values for ``count`` and
``comments``. Since you're limiting the number of comments per page to around
100, you also need to create new pages as they become necessary:

.. code-block:: python

   if page['count'] > 100:
       db.discussion.update(
           { 'discussion_id: discussion['_id'],
             'num_pages': discussion['num_pages'] },
           { '$inc': { 'num_pages': 1 } } )

The update here includes the last known number of pages in the query in order to
ensure that you don't have a race condition where the number of pages is
double-incremented, resulting in a nearly or totally empty page. If some
other process has incremented the number of pages in the discussion,
then update above simply does nothing.

Indexing
^^^^^^^^

In order to efficiently support the ``find_and_modify()`` and ``update()``
operations above, you need to maintain a compound index on
(``discussion_id``, ``page``) in the ``comment_pages`` collection:

.. code-block:: pycon

   >>> db.comment_pages.ensure_index([
   ...    ('discussion_id', 1), ('page', 1)])

View Paginated Comments for a Discussion
````````````````````````````````````````

In order to paginate comments with a fixed page size (i.e. not with the 100-ish
number of comments on a database "page"), you need to do
a bit of extra work in Python:

.. code-block:: python

   def find_comments(discussion_id, skip, limit):
       result = []
       page_query = db.comment_pages.find(
           { 'discussion_id': discussion_id },
           { 'count': 1, 'comments': { '$slice': [ skip, limit ] } })
       page_query = page_query.sort('page')
       for page in page_query:
           result += page['comments']
           skip = max(0, skip - page['count'])
           limit -= len(page['comments'])
           if limit == 0: break
       return result

Here, the ``$slice`` operator is used to pull out comments from each page,
but *only* if the ``skip`` requirement is satisfied. An example helps illustrate
the logic here. Suppose you have 3 pages with 100, 102,
101, and 22 comments on each. respectively. YOu wish to retrieve comments
with skip=300 and limit=50. The algorithm proceeds as follows:

+-------+-------+-------------------------------------------------------+
| Skip  | Limit | Discussion                                            |
+=======+=======+=======================================================+
| 300   | 50    | ``{$slice: [ 300, 50 ] }`` matches nothing in page    |
|       |       | #1; subtract page #1's ``count`` from ``skip`` and    |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 200   | 50    | ``{$slice: [ 200, 50 ] }`` matches nothing in page    |
|       |       | #2; subtract page #2's ``count`` from ``skip`` and    |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 98    | 50    | ``{$slice: [ 98, 50 ] }`` matches 2 comments in page  |
|       |       | #3; subtract page #3's ``count`` from ``skip``        |
|       |       | (saturating at 0), subtract 2 from limit, and         |
|       |       | continue.                                             |
+-------+-------+-------------------------------------------------------+
| 0     | 48    | ``{$slice: [ 0, 48 ] }`` matches all 22 comments in   |
|       |       | page #4; subtract 22 from ``limit`` and continue.     |
+-------+-------+-------------------------------------------------------+
| 0     | 26    | There are no more pages; terminate loop.              |
+-------+-------+-------------------------------------------------------+


.. note:: 

   Since you already have an index on (``discussion_id``, ``page``) in
   your ``comment_pages`` collection, MongoDB can satisfy these
   queries efficiently.

Retrieve a Comment Via Slug ("Permalink")
`````````````````````````````````````````

Query
^^^^^


Suppose you wish to directly retrieve a comment (e.g. *not* requiring
paging through all preceeding pages of commentary). In this case, you can
use the slug to find the correct page, and then use the application to
find the correct comment:

.. code-block:: python

   page = db.comment_pages.find_one(
       { 'discussion_id': discussion_id,
         'comments.slug': comment_slug},
       { 'comments': 1 })
   for comment in page['comments']:
       if comment['slug'] = comment_slug:
           break

Indexing
^^^^^^^^

Here, you'll need a new index on (``discussion_id``, ``comments.slug``) to
efficiently support retrieving the page number of the comment by slug:

.. code-block:: pycon

   >>> db.comment_pages.ensure_index([
   ...    ('discussion_id', 1), ('comments.slug', 1)])

Sharding
--------

In each of the cases above, it's likely that your ``discussion_id`` will at
least participate in the shard key if you should choose to shard.

In the case of the one document per comment approach, it would be nice
to use the ``slug`` (or ``full_slug``, in the case of threaded comments) as
part of the shard key to allow routing of requests by ``slug``:

.. code-block:: pycon

   >>> db.command('shardcollection', 'comments', {
   ...     key : { 'discussion_id' : 1, 'full_slug': 1 } })

.. code-block:: javascript

   { "collectionsharded" : "comments", "ok" : 1 }

In the case of the fully-embedded comments, of course, the discussion is
the only thing needed to shard, and its shard key will probably be
determined by concerns outside the scope of this document.

In the case of hybrid documents, you'll want to use the page number of the
comment page in the shard key as well as the ``discussion_id`` to allow MongoDB
to split popular discussions among different shards:

.. code-block:: python

   >>> db.command('shardcollection', 'comment_pages', {
   ...     key : { 'discussion_id' : 1, 'page': 1 } })

.. code-block:: javascript

   { "collectionsharded" : "comment_pages", "ok" : 1 }

