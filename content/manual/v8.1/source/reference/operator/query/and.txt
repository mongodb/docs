====
$and
====

.. default-domain:: mongodb

.. facet::
   :name: programming_language
   :values: shell

.. meta::
   :description: Use the $and operator to perform a logical AND operation on expressions, selecting documents satisfying all conditions.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

.. query:: $and

   :query:`$and` performs a logical ``AND`` operation on an array of
   *one or more* expressions (``<expression1>``, ``<expression2>``, and
   so on) and selects the documents that satisfy *all* the expressions.

   .. note::

      MongoDB provides an implicit ``AND`` operation when specifying a
      comma separated list of expressions.

Compatibility
-------------

.. |operator-method| replace:: ``$and``

.. include:: /includes/fact-compatibility.rst

Syntax
------

The :query:`$and` has the following syntax:

.. code-block:: javascript
   
   { $and: [ { <expression1> }, { <expression2> } , ... , { <expressionN> } ] }

Behavior
--------

.. |and-or| replace:: ``$and``
.. |true-false| replace:: ``false``

When evaluating the clauses in the :query:`$and` expression, MongoDB's
query optimizer considers which indexes are available that could
help satisfy clauses of the :query:`$and` expression when
:ref:`selecting the best plan to execute <read-operations-query-optimization>`.
 
.. include:: /includes/and-or-behavior.rst

.. code-block:: javascript

   db.example.find( {
      $and: [
         { x: { $ne: 0 } },
         { $expr: { $eq: [ { $divide: [ 1, "$x" ] }, 3 ] } }
      ]
   } )

Most programming languages and drivers, including the
:ref:`MongoDB Shell <mdb-shell-overview>` (``mongosh``),
do not allow the construction of objects with duplicate keys at the
same object level. For example, consider this query:

.. code-block:: javascript

   db.inventory.find( { price: { $in: [ 7.99, 3.99 ], $in: [ 4.99, 1.99 ] } } )

The above query does not construct correctly because the field name
``price`` has duplicate operators at the same object level. As a
result, the query sent to the server differs from what is intended. For
the query to work as expected, use an explicit ``AND`` operator:

.. code-block:: javascript

   db.inventory.find( {
      $and: [
         { price: { $in: [ 7.99, 3.99 ] } },
         { price: { $in: [ 4.99, 1.99 ] } }
      ]
   } )

This query explicitly checks that both conditions are satisfied:
the ``price`` array must include at least one value from each
:query:`$in` set. For more information on how to address such 
scenarios, see the :ref:`query-and-examples` section.

.. _query-and-examples:

Examples
--------

$and Queries With Multiple Expressions Specifying the Same Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider this query:

.. code-block:: javascript

   db.inventory.find( { $and: [ { price: { $ne: 1.99 } }, { price: { $exists: true } } ] } )

The query selects all documents in the ``inventory`` collection where:

- the ``price`` field value is not equal to ``1.99`` **and**
- the ``price`` field exists.

You can simplify this query by combining the operator expressions for
the ``price`` field into a single query object with a nested implicit
``AND``:

.. code-block:: javascript

   db.inventory.find( { price: { $ne: 1.99, $exists: true } } )

Sometimes such rewrites are not possible, particularly when dealing
with duplicate conditions on the same field. For example:

.. code-block:: javascript

   db.inventory.find( { status: { $ne: "closed", $ne: "archived" } } )

The above query does not construct correctly because it uses the
:query:`$ne` operator more than once on the same ``status`` field name
at the same object level. In this case, the :query:`$nin` operator
provides a more effective solution:

.. code-block:: javascript

   db.inventory.find( { status: { $nin: [ "closed", "archived" ] } } )

How you rewrite a query depends on the intended semantics of your use
case. Consider the following query:

.. code-block:: javascript

   db.inventory.find( {
      $and: [
         { status: "new" },
         { status: "processing" }
      ]
   } )

If you want to find documents where ``status`` is either ``new`` or
``processing``, you can use the :query:`$in` operator:

.. code-block:: javascript

   db.inventory.find( { status: { $in: [ "new", "processing" ] } } )

If your ``status`` field is an array ``[ "new", "processing" ]``, and
you want to check if the document contains both the ``new`` and
``processing`` values, use the :query:`$all` operator:

.. code-block:: javascript

   db.inventory.find( { status: { $all: [ "new", "processing" ] } } )

In this context, this query is semantically equivalent to ``AND``,
but :query:`$all` is often clearer when querying array fields.

Similar to duplicate field names, the same considerations apply for
duplicate operators used in the query.

.. seealso::

   - :method:`~db.collection.find()`
   - :query:`$ne`
   - :query:`$exists`
   - :query:`$in`
   - :query:`$all`