:orphan:

==================================
Development Series 3.1.x Reference
==================================

.. default-domain:: mongodb

MongoDB 3.2 is currently in development as part of the 3.1.x
development release series. 

.. warning::

   While 3.1.x releases are available, these versions of MONGODB are
   for **testing purposes only and not for production use**.

This reference document covers the 3.1 development series as a
work-in-progress. Features are subject to change. See also
:doc:`/release-notes/3.1-dev-series`.

.. TODO For the rc, must find and replace both the version-xxx and 3.1 since the page distinguishes between dev versions as well.

.. |version-dev| replace:: 3.1.6

Aggregation Framework Enhancements
----------------------------------

New Stages
~~~~~~~~~~

MongoDB |version-dev| introduces the following new stage for the
aggregation framework:

.. pipeline:: $sample

   Randomly select N documents from its input.

   The :pipeline:`$sample` stage has the following syntax: 

   .. code-block:: javascript

      { $sample: { size: <positive integer> } }

   For example, the following aggregation operation randomly selects
   ``5`` documents from the collection:

   .. code-block:: javascript

      db.datasets.aggregate(
         { $sample: { size: 5 } }
      )

   .. warning::

      - :pipeline:`$sample` may output the same document more than once
        in its result set. For more information, see
        :ref:`cursor-isolation`.

      - :pipeline:`$sample` as the first stage requires a collection
        scan.

MongoDB Enterprise 3.1.7 introduces the following new
stage for the aggregation framework:

.. pipeline:: $lookUp

   .. include:: /includes/fact-enterprise-only-admonition.rst

   Performs a left outer join to another collection in the *same*
   database to filter in documents from the "joined" collection for
   processing. The :pipeline:`$lookUp` stage does an equality match
   between a field from the input documents with a field from the
   documents of the "joined" collection.

   To each input document, the :pipeline:`$lookUp` stage adds a new
   array field whose elements are the matching documents from the
   "joined" collection. The :pipeline:`$lookUp` stage passes these
   reshaped documents to the next stage.
   The :pipeline:`$lookUp` stage has the following syntax: 

   .. code-block:: none

      {
         $lookUp:
           {
             from: <collection to join>,
             localField: <field from the input documents>,
             foreignField: <field from the documents of the "from" collection>,
             as: <output array field>
           }
      }

   The :pipeline:`$lookUp` takes a document with the following fields:
   
   .. list-table::
      :header-rows: 1
      :widths: 20 80

      * - Field
        - Description

      * - ``from``

        - Specifies the collection in the *same* database to perform
          the join with. The ``from`` collection cannot be sharded.

      * - ``localField``

        - Specifies the field from the documents input to the
          :pipeline:`$lookUp` stage. :pipeline:`$lookUp` performs an
          equality match on the ``localField`` to the
          ``foreignField`` from the documents of the ``from``
          collection. If an input document does not contain the
          ``localField``, the :pipeline:`$lookUp` treats the
          field as having a value of ``null`` for matching purposes.

      * - ``foreignField``

        - Specifies the field from the documents in the ``from``
          collection. :pipeline:`$lookUp` performs an equality match on
          the ``foreignField`` to the ``localField`` from the input
          documents. If a document in the ``from`` collection does not
          contain the ``foreignField``, the :pipeline:`$lookUp` treats
          the value as ``null`` for matching purposes.

      * - ``as``

        - Specifies the name of the new array field to add to the input
          documents. The new array field contains the matching
          documents from the ``from`` collection. If the specified name
          already exists in the input document, the existing field is
          *overwritten*.

   For example, a collection ``orders`` contain the following documents:

   .. code-block:: javascript

      { "_id" : 1, "item" : "abc", "price" : 12, "quantity" : 2 }
      { "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1 }
      { "_id" : 3  }

   Another collection ``inventory`` contains the following documents:

   .. code-block:: javascript

      { "_id" : 1, "sku" : "abc", description: "product 1", "instock" : 120 }
      { "_id" : 2, "sku" : "def", description: "product 2", "instock" : 80 }
      { "_id" : 3, "sku" : "ijk", description: "product 3", "instock" : 60 }
      { "_id" : 4, "sku" : "jkl", description: "product 4", "instock" : 70 }
      { "_id" : 5, "sku": null, description: "Incomplete" }
      { "_id" : 6 }

   The following aggregation operation on the ``orders`` collection
   joins the documents from ``orders`` with the documents from the
   ``inventory`` collection using the fields ``item`` from the
   ``orders`` collection and the ``sku`` field from the ``inventory``
   collection:

   .. code-block:: javascript

      db.orders.aggregate([
          {
            $lookUp:
              {
                from: "inventory",
                localField: "item",
                foreignField: "sku",
                as: "inventory_docs"
              }
         }
      ])

   The operation returns the following documents:

   .. code-block:: javascript

      {
        "_id" : 1,
        "item" : "abc",
        "price" : 12,
        "quantity" : 2,
        "inventory_docs" : [
           { "_id" : 1, "sku" : "abc", description: "product 1", "instock" : 120 }
        ]
      }
      {
        "_id" : 2,
        "item" : "jkl",
        "price" : 20,
        "quantity" : 1,
        "inventory_docs" : [
            { "_id" : 4, "sku" : "jkl", "description" : "product 4", "instock" : 70 }
        ]
      }
      {
        "_id" : 3,
        "inventory_docs" : [
           { "_id" : 5, "sku" : null, "description" : "Incomplete" },
           { "_id" : 6 }
        ]
      }

.. pipeline:: $indexStats

   Returns statistics regarding the use of each index for the
   collection. If running with :doc:`access control
   </core/authorization>`, the user must have privileges that include
   :authaction:`indexStats` action.

   The :pipeline:`$indexStats` stage takes an empty document and has
   the following syntax:

   .. code-block:: javascript

      { $indexStats: { } }

   For example, a collection ``orders`` contain the following documents:

   .. code-block:: javascript

      { "_id" : 1, "item" : "abc", "price" : 12, "quantity" : 2, "type": "apparel" }
      { "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "type": "electronics" }
      { "_id" : 3, "item" : "abc", "price" : 10, "quantity" : 5, "type": "apparel" }

   Create the following two indexes on the collection:

   .. code-block:: javascript

      db.orders.createIndex( { item: 1, quantity: 1 } )
      db.orders.createIndex( { type: 1, item: 1 } )

   Run some queries against the collection:

   .. code-block:: javascript

      db.orders.find( { type: "apparel"} )
      db.orders.find( { item: "abc" } ).sort( { quantity: 1 } )

   To view statistics on the index use on the ``orders`` collection,
   run the following aggregation operation:

   .. code-block:: javascript

      db.orders.aggregate( [ { $indexStats: { } } ] )

   The operation returns a document that contains usage statistics for
   each index:

   .. code-block:: json
   
      {
         "name" : "item_1",
         "ns" : "test.orders",
         "processName" : "examplehost.local:27017", 
         "usageStats" : { "operations" : NumberLong(1), "validSince" : ISODate("2015-09-10T17:45:00.837Z") }
      }

      {
         "name" : "_id_",
         "ns" : "test.orders",
         "processName" : "examplehost.local:27017",
         "usageStats" : { "operations" : NumberLong(0), "validSince" : ISODate("2015-09-10T17:44:47.531Z") } }

      {
         "name" : "type_1_item_1",
         "ns" : "test.orders",
         "processName" : "examplehost.local:27017",
         "usageStats" : { "operations" : NumberLong(1), "validSince" : ISODate("2015-09-10T17:45:05.986Z") }
      }

   The result include the following fields:

   .. list-table::
      :header-rows: 1
      :widths: 30 70

      * - Output Field
        - Description

      * - ``name``
        - Index name.

      * - ``ns``

        - The namespace (i.e. ``<database>.<collection>``) for the index

      * - ``processName``

        - The hostname and port of process.

      * - ``usageStats``

        - Statistics on the index use:

          - ``operations`` is the number of operations that used the
            index.

          - ``validSince`` is the time from which MongoDB gathered the
            statistics.

   Statistics for an index will be reset on :program:`mongod` restart
   or index drop and recreation.

New Accumulators for ``$group`` Stage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MongoDB |version-dev| introduces the following new accumulators for the
aggregation framework:

.. group:: $stdDevSamp

   Calculates the sample standard deviation of the input values. Use if
   the values encompasses a sample of a population of data from which
   to generalize about the population. Use :group:`$stdDevPop` if the
   values represent the entire population of data or you do not wish to
   generalize about a larger population.

.. group:: $stdDevPop

   Calculates the population standard deviation of the input values.
   Use if the values encompasses the entire population of data you want
   to represent and do not wish to generalize about a larger
   population. Use :group:`$stdDevSamp` if the values represent only a
   sample of a population of data from which to generalize about the
   population.

New Arithmetic Expression Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. TODO When moving to separate pages, use an extract file to single-source null/NaN argument behavior.

MongoDB |version-dev| and 3.1.7 introduces the following
new arithmetic operators for the aggregation framework:

.. expression:: $sqrt

   Calculates the square root of a positive number and returns the
   result as a double.

   :expression:`$sqrt` has the following syntax:

   .. code-block:: javascript

      { $sqrt: <number> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a *non-negative*
   number. For more information
   on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$sqrt` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$sqrt` returns ``NaN``.

   :expression:`$sqrt` errors on negative numbers.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $sqrt: 25 }``
        - ``5``

      * - ``{ $sqrt: 30 }``
        - ``5.477225575051661``

      * - ``{ $sqrt: null }``
        - ``null``

.. expression:: $abs 

   Returns the absolute value of a number.

   :expression:`$abs` has the following syntax:

   .. code-block:: javascript

      { $abs: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number. For
   more information on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$abs` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$abs` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $abs: -1 }``
        - ``1``

      * - ``{ $abs: 1 }``
        - ``1``

      * - ``{ $abs: null }``
        - ``null``

.. expression:: $log 

   .. versionadded:: 3.1.7

   Calculates the log of a number in the specified base and returns the
   result as a double.

   :expression:`$log` has the following syntax:

   .. code-block:: javascript

      { $log: [ <number>, <base> ] }
   
   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a non-negative number.

   The ``<base>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a positive
   number greater than ``1``.

   If either argument resolves to a value of ``null`` or refers to a
   field that is missing, :expression:`$log` returns ``null``. If
   either argument resolves to ``NaN``, :expression:`$log` returns
   ``NaN``.

   For more information on expressions, see
   :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $log: [ 100, 10 ] }``
        - ``2``

      * - ``{ $log: [ 100, Math.E ] }`` where ``Math.E`` is a JavaScript representation for *e*.

        - ``4.605170185988092``

   For example:

   .. code-block:: javascript

      db.datasets.aggregate( [ { $project: { logResult: { $log: [ 10, 10 ] } } } ] )

   .. seealso:: :expression:`$log10` and :expression:`$ln`

.. expression:: $log10 

   .. versionadded:: 3.1.7

   Calculates the log base 10 of a number and returns the result as a
   double.

   :expression:`$log10` has the following syntax:

   .. code-block:: javascript

      { $log10: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a non-negative
   number. For more information on expressions, see
   :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$log10` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$log10` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $log10: 1 }``
        - ``0``

      * - ``{ $log10: 10 }``
        - ``1``

      * - ``{ $log10: 100 }``
        - ``2``

      * - ``{ $log10: 1000 }``
        - ``3``

   For example:

   .. code-block:: javascript

      db.datasets.aggregate( [ { $project: { logResult: { $log10: 10 } } } ] )

   :expression:`$log10` is equivalent to ``$log: [ <number>, 10 ]`` expression.

   .. seealso:: :expression:`$log`

.. expression:: $ln 

   .. versionadded:: 3.1.7

   Calculates the natural logarithm *ln* (i.e log\ :sub:`e`) of a number and
   returns the result as a double.

   :expression:`$ln` has the following syntax:

   .. code-block:: javascript

      { $ln: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a non-negative
   number. For more information on expressions, see
   :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$ln` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$ln` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $ln: 1 }``
        - ``0``

      * - ``{ $ln: Math.E }`` where ``Math.E`` is a JavaScript representation for *e*.
        - ``1``

      * - ``{ $ln: 10  }``
        - ``2.302585092994046``

   For example:

   .. code-block:: javascript

      db.datasets.aggregate( [ { $project: { logResult: { $ln: 10 } } } ] )

   :expression:`$ln` is equivalent to ``$log: [ <number>, Math.E ]``
   expression, where ``Math.E`` is a JavaScript representation for
   Euler's number *e*.

   .. seealso:: :expression:`$log`

.. expression:: $pow 

   .. versionadded:: 3.1.7

   Raises a number to the specified exponent and returns the result.
   
   The result will have the same type as the input except when it
   cannot be represented accurately in that type. In these cases:
   
   - A 32-bit integer will be converted to a 64-bit integer if the
     result is representable as a 64-bit integer.
   
   - A 32-bit integer will be converted to a double if the result is
     not representable as a 64-bit integer.

   - A 64-bit integer will be converted to double if the result is not
     representable as a 64-bit integer.

   :expression:`$pow` has the following syntax:

   .. code-block:: javascript

      { $pow: [ <number>, <exponent> ] }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a non-negative
   number.

   The ``<exponent>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number.

   If either argument resolves to a value of ``null`` or refers to a
   field that is missing, :expression:`$pow` returns ``null``. If
   either argument resolves to ``NaN``, :expression:`$pow` returns
   ``NaN``. You cannot raise ``0`` to a negative exponent.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $pow: [ 5, 0 ] }``
        - ``1``

      * - ``{ $pow: [ 5, 2 ] }``
        - ``25``

      * - ``{ $pow: [ 5, -2 ] }``
        - ``0.04``

   For example:

   .. code-block:: javascript

      db.datasets.aggregate( [ { $project: { raisedTo2: { $pow: [ 5, 2 ] } } } ] )

.. expression:: $exp 

   .. versionadded:: 3.1.7

   Raises Euler's number (i.e. *e* ) to the specified exponent and
   returns the result. 

   :expression:`$exp` has the following syntax:

   .. code-block:: javascript

      { $exp: <exponent> }

   The ``<exponent>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number. For
   more information on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$exp` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$exp` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $exp: 0 }``
        - ``1``

      * - ``{ $exp: 2 }``
        - ``7.38905609893065``

      * - ``{ $exp: -2 }``
        - ``0.1353352832366127``

   For example:

   .. code-block:: javascript

      db.datasets.aggregate( [ { $project: { eRaisedTo2: { $exp: 2 } } } ] )

.. expression:: $trunc

   .. versionadded:: 3.1.7

   Truncates a number to its integer.

   :expression:`$trunc` has the following syntax:

   .. code-block:: javascript

      { $trunc: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number. For
   more information on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$trunc` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$trunc` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $trunc: 0 }``
        - ``0``

      * - ``{ $trunc: 7.80 }``
        - ``7``

      * - ``{ $trunc: -2.3 }``
        - ``-2``

.. expression:: $ceil

   .. versionadded:: 3.1.7

   Returns the smallest integer greater than or equal to the specified
   number.

   :expression:`$ceil` has the following syntax:

   .. code-block:: javascript

      { $ceil: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number. For
   more information on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$ceil` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$ceil` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $ceil: 1 }``
        - ``1``

      * - ``{ $ceil: 7.80 }``
        - ``8``

      * - ``{ $ceil: -2.8 }``
        - ``-2``

.. expression:: $floor

   .. versionadded:: 3.1.7

   Returns the largest integer less than or equal to the specified
   number.

   :expression:`$floor` has the following syntax:

   .. code-block:: javascript

      { $floor: <number> }

   The ``<number>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a number. For
   more information on expressions, see :ref:`aggregation-expressions`.

   If the argument resolves to a value of ``null`` or refers to a field
   that is missing, :expression:`$floor` returns ``null``. If the
   argument resolves to ``NaN``, :expression:`$floor` returns ``NaN``.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $floor: 1 }``
        - ``1``

      * - ``{ $floor: 7.80 }``
        - ``7``

      * - ``{ $floor: -2.8 }``
        - ``-3``

New Array Expression Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MongoDB |version-dev| introduces the following new array operators for the
aggregation framework:

.. expression:: $slice

   Returns a subset of an array.

   :expression:`$exp` has one of two syntax forms:

   The following syntax returns elements from either the start or end
   of the array:

   .. code-block:: javascript

      { $slice: [ <array>, <n> ] }

   The following syntax returns elements from the specified position in
   the array:

   .. code-block:: javascript

      { $slice: [ <array>, <position>, <n> ] }

   The ``<array>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an array.

   The optional ``<position>`` expression can be any valid
   :ref:`expression <aggregation-expressions>` as long as it resolves
   to an integer.

   - If positive, :expression:`$slice` determines the starting position
     from the start of the array. If ``<position>`` is greater than the
     number of elements, the :expression:`$slice` returns an empty
     array.

   - If negative, :expression:`$slice` determines the starting position
     from the end of the array. If the absolute value of the
     ``<position>`` is greater than the number of elements, the
     starting position is the start of the array.

   The ``<n>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an integer. If
   ``<position>`` is specified, ``<n>`` must resolve to a positive
   integer.
   

   - If positive, :expression:`$slice` returns up to the first ``n``
     elements in the array. If the ``<position>`` is specified,
     :expression:`$slice` returns the first ``n`` elements starting
     from the position.

   - If negative, :expression:`$slice` returns up to the last ``n``
     elements in the array. ``n`` cannot resolve to a negative number
     *if* ``<position>`` is specified.

   For more information on expressions, see
   :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1
      :widths: 85 15

      * - Example
        - Results

      * - ``{ $slice: [ [ 1, 2, 3 ], 1, 1 ] }``
        - ``[ 2 ]``

      * - ``{ $slice: [ [ 1, 2, 3 ], -2 ] }``
        - ``[ 2, 3 ]``

      * - ``{ $slice: [ [ 1, 2, 3 ], 15, 2 ] }``
        - ``[  ]``

      * - ``{ $slice: [ [ 1, 2, 3 ], -15, 2 ] }``
        - ``[ 1, 2 ]``

.. expression:: $arrayElemAt

   Returns the element at the specified array index.

   :expression:`$arrayElemAt` has the following syntax:

   .. code-block:: javascript

      { $arrayElemAt: [ <array>, <idx> ] }

   The ``<array>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an array.

   The ``<idx>`` expression can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an integer.

   - If positive, :expression:`$arrayElemAt` returns the element at the
     ``idx`` position, counting from the start of the array.

   - If negative, :expression:`$arrayElemAt` returns the element at the
     ``idx`` position, counting from the end of the array.

   For more information on expressions, see
   :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1
      :widths: 90 10

      * - Example
        - Results

      * - ``{ $arrayElemAt: [ [ 1, 2, 3 ], 0 ] }``
        - ``1``

      * - ``{ $arrayElemAt: [ [ 1, 2, 3 ], -2 ] }``
        - ``2``

      * - ``{ $arrayElemAt: [ [ 1, 2, 3 ], 15 ] }``
        - 

   If the ``idx`` exceeds the array bounds, :expression:`$arrayElemAt`
   does not return any result.

.. expression:: $concatArrays

   Concatenates arrays to return the concatenated array.

   :expression:`$concatArrays` has the following syntax:

   .. code-block:: javascript

      { $concatArrays: [ <array1>, <array2>, ... ] }

   The ``<array>`` expressions can be any valid :ref:`expression
   <aggregation-expressions>` as long as they resolve to an array. For
   more information on expressions, see :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1
      :widths: 65 35

      * - Example
        - Results

      * - ``{ $concatArrays: [ [ "hello", " "], [ "world" ] ] }``
        - ``[ "hello", " ", "world" ]``

      * - ``{ $concatArrays: [ [ "hello", " "], [ [ "world" ], "again"] ] }``
        - ``[ "hello", " ", [ "world" ], "again" ]``

.. expression:: $isArray

   Determines if the operand is an array. Returns a boolean.

   :expression:`$isArray` has the following syntax:

   .. code-block:: javascript

      { $isArray: [ <expression> ] }

   The ``<expression>`` can be any valid :ref:`expression
   <aggregation-expressions>`. For more information on expressions, see
   :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1
      :widths: 90 10

      * - Example
        - Results

      * - ``{ $isArray: [ "hello" ] }``
        - ``false``

      * - ``{ $isArray: [ [ "hello", "world" ] ] }``
        - ``true``

.. expression:: $filter

   Selects a subset of the array to return based on the specified
   condition. Returns an array with only those elements that match the
   condition. The returned elements are in the original order.

   :expression:`$filter` has the following syntax:

   .. code-block:: javascript

      { $filter: { input: <array>, as: <string>, cond: <expression> } }

   .. list-table::
      :header-rows: 1
      :widths: 20 80

      * - Field
        - Specification

      * - ``input``

        - An :ref:`expression <aggregation-expressions>` that
          resolves to an array.

      * - ``as``

        - The variable name for the element in the ``input`` array. The
          ``as`` expression accesses each element in the ``input``
          array by this :doc:`variable
          </reference/aggregation-variables>`.

      * - ``cond``

        - The :ref:`expression <aggregation-expressions>` that
          determines whether to include the element in the resulting
          array. The expression accesses the element by the variable
          name specified in ``as``.

   For more information on expressions, see
   :ref:`aggregation-expressions`.

   .. list-table::
      :header-rows: 1

      * - Example
        - Results

      * - .. code-block:: javascript

             {
               $filter: {
                  input: [ 1, "a", 2, null, 3.1, NumberLong(4), "5" ],
                  as: "num",
                  cond: { $and: [
                     { $gte: [ "$$num", NumberLong("-9223372036854775807") ] }, 
                     { $lte: [ "$$num", NumberLong("9223372036854775807") ] }
                   ] } 
               }
             }

        - ``[ 1, 2, 3.1, NumberLong(4) ]``

``mongo`` Shell Enhancements
----------------------------

To provide consistency with the MongoDB drivers' CRUD
(Create/Read/Update/Delete) API, the :program:`mongo` shell introduces
additional CRUD methods that are consistent with the drivers' CRUD API:

.. _db.collection.deleteMany:

.. method:: db.collection.deleteMany()

   Deletes all documents that match the ``filter`` condition. The
   method is equivalent to :method:`db.collection.remove()`.

   :method:`db.collection.deleteMany()` has the following form:

   .. code-block:: javascript

      db.collection.deleteMany( <filter>, { writeConcern: <document> } )

   The method has the following parameters:

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to delete all documents.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example deletes all documents with the ``status``
   field equal to ``"A"``.

   .. code-block:: javascript

      db.sample.deleteMany( { status: "A" }, { writeConcern: { w: "majority", wtimeout: 5000 } } )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "deletedCount" : 2 }

.. _db.collection.deleteOne:

.. method:: db.collection.deleteOne()

   Deletes a single document that match the ``filter`` condition. The
   method deletes a single document even if multiple documents match
   the ``filter``. :method:`db.collection.deleteOne()` is equivalent to
   the :method:`db.collection.remove()` with the ``justOne`` set to
   true.

   :method:`db.collection.deleteOne()` has the following form:

   .. code-block:: javascript

      db.collection.deleteOne( <filter>, { writeConcern: <document> } )

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to delete all documents.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example deletes one document with the ``status`` field
   equal to ``"A"``.

   .. code-block:: javascript

      db.sample.deleteOne( { status: "A" }, { writeConcern: { w: "majority", wtimeout: 5000 } } )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "deletedCount" : 1 }

.. method:: db.collection.findOneAndDelete()

   Removes a single document that matches the ``filter`` condition and
   returns the removed document. The method is equivalent to
   :method:`db.collection.findAndModify()` method with ``remove`` set
   to true.

   :method:`db.collection.findOneAndDelete()` has the following form:

   .. code-block:: javascript

      db.collection.findOneAndDelete( 
         <filter>,
         {
           sort: <document>,
           projection: <document>,
           writeConcern: <document>,
           maxTimeMS: <integer>
         }
      )

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to match any document.

   - Optional. ``sort`` is a document that sorts the matching documents
     in order to determine which document the operation removes if the
     filter matches multiple documents. The method removes the first
     document in the sort order specified by this argument.

   - Optional. ``projection`` is document that specifies which fields
     to return in the return document.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   - Optional. ``maxTimeMS`` is an integer that specifies a cumulative
     time limit in milliseconds for processing operations on a cursor.
     See :method:`cursor.maxTimeMS` for more information.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example finds and deletes one document with the
   ``status`` field equal to ``"A"``. The example includes a ``sort``
   document to order the matching documents by descending ``_id``
   values, such that the delete removes the matching document with the
   greatest ``_id`` value:

   .. code-block:: javascript

      db.sample.findOneAndDelete(
         { status: "A" }, 
         { sort: { _id: -1 }, writeConcern: { w: "majority", wtimeout: 5000 } } 
      )

   The method returns the removed document:

   .. code-block:: javascript

      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }

   If no document matches the filter condition, the method returns null.

.. method:: db.collection.findOneAndReplace()

   Replaces a single document that matches the ``filter`` condition and
   returns either the pre-replacement version of the document or the
   post-replacement version of the document. The method is equivalent
   to :method:`db.collection.findAndModify()` method with ``update``
   set to a replacement document.

   :method:`db.collection.findOneAndReplace()` has the following form:

   .. code-block:: javascript

      db.collection.findOneAndReplace( 
         <filter>,
         <replacement>
         {
           sort: <document>,
           projection: <document>,
           upsert: <boolean>,
           returnNewDocument: <boolean>
           writeConcern: <document>,
           maxTimeMS: <integer>
         }
      )

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to match any document.

   - ``<replacement>`` is a document with which to replace the matching
     document. The ``<replacement>`` document cannot specify an ``_id``
     value that differs from the replaced document.

   - Optional. ``sort`` is a document that sorts the matching documents
     in order to determine which document the operation replaces if the
     filter matches multiple documents. The method replaces the first
     document in the sort order specified by this argument.

   - Optional. ``projection`` is document that specifies which fields
     to return in the return document.

   - Optional. ``upsert`` is a boolean that specifies whether the
     operation should create a new document when no document matches
     the ``filter`` conditions. See :term:`upsert` for details.
     The default value is ``false``.

   - Optional. ``returnNewDocument`` is a boolean that determines
     whether the method returns the pre-replacement document or
     post-replacement document. The default value is ``false``.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   - Optional. ``maxTimeMS`` is an integer that specifies a cumulative
     time limit in milliseconds for processing operations on a cursor.
     See :method:`cursor.maxTimeMS` for more information.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example finds and replaces one document with the
   ``status`` field equal to ``"A"``. The example includes a ``sort``
   document to order the matching documents by descending ``_id``
   values, such that the method replaces the matching document with the
   greatest ``_id`` value:

   .. code-block:: javascript

      db.sample.findOneAndReplace(
         { status: "A" },
         { "a": 5, b: 5, status: "U" },
         { sort: { _id: -1 }, writeConcern: { w: "majority", wtimeout: 5000 } } 
      )

   The method returns the replaced document:

   .. code-block:: javascript

      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }

.. method:: db.collection.findOneAndUpdate()

   Updates a single document that matches the ``filter`` condition and
   returns either the pre-update version of the document or the
   post-update version of the document. The method is equivalent to
   :method:`db.collection.findAndModify()` method with ``update`` set
   to a document that specifies modifications using :doc:`update
   operators </reference/operator/update>`.

   :method:`db.collection.findOneAndUpdate()` has the following form:

   .. code-block:: javascript

      db.collection.findOneAndUpdate( 
         <filter>,
         <modifications>
         {
           sort: <document>,
           projection: <document>,
           upsert: <boolean>,
           returnNewDocument: <boolean>
           writeConcern: <document>,
           maxTimeMS: <integer>
         }
      )

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to match any document.

   - ``<modifications>`` is a document that specifies the modifications
     using the :doc:`update operators </reference/operator/update>`.

   - Optional. ``sort`` is a document that sorts the matching documents
     in order to determine which document the operation updates if the
     filter matches multiple documents. The method updates the first
     document in the sort order specified by this argument.

   - Optional. ``projection`` is document that specifies which fields
     to return in the return document.

   - Optional. ``upsert`` is a boolean that specifies whether the
     operation should create a new document when no document matches
     the ``filter`` conditions. See :term:`upsert` for details.
     The default value is ``false``.

   - Optional. ``returnNewDocument`` is a boolean that determines
     whether the method returns the pre-replacement document or
     post-replacement document. The default value is ``false``.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   - Optional. ``maxTimeMS`` is an integer that specifies a cumulative
     time limit in milliseconds for processing operations on a cursor.
     See :method:`cursor.maxTimeMS` for more information.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example finds and updates one document with the
   ``status`` field equal to ``"A"``. The example includes a ``sort``
   document to order the matching documents by descending ``_id``
   values, such that the method replaces the matching document with the
   greatest ``_id`` value:

   .. code-block:: javascript

      db.sample.findOneAndUpdate(
         { status: "A" },
         {
           $set: { a: [ 5, 10 ], status: "U" },
           $mul: { b: 10 },
           $currentDate: { lastModified: true }
         },
         {
           sort: { _id: -1 },
           returnNewDocument: true,
           writeConcern: { w: "majority", wtimeout: 5000 }
         }
      )

   The method returns the updated document after the modifications:

   .. code-block:: javascript

      {
        "_id" : 3,
        "a" : [ 5, 10 ],
        "b" : 30,
        "status" : "U",
        "lastModified" : ISODate("2015-08-12T01:08:47.098Z")
      }

.. method:: db.collection.insertMany()

   Inserts multiple documents into the collection. The method is
   equivalent to :method:`db.collection.insert()` method with an array
   of documents as the parameter.

   :method:`db.collection.insertMany()` has the following form:

   .. code-block:: javascript

      db.collection.insertMany( [ <document1>, <document2>,... ], { writeConcern: <document> } )

   - ``<documents>`` are the documents to insert.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   The following example inserts three documents into the ``sample`` collection:

   .. code-block:: javascript

      db.sample.insertMany(
         [
            { _id: 10, a: 10, status: "A" },
            { _id: 11, a: 11, status: "A" },
            { _id: 12, a: 12, status: "A" }
         ],
         { writeConcern: { w: "majority", wtimeout: 5000 } }
      )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "insertedIds" : [ 10, 11, 12 ] }

.. _db.collection.insertOne:

.. method:: db.collection.insertOne()

   Inserts a single document into the collection. The method is
   equivalent to :method:`db.collection.insert()` method with a single
   document as the parameter.

   :method:`db.collection.insertOne()` has the following form:

   .. code-block:: javascript

      db.collection.insertOne( <document>, { writeConcern: <document> } )

   - ``<document>`` is the document to insert.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   The following example inserts a document into the ``sample`` collection:

   .. code-block:: javascript

      db.sample.insertOne(
         { _id: 15, a: 15, status: "D" },
         { writeConcern: { w: "majority", wtimeout: 5000 } }
      )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "insertedId" : 15 }

.. _db.collection.replaceOne:

.. method:: db.collection.replaceOne()

   Replaces a single document that match the ``filter`` condition with
   the specified ``replacement`` document. The method is equivalent to
   :method:`db.collection.update( \<query\>, \<update\> )
   <db.collection.update()>` method with a replacement document as the
   ``<update>`` parameter.

   :method:`db.collection.replaceOne()` has the following form:

   .. code-block:: javascript

     db.collection.replaceOne( <filter>, <replacement>, { upsert: <boolean>, writeConcern: <document> } }

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to delete all documents.

   - ``<replacement>`` is a document with which to replace the matching
     document. The ``<replacement>`` document cannot specify an ``_id``
     value that differs from the replaced document.

   - Optional. ``upsert`` is a boolean that specifies whether the
     update operation should create a new document when no document
     matches the ``filter`` conditions. See :term:`upsert` for details.
     The default value is ``false``.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "status" : "D" }

   The following example finds and replaces one document with the
   ``status`` field equal to ``"A"``.

   .. code-block:: javascript

      db.sample.replaceOne(
         { status: "A" },
         { x: 1, y: 1, z: 1 },
         { writeConcern: { w: "majority", wtimeout: 5000 } }
      )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

.. _db.collection.updateMany:

.. method:: db.collection.updateMany()

   Updates all documents that match the ``filter`` condition. The
   method is equivalent to :method:`db.collection.update( \<query\>,
   \<update\>, { multi: true, ... }) <db.collection.update()>` method
   with an ``<update>`` document that specifies modifications using
   :doc:`update operators </reference/operator/update>` and the
   ``multi`` option set to true.

   :method:`db.collection.updateMany()` has the following form:

   .. code-block:: javascript

      db.collection.updateMany( <filter>, <update>, { upsert: <boolean>, writeConcern: <document> } }

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to delete all documents.

   - ``<update>`` is a document that specifies the modifications to
     perform using the :doc:`update operators
     </reference/operator/update>`.

   - Optional. ``upsert`` is a boolean that specifies whether the
     update operation should create a new document when no document
     matches the ``filter`` conditions. See :term:`upsert` for details.
     The default value is ``false``.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "c": 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "c": 1, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "c": 1, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "c": 1, "status" : "D" }

   The following example finds and modifies all documents with the
   ``status`` field equal to ``"A"``.

   .. code-block:: javascript

      db.sample.updateMany(
         { status: "A" },
         {
           $set: { a: 5, status: "U" },
           $mul: { b: 10, c: 5 },
           $currentDate: { lastModified: true }
         },
         { writeConcern: { w: "majority", wtimeout: 5000 } }
      )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }

.. _db.collection.updateOne:

.. method:: db.collection.updateOne()

   Updates a single document that match the ``filter`` condition. The
   method updates a single document even if multiple documents match
   the ``filter`` and is equivalent to :method:`db.collection.update(
   <query>, <update> ) <db.collection.update()` method with an
   ``<update>`` document that specifies modifications using
   :doc:`update operators </reference/operator/update>`.

   .. code-block:: javascript

      db.collection.updateOne( <filter>, <update>, { upsert: <boolean>, writeConcern: <document> } }

   - ``<filter>`` is a document that specifies conditions using
     :ref:`query selectors <query-selectors>`. Specify an empty
     document ``{}`` to delete all documents.

   - ``<update>`` is a document that specifies the modifications to
     perform using the :doc:`update operators
     </reference/operator/update>`.

   - Optional. ``upsert`` is a boolean that specifies whether the
     update operation should create a new document when no document
     matches the ``filter`` conditions. See :term:`upsert` for details.
     The default value is ``false``.

   - Optional. ``writeConcern`` is a document expressing the
     :doc:`write concern </core/write-concern>`. Omit to use the
     default write concern.

   Consider a collection ``sample`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "a" : 1, "b" : 1, "c": 1, "status" : "A" }
      { "_id" : 2, "a" : 2, "b" : 2, "c": 1, "status" : "U" }
      { "_id" : 3, "a" : 3, "b" : 3, "c": 1, "status" : "A" }
      { "_id" : 4, "a" : 4, "b" : 4, "c": 1, "status" : "D" }

   The following example finds and modifies all documents with the
   ``status`` field equal to ``"A"``.

   .. code-block:: javascript

      db.sample.updateOne(
         { status: "A" },
         {
           $set: { a: 5, status: "U" },
           $mul: { b: 10, c: 5 },
           $currentDate: { lastModified: true }
         },
         { writeConcern: { w: "majority", wtimeout: 5000 } }
      )

   The method returns a document with the status of the operation:

   .. code-block:: javascript

      { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

.. method:: db.collection.bulkWrite()

   Performs bulk writes on a collection. The bulk write operations can
   be either *ordered* or *unordered*. With an ordered list of
   operations, MongoDB executes the operations serially. If an error
   occurs during the processing of one of the write operations, MongoDB
   will return without processing any remaining write operations in the
   list.

   With an unordered list of operations, MongoDB can execute the
   operations in parallel. If an error occurs during the processing of
   one of the write operations, MongoDB will continue to process
   remaining write operations in the list.

   :method:`db.collection.bulkWrite()` has the following form:

   .. code-block:: javascript

      db.collection.bulkWrite(
         [ <operation1>, <operation2>, ... ],
         {
           ordered: <boolean>,
           writeConcern: <document>
         }
      )

   .. TODO remove internal hyperlink targets and use :method: when moving into separate pages

   The method accepts an array of ``<operations>`` to perform in bulk.
   The ``<operations>`` correspond to db.collection.insertOne_,
   db.collection.updateOne_, db.collection.updateMany_,
   db.collection.replaceOne_, db.collection.deleteOne_, and
   db.collection.deleteMany_ methods, and the array can include these
   operations in any combination.

   The method also accepts an optional document to specify whether to
   execute the list in *ordered* (the default) or in *unordered*
   sequence as well as the :doc:`write concern </core/write-concern>`.

   Specify the ``<operations>`` in the following form:

   .. list-table::

      * - .. code-block:: json

             { insertOne: { document: <document> } }

      * - .. code-block:: json

             { updateOne: { filter: <document>, update: <document>, upsert: <boolean> } }

      * - .. code-block:: json

             { updateMany: { filter: <document>, update: <document>, upsert: <boolean> } }

      * - .. code-block:: json

             { replaceOne: { filter: <document>, replacement: <document>, upsert: <boolean> } }

      * - .. code-block:: json

             { deleteOne: { filter: <document> } }

      * - .. code-block:: json

             { deleteMany: { filter: <document> } }

   The following example uses :method:`db.collection.bulkWrite()`
   method to insert four documents into the ``sample`` collection,
   update all documents that matches the specified filter. The example
   specifies that MongoDB executes the operations in an ordered
   sequence, uses a write concern of ``"majority"`` and a
   :ref:`wc-wtimeout` of ``5000`` milliseconds.

   .. code-block:: javascript

      db.sample.bulkWrite(
         [
            { insertOne: { document: { _id: 1, a: 1, b: 1, status: "A" } } },
            { insertOne: { document: { _id: 2, a: 2, b: 2, status: "N" } } },
            { insertOne: { document: { _id: 3, a: 3, b: 3, status: "A" } } },
            { insertOne: { document: { _id: 4, a: 4, b: 4, status: "D" } } },
            { updateMany: { filter: { status: "N" }, update: { $set: { status: "U" } } } },
            { ordered: true, writeConcern: { w: "majority", wtimeout: 5000 } }
         ]
      )

   The method returns the status of the operations:

   .. code-block:: javascript

      {
         "acknowledged" : true,
         "deletedCount" : 0,
         "insertedCount" : 4,
         "matchedCount" : 1,
         "upsertedCount" : 0,
         "insertedIds" : {
            "0" : 1,
            "1" : 2,
            "2" : 3,
            "3" : 4
         },
         "upsertedIds" : {

         }
      }

   :method:`db.collection.bulkWrite()` is equivalent to initializing
   :method:`Bulk()` operations builder, using :ref:`Bulk methods
   <bulk-methods>` to add operations, and running
   :method:`Bulk.execute()` to execute the operations.
   
Bit Test Query Operators
------------------------

MongoDB |version-dev| introduces the four new bit test query operators.
The bit test query operators allow applications to test whether
particular bits are set or clear in bitpacked numerical fields or in
fields storing binary data.

Behavior
~~~~~~~~

#. The operators can only test fields whose values are either number or
   BinData. Values of other types will not match.

#. If the value is a BSONType double, the value must be an integer,
   i.e. cannot have a fractional part, and must be representable as a
   64-bit signed integer, i.e. cannot be too big (2\ :sup:`100`) or too
   small (-2\ :sup:`100`).

   If the double value meets the criteria, the operators convert the
   double to a 64-bit signed integer before applying the bit test.

#. Numbers are sign extended in order to handle bit positions beyond
   the 64 bits of a long. For example, we consider bit position ``200``
   set for the number ``-5`` but we consider bit position ``200`` clear
   for the number ``+5``.

Operators
~~~~~~~~~

.. query:: $bitsAllSet

   Selects documents where the all the specified bits of a field are
   set (i.e. ``1``).

   To use :query:`$bitsAllSet`, you can use one of
   the following syntaxes:

   - To use bit positions to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllSet: [ <position>, <position2>, ... ] } }

     The ``<positions>`` can be any non-negative numerical BSON element
     type and must be representable as a 32-bit signed integer.

     The bit position is ``0``-based, starting at the least significant
     bit:

     .. code-block:: none

        11111111
        --------
        76543210 Position

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllSet` operator to test
     whether field ``a`` has bits set at position ``1`` and position
     ``5``, counting from the least significant bit as position ``0``:

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllSet: [ 1, 5 ] } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }

   - To use a numeric bitmask to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllSet: <numeric bitmask> } }

     :query:`$bitsAllSet` uses the positions of the ``1``'s in the
     bitmask to test the bit in the corresponding position in the
     ``<field>``.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllSet` operator to test
     whether field ``a`` has bits set at positions that corresponds to
     positions of ``1``'s in the numeric bitmask ``50`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllSet: 50 } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }

   - To use BinData to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllSet: <BinData> } }

     :query:`$bitsAllSet` uses the positions of the ``1``'s in the
     BinData to test the bit in the corresponding position in the
     ``<field>``. Bit position ``0`` is the first bit in the first byte
     of a BinData element.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllSet` operator to test
     whether field ``a`` has bits set at positions that corresponds to
     positions of ``1``'s in the ``BinData(0, "MC==")`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllSet: BinData(0, "MC==") } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }

.. query:: $bitsAllClear

   Selects documents where the all the specified bits of a field are
   clear (i.e. ``0``). To use :query:`$bitsAllClear`, you can use one
   of the following syntaxes:

   - To use bit positions to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllClear: [ <position>, <position2>, ... ] } }

     The ``<positions>`` can be any non-negative numerical BSON element
     type and must be representable as a 32-bit signed integer.

     The bit position is ``0``-based, starting at the least significant
     bit:

     .. code-block:: none

        11111111
        --------
        76543210 Position

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllClear` operator to test
     whether field ``a`` has bits cleared in position ``1`` and position
     ``5``, counting from the least significant bit as position ``0``:

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllClear: [ 1, 5 ] } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id: 2, a: 20, binaryValueofA: "00010100" }

   - To use a numeric bitmask to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllClear: <numeric bitmask> } }

     :query:`$bitsAllClear` uses the positions of the ``1``'s in the
     bitmask to test the bit in the corresponding position in the
     ``<field>``.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllClear` operator to test
     whether field ``a`` has bits cleared at positions that corresponds to
     positions of ``1``'s in the numeric bitmask ``35`` (i.e. ``00100011``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllClear: 35 } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:2, a: 20, binaryValueofA: "00010100" }

   - To use BinData to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAllClear: <BinData> } }

     :query:`$bitsAllClear` uses the positions of the ``1``'s in the
     BinData to test the bit in the corresponding position in the
     ``<field>``. Bit position ``0`` is the first bit in the first byte
     of a BinData element.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAllClear` operator to test
     whether field ``a`` has bits cleared at positions that corresponds to
     positions of ``1``'s in the ``BinData(0, "ID==")`` (i.e. ``00100011``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAllClear: BinData(0, "ID==") } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:2, a: 20, binaryValueofA: "00010100" }

.. query:: $bitsAnySet

   Selects documents where at least one of the specified bits of a
   field are set (i.e. ``1``). To use :query:`$bitsAnySet`, you can use
   one of the following syntaxes:

   - To use bit positions to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnySet: [ <position>, <position2>, ... ] } }

     The ``<positions>`` can be any non-negative numerical BSON element
     type and must be representable as a 32-bit signed integer.

     The bit position is ``0``-based, starting at the least significant
     bit:

     .. code-block:: none

        11111111
        --------
        76543210 Position

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAnySet` operator to test
     whether field ``a`` has any bits set in position ``1`` and position
     ``5``, counting from the least significant bit as position ``0``:

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnySet: [ 1, 5 ] } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }

   - To use a numeric bitmask to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnySet: <numeric bitmask> } }

     :query:`$bitsAnySet` uses the positions of the ``1``'s in the
     bitmask to test the bit in the corresponding position in the
     ``<field>``.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAnySet` operator to test
     whether field ``a`` has any bits set at positions that corresponds to
     positions of ``1``'s in the numeric bitmask ``50`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnySet: 50 } } )

     The query matches the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

   - To use BinData to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnySet: <BinData> } }

     :query:`$bitsAnySet` uses the positions of the ``1``'s in the
     BinData to test the bit in the corresponding position in the
     ``<field>``. Bit position ``0`` is the first bit in the first byte
     of a BinData element.

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAnySet` operator to test
     whether field ``a`` has any bits set at positions that corresponds to
     positions of ``1``'s in the ``BinData(0, "MC==")`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnySet: BinData(0, "MC==") } } )

     The query matches the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

.. query:: $bitsAnyClear

   Selects documents where at least one of the specified bits of a
   field are clear (i.e. ``0``). To use :query:`$bitsAnyClear`, you can
   use one of the following syntaxes:

   - To use bit positions to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnyClear: [ <position>, <position2>, ... ] } }

     The ``<positions>`` can be any non-negative numerical BSON element
     type and must be representable as a 32-bit signed integer.

     The bit position is ``0``-based, starting at the least significant
     bit:

     .. code-block:: none

        11111111
        --------
        76543210 Position

     Consider a collection with the following documents:

     .. code-block:: javascript

        { _id:1, a: 54, binaryValueofA: "00110110" }
        { _id:2, a: 20, binaryValueofA: "00010100" }

     The following query uses the :query:`$bitsAnyClear` operator to test
     whether field ``a`` has any bits cleared in position ``1`` and
     position ``5``, counting from the least significant bit as
     position ``0``:

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnyClear: [ 1, 5 ] } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:2, a: 20, binaryValueofA: "00010100" }

   - To use a numeric bitmask to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnyClear: <numeric bitmask> } }

     :query:`$bitsAnyClear` uses the positions of the ``1``'s in the
     bitmask to test the bit in the corresponding position in the
     ``<field>``.

     The following query uses the :query:`$bitsAnyClear` operator to test
     whether field ``a`` has any bits cleared at positions that corresponds to
     positions of ``1``'s in the numeric bitmask ``50`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnyClear: 50 } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:2, a: 20, binaryValueofA: "00010100" }

   - To use BinData to specify which bits to test:

     .. code-block:: javascript

        { <field>: { $bitsAnyClear: <BinData> } }

     :query:`$bitsAnyClear` uses the positions of the ``1``'s in the
     BinData to test the bit in the corresponding position in the
     ``<field>``.  Bit position ``0`` is the first bit in the first byte
     of a BinData element.

     The following query uses the :query:`$bitsAnyClear` operator to test
     whether field ``a`` has any bits cleared at positions that corresponds to
     positions of ``1``'s in the ``BinData(0, "MC==")`` (i.e. ``00110010``).

     .. code-block:: javascript

        db.collection.find( { a: { $bitsAnyClear: BinData(0, "MC==") } } )

     The query matches the following document:

     .. code-block:: javascript

        { _id:2, a: 20, binaryValueofA: "00010100" }

.. _3.2-ref-case-sensitive-text-search:

Case Sensitive Text Search Examples
-----------------------------------

.. TODO remove in 3.1.8

.. versionchanged:: 3.1.7

   With the introduction of the ``text`` index version 3, MongoDB
   expands the :ref:`case insensitivity
   <3.2-relnotes-text-index-case-insensitivity>` of the ``text``` index to
   include Latin characters with :ref:`diacritics
   <3.2-text-index-v3-diacritic-sensitivity>` and characters from some
   non-Latin alphabets, such as the Cyrillic alphabet.

   Earlier versions of the ``text`` index are case insensitive for
   Latin characters without diacritic marks.

The :query:`$text` operator adds support for case sensitive text search
with the new ``$caseSensitive`` option.

For more information on case sensitive text search, see
:ref:`3.2-case-sensitive-text-search`.

Case Sensitive Search for a Phrase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the ``articles`` collection contains the following documents:

.. code-block:: json

   { "_id" : 4, "subject" : "caf con leche" }
   { "_id" : 5, "subject" : "Caf Con Leche" }
   { "_id" : 6, "subject" : "Caf con leche" }

The following query performs a case sensitive search for the phrase
``Caf Con Leche``:

.. code-block:: javascript

   db.articles.find( { 
      $text: { $search: "\"Caf Con Leche\"", $language: "es", $caseSensitive: true }
   } )

The search matches just the document:

.. code-block:: json

   { "_id" : 5, "subject" : "Caf Con Leche" }

.. note::

   For ``$caseSensitive: true``, the :query:`$text` operator performs
   an exact match on the phrase when filtering out documents.

Case Sensitivity with Negated Term
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A *negated* term is a term that is prefixed by a minus sign ``-``. If
you negate a term, the :query:`$text` operator will exclude the
documents that contain those terms from the results. You can also
specify case sensitivity for negated terms.

The following example performs a case sensitive search for documents
that contain the words ``bake`` or ``coffee`` but do **not** contain
the term ``milk``:

.. code-block:: javascript

   db.articles.find( { $text: { $search: "bake coffee -milk", $caseSensitive: true } } )

The query matches the following document:

.. code-block:: json

   { "_id" : 3, "subject" : "coffee and Milk" }

View Document Validation Information
------------------------------------

To view the validation specifications for a collection, you can use the
:method:`db.getCollectionInfos( )` method and the
:dbcommand:`listCollections` command.

If a collection includes :ref:`3.2-rel-notes-document-validation`
settings, the :dbcommand:`listCollections` command and the
:method:`db.getCollectionInfos()` method will include them in the
output for the collections.

``find`` and ``getMore`` Commands
---------------------------------

:dbcommand:`find` and :dbcommand:`getMore` commands require an upgrade
of the official MongoDB drivers.

.. versionadded:: 3.1.8

.. dbcommand:: find

   Executes a query and returns the first batch of results and the
   cursor id, from which the client can construct a cursor.

   The :dbcommand:`find` command has the following form:

   .. code-block:: javascript

      {
         "find": <string>,
         "filter": <document>,
         "sort": <document>,
         "projection": <document>,
         "hint": <document or string>,
         "skip": <int>,
         "limit": <int>,
         "batchSize": <int>,
         "singleBatch": <bool>,
         "comment": <string>,
         "maxScan": <int>,
         "maxTimeMS": <int>,
         "readConcern": <document>,
         "max": <document>,,
         "min": <document>,,
         "returnKey": <bool>,
         "showRecordId": <bool>,
         "snapshot": <bool>,
         "tailable": <bool>,
         "oplogReplay": <bool>,
         "noCursorTimeout": <bool>,
         "awaitData": <bool>,
         "allowPartialResults": <bool>
      }

   The command accepts the following fields:

   .. list-table::
      :header-rows: 1
      :widths: 20 15 65

      * - Field
        - Type
        - Description

      * - ``find``
        - String
        - The name of the collection to query.

      * - ``filter``

        - Document

        - Optional. The query predicate. If unspecified, then all
          documents in the collection will match the predicate.

      * - ``sort``

        - Document

        - Optional. The sort specification for the ordering of the results.
  
      * - ``projection``

        - Document

        - Optional. The :ref:`projection specification <projections>`
          to determine which fields to include in the returned
          documents. See :ref:`projections` and
          :doc:`/reference/operator/projection`.

      * - ``hint``

        - String or document

        - Optional. Index specification. Specify either the index name as a
          string or the index key pattern. If specified, then
          the query system will only consider plans using the hinted index.

      * - ``skip``

        - Positive integer

        - Optional. Number of documents to skip. Defaults to 0.

      * - ``limit``

        - Non-negative integer

        - Optional. The maximum number of documents to return. If
          unspecified, then defaults to no limit. A limit of 0 is
          equivalent to setting no limit.

      * - ``batchSize``

        - Non-negative integer
  
        - Optional. The number of documents to return in the first batch.
          Defaults to 101. A ``batchSize`` of 0 means that the cursor will be
          established, but no documents will be returned in the first batch.

.. For the reference page, add the sentence:
   Unlike the previous wire protocol version, a ``batchSize`` of 1 for
   the :dbcommand:`find` command does not close the cursor.

      * - ``singleBatch``

        -  Boolean

        - Optional. Determines whether to close the cursor after the first
          batch. Defaults to false.

      * - ``comment``

        - String

        - A comment to attach to the query to help interpret and trace query
          :dbcommand:`profile` data.

      * - ``maxScan``

        - Positive integer

        - Optional. Maximum number of documents or index keys to scan
          when executing the query.

      * - ``maxTimeMS``

        - Positive integer

        - Optional. The cumulative time limit in milliseconds for processing
          operations on the cursor. MongoDB aborts the operation at the
          earliest following :term:`interrupt point`.

      * - ``readConcern``

        - Document

        - Optional. The :ref:`3.2-rel-notes-readConcern` specification.

      * - ``max``

        - Document

        - Optional. The *exclusive* upper bound for a specific
          index. See :method:`cursor.max()` for details.

      * - ``min``

        - Document

        - Optional. The *inclusive* lower bound for a specific
          index. See :method:`cursor.min()` for details.

      * - ``returnKey``

        - Boolean

        - Optional. If true, returns only the index keys in the
          resulting documents. Default value is false. If ``returnKey``
          is ``true`` and the :dbcommand:`find` command does not use an
          index, the returned documents will be empty.

      * - ``showRecordId``

        - Boolean

        - Optional. Determines whether to return the record identifier
          for each document. If true, adds a field ``$recordId`` to the
          returned documents.

      * - ``snapshot``

        - Boolean

        - Optional. Prevents the cursor from returning a document more than
          once because of an intervening write operation.

      * - ``tailable``

        - Boolean

        - Optional. Returns a :term:`tailable cursor` for a capped collections.

      * - ``awaitData``
      
        - Boolean

        - Optional. Use in conjunction with the ``tailable`` option to
          block a :dbcommand:`getMore` command on the cursor
          temporarily if at the end of data rather than returning no
          data. After a timeout period, :dbcommand:`find` returns as
          normal.

      * - ``oplogReplay``

        - Boolean

        - Optional. Internal use for replica sets. To use
          ``oplogReplay``, you must include the following condition in
          the ``filter``:

          .. code-block:: javascript

             { ts: { $gte: <timestamp> } }

      * - ``noCursorTimeout``

        - Boolean

        - Optional. Prevents the server from timing out idle cursors after an
          inactivity period (10 minutes).

      * - ``allowPartialResults``

        - Boolean

        - Optional. For queries against a sharded collection, returns partial
          results from the :program:`mongos` if some shards are unavailable
          instead of throwing an error.

   For example, the following command runs the :dbcommand:`find`
   command filtering on the ``rating`` field and the ``cuisine`` field.
   The command includes a ``projection`` to only return the
   following fields in the matching documents: ``_id``, ``name``,
   ``rating``, and ``address`` fields.

   The command sorts the documents in the result set by the ``name``
   field and limits the result set to 5 documents.

   .. code-block:: javascript

      db.runCommand(
         {
           find: "restaurants",
           filter: { rating: { $gte: 9 }, cuisine: "italian" },
           projection: { name: 1, rating: 1, address: 1 },
           sort: { name: 1 },
           limit: 5
         }
      )

.. versionadded:: 3.1.8

.. dbcommand:: getMore

   Use in conjunction with commands that return a cursor, e.g.
   :dbcommand:`find` and :dbcommand:`aggregate`, to return subsequent
   batches of documents currently pointed to by the cursor.

   The :dbcommand:`getMore` command has the following form:

   .. code-block:: javascript

      {
         "getMore": <long>,
         "collection": <string>,
         "batchSize": <int>,
         "maxTimeMS": <int>
      }

   The command accepts the following fields:

   .. list-table::
      :header-rows: 1
      :widths: 20 15 65

      * - Field
        - Type
        - Description

      * - ``getMore``

        - Long

        - The cursor id.

      * - ``collection``

        - String

        - The name of the collection over which the cursor is
          operating.

      * - ``batchSize``

        - Non-negative integer.

        - Optional. The number of documents to return in the batch.

      * - ``maxTimeMS``

        - Positive integer.

        - Optional. The timeout duration in milliseconds.

Diagnostic Parameters
---------------------

To support the diagnostic feature, MongoDB introduces the following
parameters:

.. |mongod-only| replace:: Available for :program:`mongod` only.

.. parameter:: diagnosticDataCollectionEnabled

   .. versionadded:: 3.1.8

   *Type*: boolean

   *Default*: true

   |mongod-only|

   Determines whether to enable the collecting and logging of data for
   diagnostic purposes. Diagnostic logging is enabled by default.

   For example, the following disables the diagnostic collection:

   .. code-block:: sh

      mongod --setParameter diagnosticDataCollectionEnabled=false

.. parameter:: diagnosticDataCollectionDirectorySizeMb

   .. versionadded:: 3.1.8

   *Type*: integer

   *Default*: 100

   |mongod-only|

   Specifies the maximum size, in megabytes, of the ``diagnostic.data``
   directory . If directory size exceeds this number, the oldest
   :ref:`diagnostic files in the directory
   <3.2-diagnostic-data-capture>` are automatically deleted based on
   the timestamp in the file name.

   For example, the following sets the maximum size of the directory to
   ``200`` megabytes:

   .. code-block:: sh

      mongod --setParameter diagnosticDataCollectionDirectorySizeMb=200

   The minimum value for
   :parameter:`diagnosticDataCollectionDirectorySizeMb` is ``10``
   megabytes. :parameter:`diagnosticDataCollectionDirectorySizeMb` must
   be greater than maximum diagnostic file size
   :parameter:`diagnosticDataCollectionFileSizeMb`.

.. parameter:: diagnosticDataCollectionFileSizeMb

   .. versionadded:: 3.1.8

   *Type*: integer

   *Default*: 10

   |mongod-only|

   Specifies the maximum size, in megabytes, of each :ref:`diagnostic
   file <3.2-diagnostic-data-capture>`. If the file exceeds the maximum
   file size, MongoDB creates a new file.

   For example, the following sets the maximum size of the directory to
   ``20`` megabytes:

   .. code-block:: sh

      mongod --setParameter diagnosticDataCollectionDirectorySizeMb=20

   The minimum value for
   :parameter:`diagnosticDataCollectionFileSizeMb` is ``1`` megabyte.

.. parameter:: diagnosticDataCollectionPeriodMillis

   .. versionadded:: 3.1.8

   *Type*: integer

   *Default*: 1000

   |mongod-only|

   Specifies the interval, in milliseconds, for the diagnostic data
   collection.

   For example, the following sets the maximum size of the directory to
   ``5000`` milliseconds or 5 seconds:

   .. code-block:: sh

      mongod --setParameter diagnosticDataCollectionPeriodMillis=5000

   The minimum value for
   :parameter:`diagnosticDataCollectionPeriodMillis` is ``100``
   milliseconds.

.. _3.2-encryption-key-management-options:

Key Management Configuration Options
------------------------------------

MongoDB Enterprise |version-dev| adds the following configuration
options to support encryption for the WiredTiger storage engine.

Command Line Options
~~~~~~~~~~~~~~~~~~~~

.. include:: /includes/fact-enterprise-only-admonition.rst

.. option:: enableEncryption

   *Type*: boolean

   *Default*: false

   Enables encryption for the WiredTiger storage engine. You must set
   to ``true`` to pass in encryption keys and configurations.

.. option:: encryptionCipherMode

   The cipher mode to use for encryption at rest:

   .. list-table::
      :header-rows: 1
      :widths: 35 65

      * - Mode
        - Description

      * - ``AES256-CBC``
        - 256-bit Advanced Encryption Standard in Cipher Block Chaining
          Mode

      * - ``AES256-GCM``

        - 256-bit Advanced Encryption Standard in Galois/Counter Mode

.. option:: encryptionKeyFile

   *Type*: string

   The path to the local keyfile when managing keys via process *other
   than* KMIP. Only set when managing keys via process other than KMIP.
   If data is already encrypted using KMIP, MongoDB will throw an error.

   Requires :setting:`enableEncryption` to be ``true``.

.. option:: kmipKeyIdentifier

   *Type*: string

   Unique KMIP identifier for an existing key within the KMIP server.
   Include to use the key associated with the identifier as the system
   key. You can only use the setting the first time you enable
   encryption for the :program:`mongod` instance. Requires
   :setting:`enableEncryption` to be true.
   
   If unspecified, MongoDB will request that the KMIP server create a
   new key to utilize as the system key.

   If the KMIP server cannot locate a key with the specified identifier
   or the data is already encrypted with a key, MongoDB will throw an
   error

.. option:: kmipRotateMasterKey

   .. versionadded:: 3.1.8

   *Type*: boolean

   *Default*: false

   If true, rotate the master key and re-encrypt the internal
   keystore.

   .. seealso:: :ref:`3.1-kmip-master-key-rotation`

.. option:: kmipServerName

   *Type*: string

   Hostname or IP address of key management solution running a KMIP
   server. Requires :setting:`enableEncryption` to be true.

.. option:: kmip.port

   *Type*: string

   *Default*: 5696

   Port number the KMIP server is listening on. Requires that a
   :setting:`kmipServerName` be provided. Requires
   :setting:`enableEncryption` to be true.

.. option:: kmipClientCertificateFile

   *Type*: string

   String containing the path to the client certificate used for
   authenticating MongoDB to the KMIP server. Requires that a
   :setting:`kmipServerName` be provided.

.. option:: kmipClientCertificatePassword

   *Type*: string

   The password (if one exists) for the client certificate passed into
   :setting:`kmipClientCertificateFile`. Is used for
   authenticating MongoDB to the KMIP server. Requires that a
   :setting:`kmipClientCertificateFile` be provided.

.. option:: kmipServerCAFile

   *Type*: string

   Path to CA File. Used for validating secure client connection to
   KMIP server.

Configuration File Options
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: /includes/fact-enterprise-only-admonition.rst

.. code-block:: yaml

   {
      security:
         enableEncryption: <boolean>,
         encryptionCipherMode: <string>,
         encryptionKeyFile: <string>,
         kmip:
            keyIdentifier: <string>,
            rotateMasterKey: <boolean>
            serverName: <string>,
            port: <string>,
            clientCertificatePassword: <string>,
            serverCAFile: <string>
   }

.. setting:: security.enableEncryption

   *Type*: boolean

   *Default*: false
   
   Enables encryption for the WiredTiger storage engine. You must set
   to ``true`` to pass in encryption keys and configurations.

.. setting:: encryptionCipherMode

   *Type*: string

   *Default*: ``AES256-CBC``

   .. versionadded:: 3.1.8

   The cipher mode to use for encryption at rest:

   .. list-table::
      :header-rows: 1
      :widths: 35 65

      * - Mode
        - Description

      * - ``AES256-CBC``
        - 256-bit Advanced Encryption Standard in Cipher Block Chaining
          Mode

      * - ``AES256-GCM``

        - 256-bit Advanced Encryption Standard in Galois/Counter Mode

.. setting:: security.encryptionKeyFile

   *Type*: string

   The path to the local keyfile when managing keys via process *other
   than* KMIP. Only set when managing keys via process other than KMIP.
   If data is already encrypted using KMIP, MongoDB will throw an error.

   Requires :setting:`security.enableEncryption` to be ``true``.

.. setting:: security.kmip.keyIdentifier

   *Type*: string

   Unique KMIP identifier for an existing key within the KMIP server.
   Include to use the key associated with the identifier as the system
   key. You can only use the setting the first time you enable
   encryption for the :program:`mongod` instance. Requires
   :setting:`security.enableEncryption` to be true.
   
   If unspecified, MongoDB will request that the KMIP server create a
   new key to utilize as the system key.

   If the KMIP server cannot locate a key with the specified identifier
   or the data is already encrypted with a key, MongoDB will throw an
   error.

.. setting:: security.kmip.rotateMasterKey

   *Type*: boolean

   *Default*: false

   If true, rotate the master key and re-encrypt the internal
   keystore.

   .. seealso:: :ref:`3.1-kmip-master-key-rotation`

.. setting:: security.kmip.serverName

   *Type*: string

   Hostname or IP address of key management solution running a KMIP
   server. Requires :setting:`security.enableEncryption` to be true.

.. setting:: security.kmip.port

   *Type*: string

   *Default*: 5696

   Port number the KMIP server is listening on. Requires that a
   :setting:`security.kmip.serverName` be provided. Requires
   :setting:`security.enableEncryption` to be true.

.. setting:: security.kmip.clientCertificateFile

   *Type*: string

   String containing the path to the client certificate used for
   authenticating MongoDB to the KMIP server. Requires that a
   :setting:`security.kmip.serverName` be provided.

.. setting:: security.kmip.clientCertificatePassword

   *Type*: string

   The password to decrypt the client certificate (i.e.
   :setting:`security.kmip.clientCertificateFile`), used to
   authenticate MongoDB to the KMIP server. Use the option only if the
   certificate is encrypted.

.. setting:: security.kmip.serverCAFile

   *Type*: string

   Path to CA File. Used for validating secure client connection to
   KMIP server.

See also :doc:`/release-notes/3.1-dev-series`.
