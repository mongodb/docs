#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-08-20 19:13-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/aggregation-pipeline-optimization.txt:3
msgid "Aggregation Pipeline Optimization"
msgstr "聚合管道的优化"

#: ../source/core/aggregation-pipeline-optimization.txt:13
msgid ""
"Aggregation pipeline operations have an optimization phase which attempts to"
" reshape the pipeline for improved performance."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:16
msgid ""
"To see how the optimizer transforms a particular aggregation pipeline, "
"include the :method:`explain <db.collection.aggregate()>` option in the "
":method:`db.collection.aggregate()` method."
msgstr ""

#: ../source/includes/fact-optimizations-subject-to-change.rst:1
msgid "Optimizations are subject to change between releases."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:25
msgid "Projection Optimization"
msgstr "预测优化"

#: ../source/core/aggregation-pipeline-optimization.txt:27
msgid ""
"The aggregation pipeline can determine if it requires only a subset of the "
"fields in the documents to obtain the results. If so, the pipeline will only "
"use those required fields, reducing the amount of data passing through the "
"pipeline."
msgstr ""
"聚合管道可以检测到是否仅使用文档中的一部分字段就可以完成聚合。如果是的话，管"
"道就可以仅使用这些必要的字段，从而减少进入管道的数据量。"

#: ../source/core/aggregation-pipeline-optimization.txt:35
msgid "Pipeline Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:40
msgid "``$sort`` + ``$match`` Sequence Optimization"
msgstr "``$sort`` + ``$match`` 顺序优化"

#: ../source/core/aggregation-pipeline-optimization.txt:42
msgid ""
"When you have a sequence with :pipeline:`$sort` followed by a :pipeline:`"
"$match`, the :pipeline:`$match` moves before the :pipeline:`$sort` to "
"minimize the number of objects to sort. For example, if the pipeline "
"consists of the following stages:"
msgstr ""
"如果你的管道中， :pipeline:`$sort` 后面跟着 :pipeline:`$match` ，把 :pipeline:"
"`$match` 移到 :pipeline:`$sort` 前面可以减少需要排序的对象个数。例如，如果管"
"道中有以下两个部分："

#: ../source/core/aggregation-pipeline-optimization.txt:52
#: ../source/core/aggregation-pipeline-optimization.txt:77
#: ../source/core/aggregation-pipeline-optimization.txt:141
msgid ""
"During the optimization phase, the optimizer transforms the sequence to the "
"following:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:63
msgid "``$skip`` + ``$limit`` Sequence Optimization"
msgstr "``$skip`` + ``$limit`` 顺序优化"

#: ../source/core/aggregation-pipeline-optimization.txt:65
msgid ""
"When you have a sequence with :pipeline:`$skip` followed by a :pipeline:`"
"$limit`, the :pipeline:`$limit` moves before the :pipeline:`$skip`. With the "
"reordering, the :pipeline:`$limit` value increases by the :pipeline:`$skip` "
"amount."
msgstr ""
"如果你的管道中， :pipeline:`$skip` 后面跟着 :pipeline:`$limit` ，优化器会把 :"
"pipeline:`$limit` 移到 :pipeline:`$skip` 前面，这个时候， :pipeline:`$limit` "
"的值会加上 :pipeline:`$skip` 的个数。"

#: ../source/core/aggregation-pipeline-optimization.txt:70
#: ../source/core/aggregation-pipeline-optimization.txt:107
msgid "For example, if the pipeline consists of the following stages:"
msgstr "例如，如果管道由以下部分组成："

#: ../source/core/aggregation-pipeline-optimization.txt:85
msgid ""
"This optimization allows for more opportunities for :ref:`agg-sort-limit-"
"coalescence`, such as with ``$sort`` + ``$skip`` + ``$limit`` sequences. "
"See :ref:`agg-sort-limit-coalescence` for details on the coalescence and :"
"ref:`agg-sort-skip-limit-sequence` for an example."
msgstr ""
"对于类似 :ref:`$sort和$limit的合并 <agg-sort-limit-"
"coalescence>` ，例如 ``$sort`` + ``$skip`` + ``$limit`` ，优化器允许你做很多优"
"化。详情请查看 :ref:`$sort和$limit的合并 <agg-sort-limit-"
"coalescence>` ，也可以在 :ref:`$sort、$skip、$limit的顺序优化 <agg-"
"sort-skip-limit-sequence>` 中查看例子。"

#: ../source/core/aggregation-pipeline-optimization.txt:91
msgid ""
"For aggregation operations on :doc:`sharded collections <aggregation-"
"pipeline-sharded-collections>`, this optimization reduces the results "
"returned from each shard."
msgstr ""
"对于在 :doc:`分片集合上的聚合 <aggregation-pipeline-sharded-collections>` "
"，优化器可以减少从每个分片返回的文档个数。"

#: ../source/core/aggregation-pipeline-optimization.txt:96
msgid "``$redact`` + ``$match`` Sequence Optimization"
msgstr "``$redact`` + ``$match`` 顺序优化"

#: ../source/core/aggregation-pipeline-optimization.txt:98
msgid ""
"When possible, when the pipeline has the :pipeline:`$redact` stage "
"immediately followed by the :pipeline:`$match` stage, the aggregation can "
"sometimes add a portion of the :pipeline:`$match` stage before the :pipeline:"
"`$redact` stage. If the added :pipeline:`$match` stage is at the start of a "
"pipeline, the aggregation can use an index as well as query the collection "
"to limit the number of documents that enter the pipeline. See :ref:"
"`aggregation-pipeline-operators-and-performance` for more information."
msgstr ""
"如果可能，当管道中 :pipeline:`$redact` 阶段后面紧接着有 :pipeline:`$match` 操"
"作，聚合有时候会添加一个 :pipeline:`$match` 到 :pipeline:`$redact` 前面。如果"
"在管道在一开始有 :pipeline:`$match` ，聚合操作在查询时可以使用索引，以减少进入"
"到管道中的文档个数。更多详情请查看 :ref:`聚合管道的操作符和性能 <aggregation-"
"pipeline-operators-and-performance>` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:114
msgid ""
"The optimizer can add the same :pipeline:`$match` stage before the :pipeline:"
"`$redact` stage:"
msgstr "优化器可以在 :pipeline:`$redact` 之前增加相同的 :pipeline:`$match` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:158
msgid "Pipeline Coalescence Optimization"
msgstr "管道合并优化"

#: ../source/core/aggregation-pipeline-optimization.txt:160
msgid ""
"When possible, the optimization phase coalesces a pipeline stage into its "
"predecessor. Generally, coalescence occurs *after* any sequence reordering "
"optimization."
msgstr ""
"优化器可以在管道开始之前合并其他的管道。一般情况下，合并发生在所有顺序优化之"
"后。"

#: ../source/core/aggregation-pipeline-optimization.txt:167
msgid "``$sort`` + ``$limit`` Coalescence"
msgstr "``$sort`` + ``$limit`` 合并"

#: ../source/core/aggregation-pipeline-optimization.txt:169
msgid ""
"When a :pipeline:`$sort` immediately precedes a :pipeline:`$limit`, the "
"optimizer can coalesce the :pipeline:`$limit` into the :pipeline:`$sort`. "
"This allows the sort operation to only maintain the top ``n`` results as it "
"progresses, where ``n`` is the specified limit, and MongoDB only needs to "
"store ``n`` items in memory [#coalescence-allowDiskUse]_. See :ref:`sort-and-"
"memory` for more information."
msgstr ""
"如果 :pipeline:`$sort` 在 :pipeline:`$limit` 前面，优化器可以把 :pipeline:`"
"$limit` 合并在 :pipeline:`$sort` 内部。此时如果指定了限定返回 ``n`` 个结果，那么"
"排序操作仅需要维护最前面的 ``n`` 个结果，MongoDB只需要在内存中存储 ``n`` 个元素 "
"[#coalescence-allowDiskUse]_。更多信息请查看 :ref:`排序与内存 <sort-and-"
"memory>` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:177
msgid ""
"The optimization will still apply when ``allowDiskUse`` is ``true`` and the "
"``n`` items exceed the :ref:`aggregation memory limit <agg-memory-"
"restrictions>`."
msgstr ""
"当 ``allowDiskUse`` 设置为 ``true`` 和 ``n`` 数目超过 :ref:`聚合的内存限制 <agg-"
"memory-restrictions>` 时，优化依旧会进行。"

#: ../source/core/aggregation-pipeline-optimization.txt:184
msgid "``$limit`` + ``$limit`` Coalescence"
msgstr "``$limit`` + ``$limit`` 合并"

#: ../source/core/aggregation-pipeline-optimization.txt:186
msgid ""
"When a :pipeline:`$limit` immediately follows another :pipeline:`$limit`, "
"the two stages can coalesce into a single :pipeline:`$limit` where the limit "
"amount is the *smaller* of the two initial limit amounts. For example, a "
"pipeline contains the following sequence:"
msgstr ""
"当 :pipeline:`$limit` 操作后面还有一个 :pipeline:`$limit` 操作，这两步可以合并"
"成一个单独的 :pipeline:`$limit` 操作，此时限制的个数是前面两个限制个数中较小的"
"值。例如，一个管道操作包含有如下操作序列："

#: ../source/core/aggregation-pipeline-optimization.txt:197
msgid ""
"Then the second :pipeline:`$limit` stage can coalesce into the first :"
"pipeline:`$limit` stage and result in a single :pipeline:`$limit` stage "
"where the limit amount ``10`` is the minimum of the two initial limits "
"``100`` and ``10``."
msgstr ""
"此时，第二个 :pipeline:`$limit` 操作可以合并到第一个 :pipeline:`$limit` 操作"
"中，最后生成一个 :pipeline:`$limit` 操作并且限制个数为初始两个限制个数 ``100`` "
"和 ``10`` 中的较小的一个 ``10`` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:209
msgid "``$skip`` + ``$skip`` Coalescence"
msgstr "``$skip`` + ``$skip`` 合并"

#: ../source/core/aggregation-pipeline-optimization.txt:211
msgid ""
"When a :pipeline:`$skip` immediately follows another :pipeline:`$skip`, the "
"two stages can coalesce into a single :pipeline:`$skip` where the skip "
"amount is the *sum* of the two initial skip amounts. For example, a pipeline "
"contains the following sequence:"
msgstr ""
"当 :pipeline:`$skip` 操作后面还有一个 :pipeline:`$skip` 操作，这两步可以合并成"
"一个单独的 :pipeline:`$skip` 操作，此时跳过的个数是前面两个跳过个数的和。例"
"如，一个管道操作包含有如下操作序列："

#: ../source/core/aggregation-pipeline-optimization.txt:221
msgid ""
"Then the second :pipeline:`$skip` stage can coalesce into the first :"
"pipeline:`$skip` stage and result in a single :pipeline:`$skip` stage where "
"the skip amount ``7`` is the sum of the two initial limits ``5`` and ``2``."
msgstr ""
"此时，第二个 :pipeline:`$skip` 操作可以合并到第一个 :pipeline:`$skip` 操作中，"
"最后生成一个 :pipeline:`$skip` 操作并且跳过个数为初始两个跳过个数 ``5`` 与 ``2`` "
"的相加值 ``7`` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:233
msgid "``$match`` + ``$match`` Coalescence"
msgstr "``$match`` + ``$match`` 合并"

#: ../source/core/aggregation-pipeline-optimization.txt:235
msgid ""
"When a :pipeline:`$match` immediately follows another :pipeline:`$match`, "
"the two stages can coalesce into a single :pipeline:`$match` combining the "
"conditions with an :expression:`$and`. For example, a pipeline contains the "
"following sequence:"
msgstr ""
"当 :pipeline:`$match` 操作后面还有一个 :pipeline:`$match` 操作，可以将这两步中"
"的条件使用 :expression:`$and` 表达式合并成一个单独的 :pipeline:`$match` 操作。"
"例如，一个管道操作包含有如下操作序列："

#: ../source/core/aggregation-pipeline-optimization.txt:246
msgid ""
"Then the second :pipeline:`$match` stage can coalesce into the first :"
"pipeline:`$match` stage and result in a single :pipeline:`$match` stage"
msgstr ""
"此时，第二个 :pipeline:`$match` 操作可以合并到第一个 :pipeline:`$match` 操作"
"中，最后生成一个 :pipeline:`$match` 操作。"

#: ../source/core/aggregation-pipeline-optimization.txt:298
msgid "Examples"
msgstr "例子"

#: ../source/core/aggregation-pipeline-optimization.txt:300
msgid ""
"The following examples are some sequences that can take advantage of both "
"sequence reordering and coalescence. Generally, coalescence occurs *after* "
"any sequence reordering optimization."
msgstr ""
"下面的一些顺序优化的例子可以结合顺序重排和合并的优势。一般来说，合并优化在所"
"有的顺序重排之后进行。"

#: ../source/core/aggregation-pipeline-optimization.txt:307
msgid "``$sort`` + ``$skip`` + ``$limit`` Sequence"
msgstr "``$sort`` + ``$skip`` + ``$limit`` 顺序"

#: ../source/core/aggregation-pipeline-optimization.txt:309
msgid ""
"A pipeline contains a sequence of :pipeline:`$sort` followed by a :pipeline:`"
"$skip` followed by a :pipeline:`$limit`:"
msgstr ""
"一个依次包含 :pipeline:`$sort` 、 :pipeline:`$skip` 和 :pipeline:`$limit` 的管"
"道："

#: ../source/core/aggregation-pipeline-optimization.txt:318
msgid ""
"First, the optimizer performs the :ref:`agg-skip-limit-optimization` to "
"transforms the sequence to the following:"
msgstr ""
"首先，优化器执行 :ref:`$skip和$limit的优化 <agg-skip-limit-optimization>` ，转换"
"后的顺序如下："

#: ../source/core/aggregation-pipeline-optimization.txt:327
msgid ""
"The :ref:`agg-skip-limit-optimization` increases the :pipeline:`$limit` "
"amount with the reordering. See :ref:`agg-skip-limit-optimization` for "
"details."
msgstr ""
"经过 :ref:`$skip和$limit的优化 <agg-skip-limit-optimization>` 后， :pipeline:`"
"$limit` 的限定个数会增长。详情请查看 :ref:`$skip和$limit的优化 <agg-skip-limit-"
"optimization>` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:331
msgid ""
"The reordered sequence now has :pipeline:`$sort` immediately preceding the :"
"pipeline:`$limit`, and the pipeline can coalesce the two stages to decrease "
"memory usage during the sort operation. See :ref:`agg-sort-limit-"
"coalescence` for more information."
msgstr ""
"重排后的 :pipeline:`$sort` 在 :pipeline:`$limit` 前面，这时可以将这两个阶段合"
"并来降低排序时需要的内存大小。详情请查看 :ref:`$sort和$limit的合并 <agg-sort-"
"limit-coalescence>` "

#: ../source/core/aggregation-pipeline-optimization.txt:337
msgid "``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` Sequence"
msgstr "``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` 顺序"

#: ../source/core/aggregation-pipeline-optimization.txt:339
msgid ""
"A pipeline contains a sequence of alternating :pipeline:`$limit` and :"
"pipeline:`$skip` stages:"
msgstr "管道中如果交替包含了 :pipeline:`$limit` 和 :pipeline:`$skip` :"

#: ../source/core/aggregation-pipeline-optimization.txt:349
msgid ""
"The :ref:`agg-skip-limit-optimization` reverses the position of the "
"``{ $skip: 5 }`` and ``{ $limit: 10 }`` stages and increases the limit "
"amount:"
msgstr ""
" :ref:`$sort和$limit的合并 <agg-sort-limit-coalescence>` 会颠倒 ``{ $skip: 5 }`` 和 "
" ``{ $limit: 10 }`` 的位置，然后增加限定个数："

#: ../source/core/aggregation-pipeline-optimization.txt:360
msgid ""
"The optimizer then coalesces the two :pipeline:`$limit` stages into a "
"single :pipeline:`$limit` stage and the two :pipeline:`$skip` stages into a "
"single :pipeline:`$skip` stage. The resulting sequence is the following:"
msgstr ""
"优化器会把两个 :pipeline:`$limit` 合并为一个 :pipeline:`$limit` ，两个 :"
"pipeline:`$skip` 合并为一个 :pipeline:`$skip` 。合并后的结果如下："

#: ../source/core/aggregation-pipeline-optimization.txt:370
msgid ""
"See :ref:`agg-limit-limit-coalescence` and :ref:`agg-skip-skip-coalescence` "
"for details."
msgstr ""
"详情请查看 :ref:`$limit和$limit的合并 <agg-limit-limit-coalescence>` 和 :ref:`$skip"
"和$skip的合并 <agg-skip-skip-coalescence>` 。"

#: ../source/core/aggregation-pipeline-optimization.txt:374
msgid ""
":method:`explain <db.collection.aggregate()>` option in the :method:`db."
"collection.aggregate()`"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:0
msgid "On this page"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:126
msgid "``$project`` + ``$skip`` or ``$limit`` Sequence Optimization"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:130
msgid ""
"When you have a sequence with :pipeline:`$project` followed by either "
":pipeline:`$skip` or :pipeline:`$limit`, the :pipeline:`$skip` or "
":pipeline:`$limit` moves before :pipeline:`$project`. For example, if the "
"pipeline consists of the following stages:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:150
msgid ""
"This optimization allows for more opportunities for :ref:`agg-sort-limit-"
"coalescence`, such as with ``$sort`` + ``$limit`` sequences. See :ref:`agg-"
"sort-limit-coalescence` for details on the coalescence."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:257
msgid "``$lookup`` + ``$unwind`` Coalescence"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:261
msgid ""
"When a :pipeline:`$unwind` immediately follows another :pipeline:`$lookup`, "
"and the :pipeline:`$unwind` operates on the ``as`` field of the "
":pipeline:`$lookup`, the optimizer can coalesce the :pipeline:`$unwind` into"
" the :pipeline:`$lookup` stage. This avoids creating large intermediate "
"documents."
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:267
msgid "For example, a pipeline contains the following sequence:"
msgstr ""

#: ../source/core/aggregation-pipeline-optimization.txt:281
msgid ""
"The optimizer can coalesce the :pipeline:`$unwind` stage into the "
":pipeline:`$lookup` stage. If you run the aggregation with ``explain`` "
"option, the ``explain`` output shows the coalesced stage:"
msgstr ""
