.. _lookup-anti-pattern:

=============================
Reduce ``$lookup`` Operations
=============================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Overview
--------

:pipeline:`$lookup` operations join data from two collections in the
same database based on a specified field. :pipeline:`$lookup` operations
can be useful when your data is structured similarly to a relational
database and you need to model large hierarchical datasets. However,
:pipeline:`$lookup` operations can be slow and resource-intensive because
they need to read and perform logic on two collections instead of a
single collection.

If you frequently run :pipeline:`$lookup` operations on your
collections, consider restructuring your schema such that the your
application can obtain all of the information it needs from a single
collection. You can utilize MongoDB's :manual:`flexible schema model
</core/data-modeling-introduction/#flexible-schema>` with embedded
documents to capture relationships between data in a single document
structure. Use this :manual:`denormalized model
</core/data-model-design/#embedded-data-models>` to take advantage of
MongoDB's rich documents and allow your application to retrieve and
manipulate related data in a single database operation.

Example
-------

Consider the following normalized schema which uses references to store
the  relationships between a ``user``,

.. code-block:: javascript
   :copyable: false

   // user document
   {
     "_id": "u1",
     "username": "Alice"
   }

their ``contact`` information,

.. code-block:: javascript
   :copyable: false
   :emphasize-lines: 4

   // contact document
   {
     "_id": "c1",
     "user_id": "u1",
     "phone": "123-456-7890",
     "email": "alice@example.com"
   }

and their ``access`` to a particular system:

.. code-block:: javascript
   :copyable: false
   :emphasize-lines: 4

   // access document
   {
     "_id": "a1",
     "user_id": "u1",
     "level": 5,
     "group": "dev"
   }

Suppose your application needs to display all of this information on a
single page. To accomplish this, your application would need to perform
two :pipeline:`$lookup` operations to join the data from the ``contact``
and ``access`` collections based on the ``user_id``.

Instead, you can utilize embedded documents to store all of the data the
application needs in a single document and eliminate the need for
any :pipeline:`$lookup` operations:

.. code-block:: javascript
   :copyable: false

   // user document
   {
     "_id": "u1",
     "username": "Alice",
     "contact": {
       "phone": "123-456-7890",
       "email": "alice@example.com"
     },
     "access": {
       "level": 5,
       "group": "dev"
     }
   }

This approach improves read performance and saves application
resources by only requiring a single request to retrieve all of the
necessary data.

Learn More
----------

- To learn more about Data Modeling in MongoDB and the flexible schema
  model, see :manual:`Data Modeling Introduction
  </core/data-modeling-introduction/>`.

- To learn more about modeling relationships with embedded
  documents, see:

  - :manual:`Model One-to-One Relationships with Embedded Documents
    </tutorial/model-embedded-one-to-one-relationships-between-documents/>`

  - :manual:`Model One-to-Many Relationships with Embedded Documents
    </tutorial/model-embedded-one-to-many-relationships-between-documents/>`

- To learn more about the tradeoffs between embedded and normalized
  data models, see
  :manual:`Data Model Design </core/data-model-design/>`.

- MongoDB also offers a free MongoDB University Course on Data Modeling:
  `M320: Data Modeling
  <https://university.mongodb.com/courses/M320/about>`__.
