===============================================
Use Authentication to Control Access to MongoDB
===============================================

.. default-domain:: mongodb

Basic authentication and access control is enabled with the 
:option:`--auth <mongod --auth>`
or 
:option:`--keyFile <mongod --keyFile>`
options in versions of MongoDB up to and including version 2.2.

Some important things to note about authentication:

* Authentication is off by default. 
* Prior to version 2.0, it is not possible to enable authentication
  in a sharded environment.

* Once authenticated, a normal user has full "read and write" access
  to the database.  You can also create read-only users, who only
  have read access.

Each database contains a "system.users" collection, which contains
all the user information. For example:

.. code-block:: javascript

   > db.system.users.find()
   { "_id": ObjectId("5075362366b2b6e3603b65c9"), "user": "readOnly", "readOnly": true, "pwd": "76841722f39207db6b332e64bfacd4ba" }
   Fetched 1 record(s) in 1ms -- Index[none] -- More[false]


Role-based access control with MongoDB is simple
with only two roles – "read" and "normal" (i.e. full read/write
access).  There are several tickets related to improving the
implementation of authorization within MongoDB:

* :issue:`SERVER-3198`
* :issue:`SERVER-7122`
* :issue:`SERVER-7124`

The admin database is special.  Several administrative commands
can only run on the admin database (and so can only be run by an
admin user).  You can use the `db.admin.command()` shell helper as
one way of running administrative commands.  For example, to list
all databases:

.. code-block:: javascript
   
   db.adminCommand( { listDatabases : 1 } )

Additionally, please be aware that users with access to the admin
database have “read and write” access to all other databases on
the server/cluster. 

Adding Users
------------

You must either:

#. have added a user to the admin db before starting the server with 
   :option:`--auth <mongod --auth>`,

#. added the first user from a localhost connection (you cannot add
   the first user from a connection that is not local with respect to
   the :program:`mongod` process).

.. note:: 

	Option (2) to add a user via localhost does not work in
	sharded clusters running v2.2+ due to :issue:`SERVER-6591`. If you are
	running 2.2 with a sharded cluster and want to use secure mode you
	must setup the cluster and add an admin user before restarting the
	cluster to run with :option:`--keyFile <mongod --keyFile>`.

Configuration
~~~~~~~~~~~~~

First create an administrator for the `mongod` instance.  This
user is stored under the special `admin` database.

If there are no admin users, one may access the database from the
localhost interface without authenticating.  Therefore, on the
localhost, run the :program:`mongo` shell and configure an admin user:

.. code-block:: javascript

   > use admin // we are using the admin database
   > db.addUser("theadmin", "anadminpassword") 

Now, let’s configure a “regular” user for another database (projectx):

.. code-block:: javascript

	> use projectx  // we are using the a projectx database
	> db.addUser("joe", "passwordForJoe") 

Let’s add a read-only user:

.. code-block:: javascript
	
	> use projectx 
	> db.addUser("guest", "passwordForGuest", true) 

Logging in as Admin User

Although admin user accounts can access any database, you must log
into the admin database. For example, if user ``superAdmin`` has an
admin account, this login will be successful:

.. code-block:: javascript

   $ mongo 
   > use admin
   > db.auth("superAdmin", "Password123")

but these commands below will fail:

.. code-block:: javascript

   > use test
   > db.auth("superAdmin", "Password123")
   1

In versions up to and including 2.2, be aware that once you have
``admin`` access in the :program:`mongo` shell, you have admin access.
If you try to authenticate to a read-only user, the authentication
will succeed, however, you will still have ``admin``, i.e. write,
permissions.

For example, authenticate as an admin (notice the shell prompt changes):

.. code-block:: javascript

   > use admin
   switched to db admin

   admin> db.auth("adminUser", "adminPassword")
   1

   admin> use test
   switched to db test
 
   test> db.system.users.find()
   { "_id": ObjectId("5075362366b2b6e3603b65c9"), "user": "readOnly", "readOnly": true, "pwd": "76841722f39207db6b332e64bfacd4ba" }
   Fetched 1 record(s) in 1ms -- Index[none] -- More[false]


Now, authenticate as ``readOnly``, note that your id does not change
and you will still have ``write`` access:

.. code-block:: javascript

   test> db.auth("readOnly", "readOnly")

   test> db.coll.insert({foo:'bar'})  // still actually adminUser
   Inserted 1 record(s) in 1ms
   
   test > db.coll.find()
   { "_id": ObjectId("50753692492db9d88b98f7dc"), "foo": "bar" }
   Fetched 1 record(s) in 1ms -- Index[none] -- More[false]

Authentication on Localhost
---------------------------

.. versionadded:: 2.0

The trust model, in this version, dictates that that if the
user has access to running the mongo shell on localhost
(127.0.0.1) then the user has write access to add users
regardless of what authentication is enforced in the :program:`mongod`
configuration, i.e. authentication does not apply to users
logging into `mongod` on localhost.


.. versionadded:: 2.2
   
The trust model changed for MongoDB 2.2.  If :program:`mongod`
is started with the :option:`--auth <mongod --auth>` option then
authentication is applied to local users.

For example, below the user connects as a read-only user to the
test database and tries to insert a collection but cannot.

.. code-block:: sh

	$ mongo localhost/test -u readOnly -p test

.. code-block:: javascript

	MongoDB shell version: 2.2.0
	connecting to: localhost/test

	test > db.coll.insert({foo:'bar'})
	unauthorized

	test > db.system.users.find()
	error: {
	  "$err": "unauthorized db:test ns:test.system.users lock type:1 client:127.0.0.1",
		 "code": 10057
		 }

However, when connecting to MongoDB over localhost with
authentication enabled but without any admin users, the user may
access the database from the localhost interface without
authenticating.

In summary, below is a table of the scenarios for accessing the
database when running with authentication enabled:
   
.. list-table::
   :widths: 25 25 50
   :header-rows: 1
   
   * - Connection	
     - Admin Users Exist
     - Authentication Required on Accessing Database
   * - Localhost
     - Yes
     - Yes
   * - Locahost
     - No
     - No
   * - Remote
     - Yes
     - Yes
   * - Remote
     - No
     - Yes

Password Hashing Insecurity
---------------------------

In version 2.2.* and earlier, it is possible that if an evil user
“Eve” has admin access to the same  database (db1) as another user
“Bob” and Bob is an admin user on another database (db2) and has
used the same password on db2 then Eve can take the hash of Bob’s
password from the system.users collection on db1 to log in as Bob
on db2.

This authentication schema is working as designed and is
consistent with the MongoDB trust model up to and including 2.2. 
Subsequent versions of MongoDB will contain more secure and
enterprise-type authentication models. For further information,
please see :issue:`SERVER-3198` and :issue:`SERVER-7155`. 

Below is a step-by-step walkthrough. 

Eve connects to the “test” database and we see that
both Eve and Bob have accounts with “admin” access:

.. code-block:: sh

   $ mongo 10.7.100.27/db1 -u eve -p test

.. code-block:: javascript

   MongoDB shell version: 2.2.0
   connecting to: 10.7.100.27/db1
   test> db.system.users.find()
   { "_id": ObjectId("5074202e032a960d16f4394e"), "user": "bob", "readOnly": false, "pwd": "ac2061b4a08ef8f2d60a07dc18ab4a0a" }
   { "_id": ObjectId("507420ba032a960d16f43951"), "user": "eve", "readOnly": false, "pwd": "5dcc2819b97e68d5cfe51da6cae8a7f6" }
   Fetched 2 record(s) in 1ms -- Index[none] -- More[false]

Bob also has an account on the admin database and has used the same password:

.. code-block:: javascript
 
   test> use admin
   switched to db admin
   test> db.auth("bob", "test")

   admin> db.system.users.find()
   { "_id": ObjectId("50742045032a960d16f43950"), "user": "bob", "readOnly": false, "pwd": "ac2061b4a08ef8f2d60a07dc18ab4a0a" }
   Fetched 1 record(s) in 1ms -- Index[none] -- More[false]

Secure Mode on Shards and Replica Sets
--------------------------------------

To secure a shard cluster using Secure Mode, you must enable
secure mode on all components of the shard cluster. Use the
:option:`--keyFile <mongos --keyFile>`
option on all routers (:program:`mongos`), 
configuration database servers (:program:`mongod --configsvr`), 
and shard servers (:program:`mongod --shardsvr`).

There are two classes of security credentials in a shard cluster:
credentials for "admin" users (i.e. for the "admin" database) and
credentials for all other databases.  These credentials reside in
different locations within the shard cluster and have different
roles:

Admin database credentials reside on the config databases. To
receive admin access to the cluster you must authenticate a
session while connected to a mongos instance using the "admin"
database.

Other database credentials reside on the primary shard for the
database.

This means that you can authenticate to these users and databases
while connected directly to the primary shard for a database,
however, for clarity and consistency all interactions between the
client and the database should use a mongos instance.

Individual shards can store administrative credentials to their
instance, which only permit access to a single shard. These
credentials are stored in the shard’s "admin" database and are
completely distinct from the cluster-wide administrative
credentials described in "1." above.


To enable “secure mode” on shards or replica sets, the --auth
option is not sufficient, you must use the `--keyFile` option.

To enable secure mode, run the mongod process with the `--auth`
option (or --keyFile for replica sets and sharding).  For example,

.. code-block:: sh

   mongod  --auth 

   mongod --shardsvr  --keyFile MySecretKey


KeyFile
-------

A key file must contain at least six Base64 characters and be no
larger than 1KB (whitespace included). Whitespace characters (x0d,
x09, x20) are stripped (mostly for cross-platform convenience), so
to the database, the following keys are identical:

.. code-block:: sh

   $ echo -e "my secret key" > key1
   $ echo -e "my secret key\n" > key2
   $ echo -e "my    secret    key" > key3
   $ echo -e "my\r\nsecret\r\nkey\r\n" > key4

As the key is stored in a file, you won't have to type it in much,
so it is a good idea to make it long and with a good degree of
randomness within it – 32 characters long for example.  A possible
solution is to generate it with `mkpasswd` plus extra-appended
characters from the administrator setting up the cluster.

.. warning:: 

   If you run mongod with `-v`, the key will be printed in the log.

The keyfile must be owned and readable by the account running the
MongoDB instance.  The MongoDB instance will exit with an error if
the keyfile is readable, writeable or executable by any other
account on the system.

Currently, permissions are not checked by :program:`mongod.exe` on Windows.	