.. _read-operations-indexing:

=======
Indexes
=======

.. TODO this page needs to be retitled. also restructure introduction
   and remove lists when needed.

.. default-domain:: mongodb

Indexes improve the efficiency of read operations by reducing the
amount of data that query operations need to process and thereby
simplifying the work associated with fulfilling queries within
MongoDB. The indexes themselves are a special data structure that
MongoDB maintains when inserting or modifying documents, and any given
index can: support and optimize specific queries, sort operations, and
allow for more efficient storage utilization. For more information
about indexes in MongoDB see: :doc:`/indexes` and :doc:`/core/indexes`.

You can create indexes using the :method:`db.collection.ensureIndex()` method
in the :program:`mongo` shell, as in the following prototype
operation:

.. code-block:: javascript

   db.collection.ensureIndex( { <field1>: <order>, <field2>: <order>, ... } )

- The ``field`` specifies the field to index. The field may be a field
  from a subdocument, using :term:`dot notation` to specify subdocument
  fields.

  You can create an index on a single field or a :ref:`compound index
  <index-type-compound>` that includes multiple fields in the index.

- The ``order`` option is specifies either ascending ( ``1`` ) or
  descending ( ``-1`` ).

  MongoDB can read the index in either direction. In most cases, you
  only need to specify :ref:`indexing order
  <index-ascending-and-descending>` to support sort operations in
  compound queries.

.. _read-operations-covered-query:

Covering a Query
----------------

An index :ref:`covers <indexes-covered-queries>` a query, a *covered
query*, when:

- all the fields in the :ref:`query <read-operations-query-document>`
  are part of that index, **and**

- all the fields returned in the documents that match the query are in
  the same index.

For these queries, MongoDB does not need to inspect at documents
outside of the index, which is often more efficient than inspecting
entire documents.

.. example::

   Given a collection ``inventory`` with the following index on the
   ``type`` and ``item`` fields:

   .. code-block:: sh

      { type: 1, item: 1 }

   This index will cover the following query on the ``type`` and ``item``
   fields, which returns only the ``item`` field:

   .. code-block:: javascript

      db.inventory.find( { type: "food", item:/^c/ },
                         { item: 1, _id: 0 } )

   However, this index will **not** cover the following query, which
   returns the ``item`` field **and** the ``_id`` field:

   .. code-block:: javascript

      db.inventory.find( { type: "food", item:/^c/ },
                         { item: 1 } )

See :ref:`indexes-covered-queries` for more information on the
behavior and use of covered queries.

Measuring Index Use
~~~~~~~~~~~~~~~~~~~

The :method:`~cursor.explain()` cursor method allows you to
inspect the operation of the query system, and is useful for analyzing
the efficiency of queries, and for determining how the query uses the
index. Call the :method:`~cursor.explain()` method on a
cursor returned by :method:`~db.collection.find()`, as in the
following example:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).explain()

.. note::

   Only use :method:`~cursor.explain()` to test the query
   operation, and *not* the timing of query performance. Because
   :method:`~cursor.explain()` attempts multiple query
   plans, it does not reflect accurate query performance.

If the above operation could not use an index, the output of
:method:`~cursor.explain()` would resemble the following:

.. code-block:: javascript

   {
     "cursor" : "BasicCursor",
     "isMultiKey" : false,
     "n" : 5,
     "nscannedObjects" : 4000006,
     "nscanned" : 4000006,
     "nscannedObjectsAllPlans" : 4000006,
     "nscannedAllPlans" : 4000006,
     "scanAndOrder" : false,
     "indexOnly" : false,
     "nYields" : 2,
     "nChunkSkips" : 0,
     "millis" : 1591,
     "indexBounds" : { },
     "server" : "mongodb0.example.net:27017"
   }

The ``BasicCursor`` value in the :data:`~explain.cursor` field
confirms that this query does not use an index. The
:data:`explain.nscannedObjects` value shows that MongoDB must scan
4,000,006 documents to return only 5 documents. To increase the
efficiency of the query, create an index on the ``type`` field, as in
the following example:

.. code-block:: javascript

   db.inventory.ensureIndex( { type: 1 } )

Run the :method:`~cursor.explain()` operation, as follows,
to test the use of the index:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).explain()

Consider the results:

.. code-block:: javascript

   {
     "cursor" : "BtreeCursor type_1",
     "isMultiKey" : false,
     "n" : 5,
     "nscannedObjects" : 5,
     "nscanned" : 5,
     "nscannedObjectsAllPlans" : 5,
     "nscannedAllPlans" : 5,
     "scanAndOrder" : false,
     "indexOnly" : false,
     "nYields" : 0,
     "nChunkSkips" : 0,
     "millis" : 0,
     "indexBounds" : { "type" : [
                                   [ "food",
                                     "food" ]
                                ] },
     "server" : "mongodbo0.example.net:27017" }

The ``BtreeCursor`` value of the :data:`~explain.cursor` field indicates that
the query used an index. This query:

- returned 5 documents, as indicated by the :data:`~explain.n` field;

- scanned 5 documents from the index, as indicated by the
  :data:`~explain.nscanned` field;

- then read 5 full documents from the collection, as indicated by
  the :data:`~explain.nscannedObjects` field.

  Although the query uses an index to find the matching documents, if
  :data:`~explain.indexOnly` is false then an index could
  not :ref:`cover <read-operations-covered-query>` the query:
  MongoDB could not both match the :ref:`query conditions
  <read-operations-query-document>` **and** return the results using
  only this index. See :ref:`indexes-covered-queries` for more
  information.

.. index:: query optimizer
.. _read-operations-query-optimization:

Query Optimization
~~~~~~~~~~~~~~~~~~

The MongoDB query optimizer processes queries and chooses the most
efficient query plan for a query given the available indexes. The
query system then uses this query plan each time the query runs. The
query optimizer occasionally reevaluates query plans as the content of
the collection changes to ensure optimal query plans.

To create a new query plan, the query optimizer:

1. runs the query against several candidate indexes in parallel.

#. records the matches in a common results buffer
   or buffers.

   - If the candidate plans include only :term:`ordered query plans
     <ordered query plan>`, there is a single common results buffer.

   - If the candidate plans include only :term:`unordered query plans
     <unordered query plan>`, there is a single common results buffer.

   - If the candidate plans include *both* :term:`ordered query plans
     <ordered query plan>` and :term:`unordered query plans
     <unordered query plan>`, there are two common results buffers, one
     for the ordered plans and the other for the unordered plans.

   If an index returns a result already returned by another index, the
   optimizer skips the duplicate match. In the case of the two buffers,
   both buffers are de-duped.

#. stops the testing of candidate plans and selects an index when one of
   the following events occur:

   - An :term:`unordered query plan` has returned all the matching results; *or*

   - An :term:`ordered query plan` has returned all the matching results; *or*

   - An :term:`ordered query plan` has returned a threshold number of
     matching results:

     - Version 2.0: Threshold is the query batch size. The default
       batch size is 101.

     - Version 2.2: Threshold is 101.

The selected index becomes the index specified in the query plan;
future iterations of this query or queries with the same query
pattern will use this index. Query pattern refers to query select
conditions that differ only in the values, as in the following two
queries with the same query pattern:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } )
   db.inventory.find( { type: 'utensil' } )

To manually compare the performance of a query using more than one
index, you can use the :method:`hint() <cursor.hint()>` and
:method:`explain() <cursor.explain()>` methods in conjunction, as in
the following prototype:

.. code-block:: javascript

   db.collection.find().hint().explain()

The following operations each run the same query but will reflect the
use of the different indexes:

.. code-block:: javascript

   db.inventory.find( { type: 'food' } ).hint( { type: 1 } ).explain()
   db.inventory.find( { type: 'food' } ).hint( { type: 1, name: 1 }).explain()

This returns the statistics regarding the execution of the query. For
more information on the output of :method:`explain()
<cursor.explain()>`, see :doc:`/reference/method/cursor.explain`.

.. note::

   If you run :method:`explain() <cursor.explain()>` without including
   :method:`hint() <cursor.hint()>`, the query optimizer reevaluates
   the query and runs against multiple indexes before returning the
   query statistics.

As collections change over time, the query optimizer deletes a query
plan and reevaluates the after any of the following events:

- the collection receives 1,000 write operations.

- the :dbcommand:`reIndex` rebuilds the index.

- you add or drop an index.

- the :program:`mongod` process restarts.

For more information, see :doc:`/applications/indexes`.

Query Operations that Cannot Use Indexes Effectively
----------------------------------------------------

Some query operations cannot use indexes effectively or cannot use
indexes at all. Consider the following situations:

- The inequality operators :operator:`$nin` and :operator:`$ne` are
  not very selective, as they often match a large portion of the
  index.

  As a result, in most cases, a :operator:`$nin` or :operator:`$ne`
  query with an index may perform no better than a :operator:`$nin` or
  :operator:`$ne` query that must scan all documents in a collection.

- Queries that specify regular expressions, with inline JavaScript
  regular expressions or :operator:`$regex` operator expressions,
  cannot use an index. *However*, the regular expression with anchors
  to the beginning of a string *can* use an index.
