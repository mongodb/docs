=========================
Analyze Query Performance
=========================

.. default-domain:: mongodb

The MongoDB query optimizer processes queries and chooses the most optimal
:doc:`query plan </core/query-plans>` for a query given the available
indexes. Sometimes you can optimize a query or index based on their
impact on database performance.

The :method:`~cursor.explain()` cursor method provides statistics about
the performance of a query. This data output can be useful in measuring
how optimally a query uses indexes, document lookups, and other database
functionality to retrieve information.

The :method:`~cursor.explain()` method output does not reflect an accurate
timing of query performance.

See :doc:`/core/query-optimization`,
:doc:`/tutorial/optimize-query-performance-with-indexes-and-projections`,
and :doc:`/applications/indexes` for more information about building
optimal database queries.

Evaluate the Performance of a Query
-----------------------------------

You can use the :method:`~cursor.explain()` method to understand and
evaluate the performance characteristics of different query and index
combinations.

For the following examples, consider a collection with these six documents with fields
for ``id``, ``section``, and ``status``:

.. code-block:: javascript

   { "_id" : 1, "section" : 1, "status" : 1 }
   { "_id" : 2, "section" : 2, "status" : 1 }
   { "_id" : 3, "section" : 1, "status" : 1 }
   { "_id" : 4, "section" : 3, "status" : 1 }
   { "_id" : 5, "section" : 4, "status" : 0 }
   { "_id" : 6, "section" : 4, "status" : 0 }

Range Query with No Index
~~~~~~~~~~~~~~~~~~~~~~~~~

The following range query retrieves documents where the ``section``
field has a value between ``2`` and ``4``:

.. code-block:: javascript

   db.posts.find( { section: { $gte: 2, $lte: 4 } } )

The query returns these four documents:

.. code-block:: javascript

   { "_id" : 2, "section" : 2, "status" : 1 }
   { "_id" : 4, "section" : 3, "status" : 1 }
   { "_id" : 5, "section" : 4, "status" : 0 }
   { "_id" : 6, "section" : 4, "status" : 0 }

The following range query with the :method:`~cursor.explain()` method
generates statistics about the database impact of this query:

.. code-block:: javascript

   db.posts.find( { section: { $gte: 2, $lte: 4 } } ).explain()

The :method:`~cursor.explain()` method returns this output:

.. code-block:: javascript

   {
       "cursor" : "BasicCursor",
       "isMultiKey" : false,
       "n" : 4,
       "nscannedObjects" : 6,
       "nscanned" : 6,
       "nscannedObjectsAllPlans" : 6,
       "nscannedAllPlans" : 6,
       "scanAndOrder" : false,
       "indexOnly" : false,
       "nYields" : 0,
       "nChunkSkips" : 0,
       "millis" : 0,
       "server" : "machine.local:27017",
       "filterSet" : false
   }

This query returned 4 documents, as indicated by the :data:`~explain.n`
field.

The :data:`~explain.n` field indicates the query returned 4 documents. The
``BasicCursor`` value of the :data:`~explain.cursor` field indicates the
query did not use an index. See :ref:`explain-output` for descriptions of
the other fields in this output.

The differences between 4 returned documents, 6 documents scanned from the
index, and 6 documents read as a result of the query suggests this might
not be an optimal query. The database scanned and read 2 documents more
than it returned.

A Query with an Index on One Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add an index on the ``section`` field with the
:method:`~db.collection.ensureIndex` method, then run the following range
query for documents with ``section`` fields with values between ``2`` and
``4`` with the :method:`~cursor.explain()` method:

.. code-block:: javascript

   db.posts.find( { section: { $gte: 2, $lte: 4 } } ).explain()

The :method:`~cursor.explain()` method returns this output:

.. code-block:: javascript

   {
       "cursor" : "BtreeCursor section_1",
       "isMultiKey" : false,
       "n" : 4,
       "nscannedObjects" : 4,
       "nscanned" : 4,
       "nscannedObjectsAllPlans" : 4,
       "nscannedAllPlans" : 4,
       "scanAndOrder" : false,
       "indexOnly" : false,
       "nYields" : 0,
       "nChunkSkips" : 0,
       "millis" : 0,
       "indexBounds" : {
              "section" : [
                     [
                            2,
                            4
                     ]
              ]
       },
       "server" : "machine.local:27017",
       "filterSet" : false
   }

This query returned 4 documents, as indicated by the :data:`~explain.n`
field.

To return these 4 documents, the :data:`~explain.nscanned` field indicates
the query scanned 4 documents from the index and the
:data:`~explain.nscannedObjects` field indicates the query read 4 full
documents from the collection.

The ``BtreeCursor section_1`` value of the :data:`~explain.cursor` field
indicates the query used an index on the ``section`` field. See
:ref:`explain-output` for descriptions of the other fields in this output.

The numeric equality between 4 returned documents, 4 documents scanned
from the index, and 4 documents read as a result of the query suggests
this might be an optimal query.

A Query with a Compound Index
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add a compound index on the ``section`` and ``status`` fields, in that
order, with the :method:`~db.collection.ensureIndex()` method:

.. code-block:: javascript

   db.collection.ensureIndex( { section: 1, status: 1 } )

Then run the following query with the :method:`~cursor.explain()` method
to evaluate the database impact of this query request:

.. code-block:: javascript

   db.posts.find( { section: { $gte: 2, $lte: 4 }, status: 1 } ).explain()

The :method:`~cursor.explain()` method returns this output:

.. code-block:: javascript

   {
       "cursor" : "BtreeCursor section_1_status_1",
       "isMultiKey" : false,
       "n" : 2,
       "nscannedObjects" : 2,
       "nscanned" : 3,
       "nscannedObjectsAllPlans" : 2,
       "nscannedAllPlans" : 3,
       "scanAndOrder" : false,
       "indexOnly" : false,
       "nYields" : 0,
       "nChunkSkips" : 0,
       "millis" : 0,
       "indexBounds" : {
           "section" : [
               [
                   2,
                   4
               ]
           ],
           "status" : [
               [
                   1,
                   1
               ]
           ]
       },
       "server" : "machine.local:27017",
       "filterSet" : false
   }

This query returned 2 documents, as indicated by the :data:`~explain.n`
field.

To return these 2 documents, the :data:`~explain.nscanned` field indicates
the query scanned 3 documents from the index and the
:data:`~explain.nscannedObjects` field indicates the query read 2 full
documents from the collection.

The ``BtreeCursor section_1_status_1`` value of the
:data:`~explain.cursor` field indicates the query used a compound index on
the ``section`` field and ``status`` field. See :ref:`explain-output` for
descriptions of the other fields in this output.

The differences between 2 returned documents, 3 documents scanned from the
index, and 2 documents read as a result of the query suggests a query with
the compound index might be optimal.

Compare Performance of Indexes
------------------------------

To manually compare the performance of a query using more than one
index, you can use the :method:`~cursor.hint()` and
:method:`~cursor.explain()` methods in conjunction.

.. example:: Evaluate a query using different indexes:

   .. code-block:: javascript

      db.inventory.find( { type: 'food' } ).hint( { type: 1 } ).explain()
      db.inventory.find( { type: 'food' } ).hint( { type: 1, name: 1 } ).explain()

   These return the statistics regarding the execution of the query
   using the respective index.

.. note::

   If you run :method:`explain() <cursor.explain()>` without including
   :method:`hint() <cursor.hint()>`, the query optimizer reevaluates
   the query and runs against multiple indexes before returning the
   query statistics.

For more detail on the explain output, see :ref:`explain-results`.
