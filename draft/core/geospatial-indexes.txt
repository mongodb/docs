==================
Geospatial Indexes
==================

.. default-domain:: mongodb

Overview
--------

MongoDB supports location-based queries and geospatial data with a
special index for coordinate data. The geospatial index stores :ref:`geohashes
<geospatial-geohash>`, and makes it possible to return documents
based on proximity to a point or within a bounded region. Geospatial
queries support coordinate systems on either flat and spherical surfaces.
Additionally, geospatial haystack indexes provide additional
support for certain classes of region-based queries.

This document introduces the core concepts
that underpin geospatial queries and indexes in MongoDB. For more information,
:doc:`/applications/geospatial-indexes` provide complete documentation
of all location-based operations and queries.

.. include:: /includes/geospatial-coordinates.rst

.. _geospatial-indexes:

Geospatial Indexes
------------------

.. see:: :ref:`geospatial-coordinates` for an overview on modeling
   location data in MongoDB.

To use geospatial functions in MongoDB, model
location data in a 2D array, then create an index using the
:func:`ensureIndex <db.collection.ensureIndex()>` method on this field
using the ``2d`` option. Consider the following prototype operation:

.. code-block:: javascript

   db.collection.ensureIndex( { <location field> : "2d" } )

After the ``2d`` index has been created, all queries using coordinates
will use this geospatial index.  The index uses a :term:`geohash`
calculated from the coordinates.  For more information on
:term:`geohash`, please refer to the :ref:`geohash
<geospatial-geohash>` section.

To perform queries on your geospatial data, please see
:doc:`/applications/geospatial-indexes`.

.. note::

   MongoDB only supports *one* geospatial index per collection. As
   with any MongoDB index, any single query can only
   use one index. Creating more than one geospatial index with a
   collection will produce unexpected results.

.. _geospatial-indexes-range:

Range
~~~~~

All geospatial indexes are bounded. MongoDB will
return an error and reject documents with coordinate data outside of
the specified range. The default range assumes latitude and longitude
data, and are between -180 inclusive and 180
non-inclusive (i.e. ``[-180, 180)``.)

To configure the range of a geospatial index, use the ``min`` and
``max`` options with the :func:`ensureIndex() <db.collection.ensureIndex()>`
operation, as in the following prototype.

.. code-block:: javascript

   db.collection.ensureIndex( { <location field>: "2d" } ,
                              { min: <lower bound> , max: <upper bound> } )

The following operation will create an index on the  ``places``
collection, for coordinates in the ``loc`` field, with the range
between ``-90`` and ``90``:

.. code-block:: javascript

   db.places.ensureIndex( { loc: "2d" } ,
                           { min: 90 , max: 90 } )

For more information see the :ref:`geospatial precision
<geospatial-indexes-precision>` and :ref:`geohash
<geospatial-geohash>` sections.

.. _geospatial-indexes-precision:

Precision
~~~~~~~~~

Geospatial indexes use "bits" to represent precision, or
resolution. Higher bit values allow MongoDB to return more precise
results, at the expense of speed. For more information on the
relationship between bits and precision, see the :ref:`geohash
<geospatial-geohash>` section.

By default, geospatial indexes in MongoDB have 26 bits of precision,
although precision is configurable upon index creation and MongoDB
supports up to 32 bits of precision. With 26 bits of precision, using
the default range of -180 to 180, geospatial data can be precise to roughly 2
feet or about 60 centimeters.

You can set the precision of a geospatial index during creation by
specifying the ``bits`` option to the :func:`ensureIndex()
<db.command.ensureIndex()>` method, as in the following prototype:

.. code-block:: javascript

   db.collection.ensureIndex( {<location field>: "2d"} ,
                              { bits: <bit precision> } )

Only create an index with fewer than 26 bits *if* your the data in
your collection is less precise and/or you're willing to sacrifice
precision for query speed.

Compound Indexes
~~~~~~~~~~~~~~~~

MongoDB supports :ref:`compound indexes <index-type-compound>` where
one component holds coordinate data. For queries that include these
fields, MongoDB will use this index for a larger portion of these
operations, which will improve performance for these queries.

Use an operation that resembles the following to create a geospatial
index with a compound key.

.. code-block:: javascript

   db.collection.ensureIndex( { <location field>: "2d", <field>: 1 } );

These indexes support regular geospatial queries as well as queries where you must filter both by
location and by another field. For example, if you need to return a
list of restaurants near a given point, but you want to optionally
filter restaurants by type, such as "take-out," or
"bar" stored in the ``type`` field.

.. note::

   Limits in geospatial queries are always applied to the geospatial
   component first. This will affect the results if you specify
   additional sort operations.

.. see also: ":ref:`<index-type-compound>`" and ":ref:`<geospatial-haystack-index>`"

.. _geospatial-haystack-index:

Haystack Index
~~~~~~~~~~~~~~

Geospatial haystack indexes make it possible to tune the
distribution of your data and build a special bucket
index. Haystack indexes improve query performance for queries limited
to a specific area.

.. note::

   Haystack indexes are not suited to returning the closest documents to
   a particular location, as the closest documents could be far away
   compared to the ``bucketSize``.

To build a :term:`geoHaystack` index, specify the ``geoHaystack`` for the
location field and a ``bucketSize`` parameter . The ``bucketSize``
parameter determines the granularity of the bucket index. A
``bucketSize`` of ``1`` creates an index that stores keys within a single unit
in the coordinate in the same bucket.

.. code-block:: javascript

   db.collection.ensureIndex({ <location field>: "geoHaystack", type: 1 },
                             { bucketSize: <bucket value> })

By default, all queries that use a geospatial haystack index will return 50
documents.

To query geohaystack indexes, you *must* use the :dbcommand:`geoSearch`
command, please see the :ref:`Querying Haystack Indexes
<geospatial-haystack-queries>` section.

:ref:`Spherical queries <geospatial-spherical-representation>` are not
supported by haystack indexes.

.. _geospatial-spherical-representation:

Spatial Representation Systems
------------------------------

MongoDB supports two systems for representing and returning geospatial
results. The default representation is flat and assumes coordinates
points are on a flat surface, which is sufficient for many
applications. For coordinate points that refer to locations on a
spherical surface, (i.e. coordinates on Earth) spherical queries will
provide results that account for curvature of the Earth's surface.

.. note::

   There is no difference between flat and spherical *data* as stored
   in MongoDB. Rather, the only difference between spherical and flat
   geospatial systems in MongoDB is in the **queries**.

For more information on query operations for spherical systems see the
:ref:`spherical queries <geospatial-query-spherical>` section.

.. _geospatial-geohash:

Geohash
-------

To create a geospatial index, MongoDB computes the :term:`geohash`
value for the coordinate pair in the specified values.

To calculate a geohash value, continuously divide a 2D map into
quadrants. Then, assign each quadrant a two bit value. For example, a
two bit representation of four quadrants would be:

.. code-block:: javascript

   01  11

   00  10

These two bit values, ``00``, ``01``, ``10``, and ``11``, represent
each of the quadrants, and points within that quadrant. For a
:term:`geohash` with two bits of resolution, a point in the bottom
left quadrant would have a geohash of ``00``.  The top left quadrant
would have the geohash of ``01``. The bottom right and top right would
have a geohash of ``10`` and ``11``, respectively.

To provide additional precision, continue dividing each quadrant into
sub-quadrants. To identify quadrants within a sub-quadrant, take the
geohash for the containing quadrant (e.g. ``01``) and concatenate the geohash for
the sub-quadrant. Therefore, the geohash for
the upper-right quadrant is ``11``, the geohash for the sub-quadrants would be:
``1101``, ``1111``, ``1110``, and ``1100``.

To calculate a more precise :term:`geohash`, continue dividing the
sub-quadrant, concatenate the two-bit identifier for each division. The
more "bits" in the hash identifier for a given point, the smaller
possible area that the hash can describe, and the higher the
resolution of the geospatial index.

.. the following is a section about the limitations of geospatial
   indexes in sharding:

.. include:: /includes/geospatial-sharding.rst
