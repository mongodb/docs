const path = require('path');
const fs = require('fs');
const vm = require('vm');
const { Decimal128, ObjectId } = require('mongodb'); // Import MongoDB data types

/**
 * Compares the actual output from a MongoDB operation against the expected output stored in a file.
 * Supports both ordered and unordered array comparisons, and performs deep comparisons of nested objects.
 * MongoDB-specific types such as Decimal128, ObjectId, and Date are normalized for consistent comparisons.
 *
 * @param {string} filepath - The relative path to the expected output file. The file must contain valid JSON.
 * @param {Array<Object>} output - The actual output generated by the MongoDB operation, expected to be an array of objects.
 * @param {string} [comparisonType='unordered'] - The type of comparison for arrays:
 *   - 'unordered': Arrays are treated as unordered collections, comparing elements regardless of order.
 *   - 'ordered': Arrays are compared in a strict order, with elements matched positionally.
 *
 * @returns {boolean} True if the actual output matches the expected output, false otherwise.
 *   - Logs detailed mismatch information in the console if the comparison fails.
 *   - Returns false if one or both arrays are undefined.
 *
 * @throws {Error} If `comparisonType` is neither 'ordered' nor 'unordered'.
 *
 * @example
 * // Example: Unordered comparison (default)
 * const matches = outputMatchesExampleOutput('examples/tutorial-output.json', actualOutput);
 * console.log(matches); // true if arrays match regardless of order
 *
 * @example
 * // Example: Ordered comparison
 * const matches = outputMatchesExampleOutput(
 *   'examples/tutorial-output.json',
 *   actualOutput,
 *   'ordered'
 * );
 * console.log(matches); // true if arrays match exactly with order preserved
 *
 * @description
 * The function reads the expected output from the specified file, preprocesses for formatting
 * issues (e.g., missing arrays, single-quoted strings), and evaluates it safely in a sandbox environment.
 * Nested fields, including arrays and objects, are recursively normalized for deep comparisons.
 * The function logs mismatched outputs for debugging purposes if the comparison fails.
 */
function outputMatchesExampleOutput(
  filepath,
  output,
  comparisonType = 'unordered'
) {
  // Accept 'ordered' or 'unordered'
  const filepathString = '../examples/' + filepath;
  const outputFilePath = path.resolve(__dirname, filepathString);
  const rawExpectedOutput = fs.readFileSync(outputFilePath, 'utf8');

  const preprocessFileContents = (contents) => {
    const wrappedContents = contents
      .trim()
      .replace(/}\n{/g, '},\n{') // Add commas between concatenated objects
      .replace(/'(.*?)'/g, '"$1"') // Convert single quotes to double quotes
      .replace(/^\{/g, '[{') // Wrap first object in an array if missing
      .replace(/}$/g, '}]'); // Wrap last object in an array if missing

    const processed = wrappedContents.replace(
      /(\b[a-zA-Z_]\w*)\s*:/g,
      '"$1":' // Wrap keys in double quotes
    );

    const finalProcessed = processed.replace(
      /:\s*([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.?[0-9]*Z?)/g,
      (match, dateValue) => {
        const normalizedDate = new Date(dateValue).toISOString(); // Normalize date to UTC
        return `: "${normalizedDate}"`;
      }
    );

    return finalProcessed;
  };

  const processedExpectedOutput = preprocessFileContents(rawExpectedOutput);

  const context = {
    Decimal128: (value) => new Decimal128(value),
    ObjectId: (value) => new ObjectId(value),
    Date: (value) => new Date(value),
  };

  let expectedOutputArray;
  try {
    expectedOutputArray = vm.runInNewContext(processedExpectedOutput, context);
  } catch (error) {
    console.error('Failed to parse expected output:', error);
    return false;
  }

  const normalizeItem = (item) => {
    const normalized = {};
    for (const key in item) {
      const value = item[key];

      if (value instanceof Decimal128 || value instanceof ObjectId) {
        normalized[key] = value.toString();
      } else if (value instanceof Date) {
        normalized[key] = value.toISOString();
      } else if (
        typeof value === 'string' &&
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.?[0-9]*Z?$/.test(value)
      ) {
        // Parse and re-normalize string-formatted dates to UTC
        const parsedDate = new Date(value);
        normalized[key] = parsedDate.toISOString();
      } else if (Array.isArray(value)) {
        normalized[key] = value.map((element) =>
          typeof element === 'object' && element !== null
            ? normalizeItem(element)
            : element
        );
      } else if (typeof value === 'object' && value !== null) {
        normalized[key] = normalizeItem(value);
      } else {
        normalized[key] = value;
      }
    }
    return normalized;
  };

  const areObjectsEqual = (obj1, obj2, comparisonType) => {
    if (
      typeof obj1 !== 'object' ||
      obj1 === null ||
      typeof obj2 !== 'object' ||
      obj2 === null
    ) {
      return obj1 === obj2; // Direct comparison for non-object values
    }

    if (Array.isArray(obj1) && Array.isArray(obj2)) {
      if (comparisonType === 'unordered') {
        const normalizedArray1 = obj1.map(normalizeItem);
        const normalizedArray2 = obj2.map(normalizeItem);

        return normalizedArray1.every((item1) =>
          normalizedArray2.some((item2) =>
            areObjectsEqual(item1, item2, comparisonType)
          )
        );
      } else if (comparisonType === 'ordered') {
        return obj1.every((element, index) =>
          areObjectsEqual(element, obj2[index], comparisonType)
        );
      } else {
        throw new Error(
          `Invalid comparisonType: ${comparisonType}. Use "ordered" or "unordered".`
        );
      }
    }

    const keys1 = Object.keys(obj1).sort();
    const keys2 = Object.keys(obj2).sort();

    if (keys1.length !== keys2.length) {
      return false; // Different number of keys
    }

    for (const key of keys1) {
      if (!keys2.includes(key)) {
        return false; // Mismatched keys
      }
      const val1 = obj1[key];
      const val2 = obj2[key];

      if (!areObjectsEqual(val1, val2, comparisonType)) {
        return false; // Mismatched values
      }
    }

    return true;
  };

  if (Array.isArray(output) && Array.isArray(expectedOutputArray)) {
    const isEqual =
      output.length === expectedOutputArray.length &&
      expectedOutputArray.every((expectedItem) =>
        output.some((actualItem) =>
          areObjectsEqual(
            normalizeItem(actualItem),
            normalizeItem(expectedItem),
            comparisonType
          )
        )
      );

    if (!isEqual) {
      console.log('Mismatch between actual output and expected output:', {
        actualOutputArray: output.map(normalizeItem),
        expectedOutputArray: expectedOutputArray.map(normalizeItem),
      });
    }

    return isEqual;
  } else {
    console.error('One or both arrays is undefined.');
    return false;
  }
}

module.exports = outputMatchesExampleOutput;
