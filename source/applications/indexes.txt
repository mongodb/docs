===================
Indexing Strategies
===================

.. default-domain:: mongodb

Synopsis
--------

This document provides practical approaches and strategies for indexing
in MongoDB. For the fundamentals of MongoDB indexing, see the
:doc:`/core/indexes` document. For operational guidelines and
procedures, see the :doc:`/administration/indexes` document.

Indexes allow MongoDB to process and fulfill queries quickly
by creating small and efficient representations of the documents in a
collection.

Strategies
----------

The best indexes for your application are based on a number of important
factors, including the kinds of queries you expect, the ratio of reads
to writes, and the amount of free memory on your system. The best
strategy for designing indexes is always to profile a variety of index
configurations with data sets similar to the ones you'll be running in
production and to see which configurations perform best. There's no substitute for good
empirical analyses.

.. _indexes-create-to-match-queries:

Create Indexes to Match Your Queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you query on a single key, a single-key index will do. For
example, assume you're searching for a blog post's slug:

.. code-block:: javascript

   db.posts.find({ slug : 'state-of-mongodb-2010' })

In this case, a unique index on a single key is best:

.. code-block:: javascript

   db.posts.ensureIndex({ slug: 1 }, {unique: true})

If you query on multiple keys, use a :ref:`compound index
<index-type-compound>`. With the exception of queries that use the
:operator:`$or` operator, a query cannot use multiple indexes. A query
must use only one index. Therefore, to query on multiple keys, use a
:ref:`compound index <index-type-compound>`.

If you query on multiple keys and sort the results, see :ref:`index-sort`.

.. _covered-queries:
.. _indexes-covered-queries:

Use Covered Queries
~~~~~~~~~~~~~~~~~~~

In some cases, MongoDB will be able to fulfill a query using *only*
the index, without needing to scan actual documents from the
database. To use a covered index you must:

- ensure that the index includes all of the fields in the result.

  This means that the :term:`projection`, must explicitly exclude the
  ``_id`` field from the result set, unless the index includes
  ``_id``.

- if any of the indexed fields in any of the documents in the
  collection includes an array, then the index becomes a
  :ref:`multi-key index <index-type-multikey>` index, and cannot
  support a covered query.

Use the :method:`explain() <cursor.explain()>` to test the query. If
MongoDB was able to use a covered index, then the value of the
``indexOnly`` field will be ``true``. For more information on
:method:`explain() <cursor.explain()>`, see
:ref:`indexes-measuring-use`.

Covered queries are much faster than other queries, for two reasons:
indexes are typically stored in RAM *or* located sequentially on
disk, and indexes are smaller than the documents they catalog.

.. _index-sort:
.. _sorting-with-indexes:

Sort Using Indexes
~~~~~~~~~~~~~~~~~~

While the :method:`sort() <cursor.sort()>` method supports in-memory
sort operations without the use of an index, these operations are:

#. Significantly slower than sort operations that use an index.

#. Abort when the sort operation consume 32 megabytes of memory.

For the best result, index the field you want sorted in your query
results. For example, if you have a ``{ username: 1 }`` index, you can
use this index to return documents sorted by the ``username`` field.

*MongoDB can return sorted results in either ascending or descending
order using an index in ascending or descending order,* because MongoDB
can transverse items in the index in both directions. For more
information about index order see :ref:`Ascending and Descending Index
Order <index-ascending-and-descending>`.

In general, MongoDB can use a :ref:`compound index
<index-type-compound>` to return sorted results *if*:

- The first sorted field is the first field in the index.

- The last field in the index before the first sorted field is an
  equality match in the query.

Consider the example below for an illustration of this concept.

.. example::

   Given the following index:

   .. code-block:: javascript

      { a: 1, b: 1, c: 1, d: 1 }

   The following query and sort operations will be able to use the
   index:

   .. code-block:: javascript

      db.collection.find().sort( { a:1 } )
      db.collection.find().sort( { a:1, b:1 } )

      db.collection.find( { a:4 } ).sort( { a:1, b:1 } )
      db.collection.find( { b:5 } ).sort( { a:1, b:1 } )

      db.collection.find( { a:{ $gt:4 } } ).sort( { a:1, b:1 } )

      db.collection.find( { a:5 } ).sort( { a:1, b:1 } )
      db.collection.find( { a:5 } ).sort( { b:1, c:1 } )

      db.collection.find( { a:5, c:4, b:3 } ).sort( { d:1 } )

      db.collection.find( { a:5, b:3, d:{ $gt:4 } } ).sort( { c:1 } )
      db.collection.find( { a:5, b:3, c:{ $lt:2 }, d:{ $gt:4 } } ).sort( { c:1 } )

   However, the following query operations would not be able to sort
   the results using the index:

   .. code-block:: javascript

      db.collection.find().sort( { b:1 } )
      db.collection.find( { b:5 } ).sort( { b:1 } )
      db.collection.find( { b:{ $gt:5 } } ).sort( { a:1, b:1 } )

.. _indexes-ensure-indexes-fit-ram:

Ensure Indexes Fit RAM
~~~~~~~~~~~~~~~~~~~~~~

For best results, always ensure that your indexes fit entirely in RAM,
so the system doesn't need to read the index from disk to fulfill a
query. If your indexes approach or exceed the total size of available
RAM, they may not fit in memory.

You can check the size of your indexes in the :program:`mongo` shell,
using the :method:`db.collection.totalIndexSize()` helper. You may also
use :dbcommand:`collStats` or :method:`db.collection.stats()` to return
this and :doc:`related information </reference/collection-statistics>`.

:method:`db.collection.totalIndexSize()` returns data in bytes. Consider
the following invocation:

.. code-block:: javascript

   > db.collection.totalIndexSize()
   4294976499

This reports a total index size of roughly 4 gigabytes. Consider this
value in contrast to the total amount of available system RAM and the
rest of the :term:`working set`. Also remember:

- if you have and use multiple collections to consider the size of
  all indexes on all collections.

- there are some :ref:`limited cases where indexes do not need to fit
  in RAM <indexing-right-handed>`.

Considerations
--------------

Above all, when developing your indexing strategy you should have a
deep understanding of:

- The application's queries.

- The relative frequency of each query in the application.

- The current indexes created for your collections.

- Which indexes the most common queries use.

MongoDB can only use *one* index to support any given
operation. However, each clause of an :operator:`$or` query can use
its own index.

.. _index-selectivity:

Selectivity
~~~~~~~~~~~

Selectivity describes the ability of a query to narrow the result set
using the index. Effective indexes are more selective and allow
MongoDB to use the index for a larger portion of the work associated
with fulfilling the query. There are two aspects of selectivity:

#. Data need to have a high distribution of the values for the indexed
   key.

#. Queries need to limit the number of possible documents using the
   indexed field.

.. example::

   First, consider an index, ``{ a : 1 }``, on a collection where
   ``a`` has three values evenly distributed across the collection:

   .. code-block:: javascript

      { _id: ObjectId(), a: 1, b: "ab" }
      { _id: ObjectId(), a: 1, b: "cd" }
      { _id: ObjectId(), a: 1, b: "ef" }
      { _id: ObjectId(), a: 2, b: "jk" }
      { _id: ObjectId(), a: 2, b: "lm" }
      { _id: ObjectId(), a: 2, b: "no" }
      { _id: ObjectId(), a: 3, b: "pq" }
      { _id: ObjectId(), a: 3, b: "rs" }
      { _id: ObjectId(), a: 3, b: "tv" }

   If you do a query for ``{ a: 2, b: "no" }`` MongoDB will still need
   to scan 3 documents of the :term:`documents <document>` in the
   collection to fulfill the query. Similarly, a query for ``{ a: {
   $gt: 1}, b: "tv" }``, would need to scan through 6 documents,
   although both queries would return the same result.

   Then, consider an index on a field that has many values evenly
   distributed across the collection:

   .. code-block:: javascript

      { _id: ObjectId(), a: 1, b: "ab" }
      { _id: ObjectId(), a: 2, b: "cd" }
      { _id: ObjectId(), a: 3, b: "ef" }
      { _id: ObjectId(), a: 4, b: "jk" }
      { _id: ObjectId(), a: 5, b: "lm" }
      { _id: ObjectId(), a: 6, b: "no" }
      { _id: ObjectId(), a: 7, b: "pq" }
      { _id: ObjectId(), a: 8, b: "rs" }
      { _id: ObjectId(), a: 9, b: "tv" }

   Although the index on ``a`` is more selective, in the sense that
   queries can use the index more effectively, a query such as ``{ a:
   { $gt: 5 }, b: "tv" }`` would still need to scan 4 documents. By
   contrast, given a query like ``{ a: 2, b: "cd" }``, MongoDB would
   only need to scan one document to fulfill the rest of the
   query. The index and query are more selective because the values of
   ``a`` are evenly distributed *and* the query can selects a specific
   document using the index.

.. example::

   Avoid single-key indexes with low selectivity. Suppose you have a
   field called ``status`` where the possible values are ``new`` and
   ``processed``. If you add an index on ``status`` you've created a
   low-selectivity index, meaning that the index will be of little help
   in locating records and will be just taking up space.

   A better strategy, depending on your queries, would be to create a
   :ref:`compound index <index-type-compound>` that includes the
   low-selectivity field. For instance, you could have a compound index
   on ``status`` and ``created_at.``

   Another option, again depending on your use case, might be to use
   separate collections, one for each status. Experimentation and
   benchmarks will help you choose the best approach.

To ensure optimal performance, use indexes that are maximally
selective relative to your queries. At the same time queries need to
be appropriately selective relative to your indexed data. If overall
selectivity is low enough, and MongoDB must read a number of documents
to return results, then some queries may perform faster without
indexes. See the :ref:`indexes-measuring-use` section for more
information on testing information.

Write-heavy Applications
~~~~~~~~~~~~~~~~~~~~~~~~

If your application is write-heavy, then be careful when creating new
indexes, since each additional index with impose a small
write-performance penalty. In general, don't be careless about adding
indexes. Indexes should be added to complement your queries. Always have
a good reason for adding a new index, and make sure you've benchmarked
alternative strategies.

Insert Throughput
~~~~~~~~~~~~~~~~~

.. TODO insert link to /source/core/write-operations when that page is complete.

MongoDB must update all indexes associated with a collection after
every insert, update, or delete operation.

Every index on a collection adds
some amount of overhead to these operations. In almost every case, the
performance gains that indexes realize for read operations are worth
the insertion penalty; however:

- In some cases, an index to support an infrequent query may incur
  more insert-related costs than saved read-time.

- In some situations, if you have many indexes on a collection with a
  high insert throughput and a number of very similar indexes, you may
  find better overall results by using a slightly less effective index
  on some queries if it means consolidating the total number of
  indexes.

- If your indexes and queries are not very selective, the speed
  improvements for query operations may not offset the costs of
  maintaining an index. See the section on :ref:`index selectivity
  <index-selectivity>` for more information.

- In some cases a single compound on two or more fields index may
  support all of the queries that index on a single field index, or a
  smaller :ref:`compound index <index-type-compound>`. In general,
  MongoDB can use compound index
  to support the same queries as any of its prefixes. Consider the
  following example:

  .. example::

     Given the following index on a collection:

     .. code-block:: javascript

        { x: 1, y: 1, z: 1 }

     Can support a number of queries as well as most of the queries
     that the following indexes support:

     .. code-block:: javascript

        { x: 1 }
        { x: 1, y: 1 }

     There are some situations where the prefix indexes may offer
     better query performance as is the case if ``z`` is a large
     array. Also, consider the following index on the same collection:

     .. code-block:: javascript

        { x: 1, z: 1 }

     The ``{ x: 1, y: 1, z: 1 }`` index can support many of the same
     queries as the above index; however, ``{ x: 1, z: 1 }`` has
     additional use: Given the following query:

     .. code-block:: javascript

        db.collection.find( { x: 5 } ).sort( { z: 1} )

     The ``{ x: 1, z: 1 }`` will support both the query and the sort
     operation, while the ``{ x: 1, y: 1, z: 1 }`` index can only
     support the query.

     See the :ref:`sorting-with-indexes` section for more
     information.

Index Size
~~~~~~~~~~

Indexes require space, both on disk and in RAM. Indexes require less
space in RAM than the full documents in the collection. In theory, if
your queries only match a subset of the documents and can use the
index to locate those documents, MongoDB can maintain a much smaller
:term:`working set`. Ensure that:

- the indexes and the working set can fit RAM at the same time.

- all of your indexes use less space than all of the documents in the
  collection. This may not be an issue all of your queries use
  :ref:`covered queries <covered-queries>` or indexes do not need to
  fit into ram, as in the following situation:

.. _indexing-right-handed:

Indexes do not have to fit *entirely* into RAM in all cases. If the
value of the indexed field grows with every insert, and most queries
select recently added documents; then MongoDB only needs to keep the
parts of the index that hold the most recent or "right-most" values in
RAM. This allows for efficient index use for read and write
operations and minimize the amount of RAM required to support the
index.

.. To determine the size of the index, see DOCS-224
