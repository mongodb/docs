{
  "content": "> As of June 2022, the functionality previously known as MongoDB Realm is now named [Atlas App Services](https://www.mongodb.com/docs/atlas/app-services/). Atlas App Services refers to the cloud services that simplify building applications with Atlas â€“ Atlas Data API, Atlas GraphQL API, Atlas Triggers, and Atlas Device Sync. [Realm](https://www.mongodb.com/docs/realm/) will continue to be used to refer to the client-side database and SDKs.\\n\\nBuilding [Continuous Integration/Continuous Deployment (CI/CD)](https://en.wikipedia.org/wiki/CI/CD) pipelines can be challenging. You have to map your team's ideal pipeline, identify and fix any gaps in your team's test automation, and then actually build the pipeline. Once you put in the work to craft a pipeline, you'll reap a variety of benefits like...\\n\\n* Faster releases, which means you can get value to your end users quicker)\\n* Smaller releases, which can you help you find bugs faster\\n* Fewer manual tasks, which can reduce manual errors in things like testing and deployment.\\n\\nAs Tom Haverford from the incredible TV show Parks and Recreation wisely said, \\\"Sometimes you gotta **work a little**, so you can **ball a lot**.\\\" (View the entire scene [here](https://www.youtube.com/watch?v=BcJaSl2UZcw&t=194s). But don't get too sucked into the silliness that you forget to return to this article ðŸ˜‰.)\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/ballalot_1bbe08b37d.gif\\\" width=\\\"400\\\" alt=\\\"Screen recording of user adding an item to the inventory in the Inventory App\\\" align=\\\"center\\\"/>\\n</div>\\n\\n\\nIn this article, I'll walk you through how I crafted a CI/CD pipeline for a mobile app built with MongoDB Realm. I'll provide strategies as well as code you can reuse and modify, so you can put in just **a little bit of work** to craft a pipeline for your app and **ball a lot**.\\n\\nThis article covers the following topics:\\n\\n- [All About the Inventory App](#all-about-the-inventory-app)\\n   - [What the App Does](#what-the-app-does)\\n   - [The System Architecture](#the-system-architecture)\\n- [All About the Pipeline](#all-about-the-pipeline)\\n    - [Pipeline Implementation Using GitHub Actions](#pipeline-implementation-using-github-actions)\\n    - [MongoDB Atlas Project Configuration](#mongodb-atlas-project-configuration)\\n    - [What Happens in Each Stage of the Pipeline](#what-happens-in-each-stage-of-the-pipeline)\\n- [Building Your Pipeline](#building-your-pipeline)\\n   - [Map Your Pipeline](#map-your-pipeline)\\n   - [Implement Your Pipeline](#implement-your-pipeline)\\n- [Summary](#summary) \\n\\n> More of a video person? No worries. Check out the recording below of a talk I gave at MongoDB.live 2021 that covers the exact same content this article does. :youtube[]{vid=-JcEa1snwVQ}\\n\\n## All About the Inventory App\\n\\nI recently created a CI/CD pipeline for an iOS app that manages stores' inventories. In this section, I'll walk you through what the app does and how it was architected. This information will help you understand why I built my CI/CD pipeline the way that I did.\\n\\n### What the App Does\\n\\nThe Inventory App is a fairly simple iOS app that allows users to manage the online record of their physical stores' inventories. The app allows users to take the following actions:\\n\\n* Create an account\\n* Login and logout\\n* Add an item to the inventory\\n* Adjust item quantities and prices\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/completedemo_small_fee3ae5aa6.gif\\\" width=\\\"400\\\" alt=\\\"Screen recording of a user interacting with the Inventory App to login, add an item named 'Concealer' to the inventory, adjust item quantities, and logout\\\" style=\\\"text-align: center;\\\"/>\\n</div>\\n\\nIf you'd like to try the app for yourself, you can get a copy of the code in the GitHub repo: [mongodb-developer/realm-demos](https://github.com/mongodb-developer/realm-demos).\\n\\n### The System Architecture\\n\\nThe system has three major components:\\n\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/general_objects_mobile_4x_6fe67c6c8c.png\\\" width=\\\"30\\\" alt=\\\"Mobile device icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/> **The Inventory App** is the iOS app that will be installed on the mobile device. The local Realm database is embedded in the Inventory App and stores a local copy of the inventory data.\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Realm_Icon_2x_9bef9956b3.png\\\" width=\\\"30\\\" alt=\\\"Realm icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/>**The Realm App** is the central MongoDB Realm backend instance of the mobile application. In this case, the Realm App utilizes Realm features like [authentication](https://docs.mongodb.com/realm/authentication/), [rules](https://docs.mongodb.com/realm/mongodb/), [schema](https://docs.mongodb.com/realm/mongodb/document-schemas/), [GraphQL API](https://docs.mongodb.com/realm/graphql/), and [Sync](https://docs.mongodb.com/realm/sync/). The Inventory App is connected to the Realm App. **Note**: The Inventory App and the Realm App are NOT the same thing; they have two different code bases.\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/mongodb_atlas_cluster_4x_ce6d233ecb.png\\\" width=\\\"30\\\" alt=\\\"Atlas database icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/> **The Atlas Database** stores the inventory data. [Atlas](https://cloud.mongodb.com/) is MongoDB's fully managed Database-as-a-Service. Realm Sync handles keeping the data synced between Atlas and the mobile apps.\\n\\n![Diagram showing how the Mobile App syncs with the Atlas database using Realm Sync](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_14_at_7_50_18_AM_09bb66451d.png)\\n\\nAs you're building a CI/CD pipeline for a mobile app with an associated Realm App and Atlas database, you'll need to take into consideration how you're going to build and deploy both the mobile app and the Realm App. You'll also need to figure out how you're going to indicate which database the Realm App should be syncing to. Don't worry, I'll share strategies for how to do all of this in the sections below.\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/bored_5c6b8e36c1.gif\\\" width=\\\"400\\\" alt=\\\"I've never been more bored in my entire life\\\"/>\\n</div>\\n\\nOkay, that's enough boring stuff. Let's get to my favorite part: the CI/CD pipeline!\\n\\n## All About the Pipeline\\n\\nNow that you know what the Inventory App does and how it was architected, let's dive into the details of the CI/CD pipeline for this app. You can use this pipeline as a basis for your pipeline and tweak it to fit your team's process.\\n\\nMy pipeline has three main stages:\\n\\n* **Development**: In the Development Stage, developers do their development work like creating new features and fixing bugs.\\n* **Staging**: In the Staging Stage, the team simulates the production environment to make sure everything works together as intended. The Staging Stage could also be known as QA (Quality Assurance), Testing, or Pre-Production.\\n* **Production**: The Production Stage is the final stage where the end users have access to your apps.\\n\\n![Diagram showing the three stages of the pipeline: Development, Staging, and Production](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_14_at_7_53_34_AM_5062cea6d6.png)\\n\\n### Pipeline Implementation Using GitHub Actions\\n\\nA variety of tools exist to help teams implement CI/CD pipelines. I chose to use [GitHub Actions](https://github.com/features/actions), because it works well with GitHub (which is where my code is already) and it has a free plan for public repositories (and I like free things!). GitHub Actions allows you to automate [workflows](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#workflows). As you'll see in later sections, I implemented my CI/CD pipeline using a workflow. Each workflow can contain one or more [jobs](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#jobs), and each job contains one or more [steps](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#steps).\\n\\nThe complete workflow is available in [build.yml](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/build.yml) in the [Inventory App's GitHub repository](https://github.com/mongodb-developer/realm-demos).\\n\\n### MongoDB Atlas Project Configuration\\n\\nThroughout the pipeline, the workflow will deploy to new or existing Realm Apps that are associated with new or existing databases based on the pipeline stage. I decided to create four Atlas projects to support my pipeline:\\n* **Inventory Demo - Feature Development.** This project contains the Realm Apps associated with every new feature. Each Realm App syncs with a database that has a custom name based on the feature (for example,Â a feature branch named `beta6-improvements` would have a database named `InventoryDemo-beta6-improvements`). All of the databases for feature branches are stored in this project's Atlas cluster. The Realm Apps and databases for feature branches are deleted after the feature work is completed.\\n* **Inventory Demo - Pull Requests.**Â This project contains the Realm Apps that are created for every pull request. Each Realm App syncs with a database that has a custom name based on the time the workflow runs (for example,Â `InventoryDemo-2021-06-07_1623089424`). All of the databases associated with pull requests are stored in this project's Atlas cluster.Â  \\n\\n   As part of my pipeline, I chose to delete the Realm App and associated database at the end of the workflow that was triggered by the pull request.Â Another option would be to skip deleting the Realm App and associated database when the tests in the workflow fail, so that a developer could manually investigate the source of the failure.\\n* **Inventory Demo - Staging.** This project contains the Realm App for Staging. The Realm App syncs with a database used only for Staging.Â The Staging database is the only database in this project's cluster. The Realm App and database are never deleted, so the team can always look in the same consistent locations for the Staging app and its data.\\n* **Inventory Demo - Production.**Â This project contains the Realm App for Production.Â The Realm App syncs with a database used only for Production.Â The Production database is the only database in this project's cluster.Â The Realm App and database are never deleted.\\n\\nNote: This app requires only a single database. If your app uses more than one database, the principles described above would still hold true.\\n\\n### What Happens in Each Stage of the Pipeline\\n\\nI've been assigned a ticket to change the color of the **Log In** button in the iOS app from blue to pink. In the following sections, I'll walk you through what happens in each stage of the pipeline and how my code change is moved from one stage to the next.\\n\\nAll of the stages and transitions below use the same GitHub Actions workflow. The workflow has conditions that modify which steps are taken. I'll walk you through what steps are run in each workflow execution in the sections below. The workflow uses [environment variables](https://docs.github.com/en/actions/reference/environment-variables) and [secrets](https://docs.github.com/en/actions/reference/encrypted-secrets) to store values. Visit the [realm-demos GitHub repo](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/build.yml) to see the complete workflow source code.\\n\\n#### Development\\n\\nThe Development stage is where I'll do my work to update the button color. In the subsections below, I'll walk you through how I do my work and trigger a workflow.\\n\\n##### Updating the Inventory App\\n\\nSince I want to update my iOS app code, I'll begin by opening a copy of my app's code in [Xcode](https://developer.apple.com/xcode/). I'll change the color of the **Log In** button there. I'm a good developer ðŸ˜‰, so I'll run the automated tests to make sure I didn't break anything. The Inventory App has automated unit and UI tests that were implemented using [XCTest](https://developer.apple.com/documentation/xctest). I'll also kick off a simulator, so I can manually test that the new button color looks fabulous.\\n\\n![Updating the button color in Xcode](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_52_51_PM_231b26e4c2.png \\\"Updating the button color in Xcode\\\")\\n\\n##### Updating the Realm App\\n\\nIf I wanted to make an update to the Realm App code, I could either:\\n\\n* work in the cloud in the Realm web interface or\\n* work locally in a code editor like Visual Studio Code.\\n\\nIf I choose to work in the Realm web interface, I can make changes and deploy them. The Realm web interface was recently updated to allow developers to commit changes they make there to their GitHub repositories. This means changes made in the web interface won't get lost when changes are deployed through other methods (like through the Realm Command Line Interface or automated GitHub deployments).\\n\\n![Updating the Realm App code in the Realm web interface](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_2_00_42_PM_e78f5d2efc.png \\\"Updating the Realm App code in the Realm web interface\\\")\\n\\nIf I choose to work with my Realm App code locally, I could make my code changes and then run unit tests. If I want to run integration tests or do some manual testing, I need to deploy the Realm App. One option is to use the [Realm Command Line Interface](https://docs.mongodb.com/realm/deploy/realm-cli-reference/#realm-cli) (Realm CLI) to deploy with a command like [`realm-cli push`](https://docs.mongodb.com/realm/deploy/deploy-cli/#deploy-the-updated-app). Another option is to automate the deployment using a GitHub Actions workflow.\\n\\n![Updating the Realm App code locally in Visual Studio Code](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_52_32_PM_d331a77e6e.png \\\"Updating the Realm App code locally in Visual Studio Code\\\")\\n\\nI've chosen to automate the deployment using a GitHub Actions workflow, which I'll describe in the following section.\\n\\n##### Kicking Off the Workflow\\n\\nAs I am working locally to make changes to both the Inventory App and the Realm App, I can commit the changes to a new [feature branch](https://martinfowler.com/bliki/FeatureBranch.html) in my GitHub repository.\\n\\nWhen I am ready to deploy my Realm App and run all of my automated tests, I will push the commits to my repository. The push will trigger the workflow. \\n\\n![Screenshot of the GitHub Actions web interface after a push to a feature branch triggers a workflow](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_55_38_PM_9499d4483d.png \\\"The workflow is in progress after a push to a feature branch\\\")\\n\\nThe workflow runs the [`build`](https://github.com/mongodb-developer/realm-demos/blob/5c3a1d3554527fe9fb2602dcbc84e2cc4d39acac/.github/workflows/build.yml#L6) job, which runs the following steps:\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out the repository so the workflow can access the code.\\n3. <a name=\\\"store-current-time\\\">**Store current time in variable.** Stores the current time in an environment variable named `CURRENT_TIME`. This variable is used later in the workflow.</a>\\n\\n    ```\\n    echo \\\"CURRENT_TIME=$(date +'%Y-%m-%d_%s')\\\" >> $GITHUB_ENV\\n    ```\\n\\n4. **Is this a push to a feature branch?** If this is a push to a feature branch (which it is), do the following:\\n    * Create a new environment variable to store the name of the feature branch.\\n       ```\\n       ref=$(echo ${{ github.ref }})\\n       branch=$(echo \\\"${ref##*/}\\\")\\n       echo \\\"FEATURE_BRANCH=$branch\\\" >> $GITHUB_ENV\\n       ```\\n    * Check the `GitHubActionsMetadata` Atlas database to see if a Realm App already exists for this feature branch. If a Realm App exists, store the Realm App ID in an environment variable. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n       ```\\n       output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.findOne({'branch': '$branch'})\\\")\\n        \\n       if [[ $output == *null ]]; then\\n           echo \\\"No Realm App found for this branch. A new app will be pushed later in this workflow\\\"\\n       else\\n           echo \\\"A Realm App was found for this branch. Updates will be pushed to the existing app later in this workflow\\\"\\n           app_id=$(echo $output | sed 's/^.*realm_app_id\\\" : \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n           echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n       fi\\n       ```\\n\\n    * Update the `databaseName` in the `development.json` [environment file](https://docs.mongodb.com/realm/config/environments/). Set the database name to contain the branch name to ensure it's unique.\\n\\n      ```\\n      cd inventory/export/sync/environments\\n      printf '{\\\\n     \\\"values\\\": {\\\"databaseName\\\": \\\"InventoryDemo-%s\\\"}\\\\n}' \\\"$branch\\\" > development.json \\n       ```\\n    * Indicate that the Realm App should use the `development` [environment](https://docs.mongodb.com/realm/values-and-secrets/define-environment-values/) by updating `realm_config.json`.\\n       ```\\n       cd ..\\n       sed -i txt 's/{/{ \\\"environment\\\": \\\"development\\\",/' realm_config.json\\n       ```\\n\\n5. <a name=\\\"install-realm-cli\\\">**Install the Realm CLI and authenticate.**</a>  This step installs the Realm CLI and authenticates using the API keys that are stored as GitHub secrets.\\n   ```\\n   npm install -g mongodb-realm-cli@beta\\n   realm-cli login --api-key=\\\"${{ secrets.REALM_API_PUBLIC_KEY }}\\\" --private-api-key=\\\"${{ secrets.REALM_API_PRIVATE_KEY }}\\\" --realm-url https://realm.mongodb.com --atlas-url https://cloud.mongodb.com\\n   ```\\n6. **Create a new Realm App for feature branches where the Realm App does not yet exist.** This step has three primary pieces:\\n   * Push the Realm App to the Atlas project specifically for feature branches.\\n      ```\\n      cd inventory/export/sync\\n      realm-cli push -y --project 609ea554944fe545460529a1\\n       ```\\n   * Retrieve and store the Realm App ID from the output of `realm-cli app describe`.\\n      ```\\n      output=$(realm-cli app describe)\\n      app_id=$(echo $output | sed 's/^.*client_app_id\\\": \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n      echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n      ```\\n   * Store the Realm App ID in the GitHubActionsMetadata database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n      ```\\n      mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.insertOne({'branch': '${{ env.FEATURE_BRANCH}}', 'realm_app_id': '$app_id'})\\\"\\n      ```\\n7. <a name=\\\"create-realm-app-id-txt\\\">**Create `realm-app-id.txt` that stores the Realm App ID.** This file will be stored in the mobile app code. The sole purpose of this file is to tell the mobile app to which Realm App it should connect.</a>\\n   ```\\n   echo \\\"${{ env.REALM_APP_ID }}\\\" > $PWD/inventory/clients/ios-swiftui/InventoryDemo/realm-app-id.txt\\n   ```\\n8. <a name=\\\"build-mobile-app\\\">**Build mobile app and run tests.** This step builds the mobile app for testing and then runs the tests using a variety of simulators. If you have integration tests, you could also choose to checkout previous releases of the mobile app and run the integration tests against the current version of the Realm App to ensure backwards compatibility.</a>\\n   * Navigate to the mobile app's directory.\\n      ```\\n      cd inventory/clients/ios-swiftui/InventoryDemo\\n      ```\\n   * Build the mobile app for testing.\\n      ```\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 12 Pro Max,OS=14.4' -derivedDataPath './output' build-for-testing\\n      ```\\n   * Define the simulators that will be used for testing.\\n      ```\\n      iPhone12Pro='platform=iOS Simulator,name=iPhone 12 Pro Max,OS=14.4'\\n      iPhone12='platform=iOS Simulator,name=iPhone 12,OS=14.4'\\n      iPadPro4='platform=iOS Simulator,name=iPad Pro (12.9-inch) (4th generation)'\\n      ```   \\n   * Run the tests on a variety of simulators. Optionally, you could put these in separate jobs to run in parallel.\\n      ```\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPhone12Pro\\\" -derivedDataPath './output' test-without-building\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPhone12\\\" -derivedDataPath './output' test-without-building     \\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPadPro4\\\" -derivedDataPath './output' test-without-building\\n        ```\\n9. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n10. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nThe nice thing here is that simply by pushing my code changes to my feature branch, my Realm App is deployed and the tests are run. When I am finished making updates to the code, I can feel confident that a Staging build will be successful.\\n\\n#### Moving from Development to Staging\\n\\nNow that I'm done working on my code changes, I'm ready to move to Staging. I can kick off this process by creating a [GitHub pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). In the pull request, I'll request to merge my code from my feature branch to the `staging` branch. When I submit the pull request, GitHub will automatically kick off another workflow for me. \\n\\n![Screenshot of a pull request](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/pull_request_dbe365f655.png \\\"The pull request shows that a workflow is in progress\\\")\\n\\nThe workflow runs the following steps.\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out the repository so the workflow can access the code.\\n3. **Store current time in variable.** See the [section above](#store-current-time) for more information on this step.\\n4. **Set environment variables for all other runs.** This step sets the necessary environment variables for pull requests where a new Realm App and database will be created for *each* pull request. This step has three primary pieces.\\n    * Create a new environment variable named `IS_DYNAMICALLY_GENERATED_APP` to indicate this is a dynamically generated app that should be deleted later in this workflow.\\n       ```\\n       echo \\\"IS_DYNAMICALLY_GENERATED_APP=true\\\" >> $GITHUB_ENV\\n       ```\\n    * Update the `databaseName` in the `testing.json` [environment file](https://docs.mongodb.com/realm/config/environments/). Set the database name to contain the current time to ensure it's unique.\\n       ```\\n       cd inventory/export/sync/environments\\n       printf '{\\\\n     \\\"values\\\": {\\\"databaseName\\\": \\\"InventoryDemo-%s\\\"}\\\\n}' \\\"${{ env.CURRENT_TIME }}\\\" > testing.json  \\n       ```\\n   * Indicate that the Realm App should use the `testing` [environment](https://docs.mongodb.com/realm/values-and-secrets/define-environment-values/) by updating `realm_config.json`.\\n      ```\\n      cd ..\\n      sed -i txt 's/{/{ \\\"environment\\\": \\\"testing\\\",/' realm_config.json \\n      ```\\n5. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n6. **Create a new Realm App for pull requests.** Since this is a pull request, the workflow creates a new Realm App just for this workflow. The Realm App will be deleted at the end of the workflow.\\n    * Push to the Atlas project specifically for pull requests.\\n       ```\\n       cd inventory/export/sync\\n       realm-cli push -y --project 609ea554944fe545460529a1\\n        ```\\n    * Retrieve and store the Realm App ID from the output of `realm-cli app describe`.\\n       ```\\n       output=$(realm-cli app describe)\\n       app_id=$(echo $output | sed 's/^.*client_app_id\\\": \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n       echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n        ```\\n    * Store the Realm App ID in the `GitHubActionsMetadata` database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n       ```\\n       mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.insertOne({'branch': '${{ env.FEATURE_BRANCH}}', 'realm_app_id': '$app_id'})\\\"\\n       ```\\n7. **Create `realm-app-id.txt` that stores the Realm App ID.** See the [section above](#create-realm-app-id-txt) for more information on this step.\\n8. **Build mobile app and run tests.** See the [section above](#build-mobile-app) for more information on this step.\\n9. **Delete dynamically generated Realm App.** The workflow created a Realm App just for this pull request in an earlier step. This step deletes that Realm App.\\n   ```\\n   realm-cli app delete --app ${{ env.REALM_APP_ID }}\\n   ```\\n10. **Delete dynamically generated database.** The workflow also created a database just for this pull request in an earlier step. This step deletes that database.\\n    ```\\n    mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_PULL_REQUESTS }}/InventoryDemo-${{ env.CURRENT_TIME }}\\\" --username ${{ secrets.ATLAS_USERNAME_PULL_REQUESTS }} --password ${{ secrets.ATLAS_PASSWORD_PULL_REQUESTS }} --eval \\\"db.dropDatabase()\\\"\\n    ```\\n11. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n12. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nThe results of the workflow are included in the pull request.\\n\\n![\\\"Screenshot of the workflow results in the pull request](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/prcheckspassed_a67dde1eaa.png \\\"The pull request shows that all workflows completed successfully\\\")\\n\\nMy teammate will review the pull request. They will likely review the code and double check that the workflow passed. We might go back and forth with suggestions and updates until we both agree the code is ready to be merged into the `staging` branch.\\n\\nWhen the code is ready, my teammate will approve the pull request and then click the button to squash and merge the commits. My teammate may also choose to delete the branch as it is no longer needed. \\n\\n![Screenshot of the option to delete the branch](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/deletebranch_ff52d9ee1c.png \\\"My teammate can delete the branch with the click of a button in the pull request\\\")\\n\\nDeleting the branch triggers the `delete-feature-branch-artifacts` workflow. This workflow is different from all of the workflows I will discuss in this article. This workflow's job is to delete the artifacts that were associated with the branch. \\n\\n![Screenshot of the GitHub Actions web interface after deleting a branch triggers a workflow](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/deletebuild_474562b75d.png \\\"The workflow to delete the feature branch artifacts is in progress\\\")\\n\\nThe [`delete-feature-branch-artifacts`](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/delete-feature-branch-artifacts.yml) workflow runs the following steps.\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n3. **Store the name of the branch.** This step retrieves the name of the branch that was just deleted and stores it in an environment variable named `FEATURE_BRANCH`.\\n   ```\\n   ref=$(echo ${{ github.event.ref }})\\n   branch=$(echo \\\"${ref##*/}\\\")\\n   echo \\\"FEATURE_BRANCH=$branch\\\" >> $GITHUB_ENV\\n   ```\\n\\n4. **Delete the Realm App associated with the branch.** This step queries the `GitHubActionsMetadata` database for the ID of the Realm App associated with this branch. Then it deletes the Realm App, and deletes the information in the `GitHubActionsMetadata` database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n\\n   ```\\n   # Get the Realm App associated with this branch\\n   output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.findOne({'branch': '${{ env.FEATURE_BRANCH }}'})\\\")\\n   \\n   if [[ $output == *null ]]; then\\n       echo \\\"No Realm App found for this branch\\\"\\n   else\\n       # Parse the output to retrieve the realm_app_id\\n       app_id=$(echo $output | sed 's/^.*realm_app_id\\\" : \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n              \\n       # Delete the Realm App\\n       echo \\\"A Realm App was found for this branch: $app_id. It will now be deleted\\\"\\n       realm-cli app delete --app $app_id\\n        \\n       # Delete the record in the GitHubActionsMetadata database\\n       output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.deleteOne({'branch': '${{ env.FEATURE_BRANCH }}'})\\\")\\n   fi\\n   ```\\n\\n5. **Delete the database associated with the branch.** This step deletes the database associated with the branch that was just deleted.\\n\\n   ```\\n   mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/InventoryDemo-${{ env.FEATURE_BRANCH }}\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.dropDatabase()\\\"\\n   ```\\n\\n6. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\n#### Staging\\n\\nAs part of the pull request process, my teammate merged my code change into the `staging` branch. I call this stage \\\"Staging,\\\" but teams have a variety of names for this stage. They might call it \\\"QA (Quality Assurance),\\\" \\\"Testing,\\\" \\\"Pre-Production,\\\" or scom/actions/checkout) to check out the repository so the workflow can access the code.\\n3. **Store current time in variable.** See the [section above](#store-current-time) for more information on this step.\\n4. **Is this a push to the Staging branch?** This step checks if the workflow was triggered by a push to the `staging` branch. If so, it stores the ID of the Staging Realm App in the `REALM_APP_ID` environment variable.\\n   ```\\n   echo \\\"REALM_APP_ID=inventorydemo-staging-zahjj\\\" >> $GITHUB_ENV\\n   ```\\n\\n5. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n6. <a name=\\\"push-updated-copy\\\">**Push updated copy of the Realm App for existing apps (Main, Staging, or Feature branches).** This step pushes an updated copy of the Realm App (stored in `inventory/export/sync`) for cases when the Realm App already exists.</a>\\n   ```\\n   cd inventory/export/sync\\n   realm-cli push --remote=\\\"${{ env.REALM_APP_ID }}\\\" -y\\n   ```\\n7. **Create `realm-app-id.txt` that stores the Realm App ID.** See the [section above](#create-realm-app-id-txt) for more information on this step.\\n8. **Build mobile app and run tests.** See the [section above](#build-mobile-app) for more information on this step.\\n9. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n10. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nRealm has a new feature releasing soon that will allow you to roll back deployments. When this feature releases, I plan to add a step to the workflow above to automatically roll back the deployment to the previous one in the event of test failures.\\n\\n#### Moving from Staging to Production\\n\\nAt this point, some teams may choose to have their pipeline automation stop before automatically moving to production. They may want to run manual tests. Or they may want to intentionally limit their number of releases.\\n\\nI've chosen to move forward with continuous deployment in my pipeline. So, if the tests in Staging pass, the workflow above continues on to the [`pushToMainBranch`](https://github.com/mongodb-developer/realm-demos/blob/5c3a1d3554527fe9fb2602dcbc84e2cc4d39acac/.github/workflows/build.yml#L238) job that automatically pushes the latest commits to the `main` branch. The job runs the following steps:\\n\\n1. **Set up job.** This step is created by GitHub Act> JSON.stringify(\"> As of June 2022, the functionality previously known as MongoDB Realm is now named [Atlas App Services](https://www.mongodb.com/docs/atlas/app-services/). Atlas App Services refers to the cloud services that simplify building applications with Atlas â€“ Atlas Data API, Atlas GraphQL API, Atlas Triggers, and Atlas Device Sync. [Realm](https://www.mongodb.com/docs/realm/) will continue to be used to refer to the client-side database and SDKs.\\n\\nBuilding [Continuous Integration/Continuous Deployment (CI/CD)](https://en.wikipedia.org/wiki/CI/CD) pipelines can be challenging. You have to map your team's ideal pipeline, identify and fix any gaps in your team's test automation, and then actually build the pipeline. Once you put in the work to craft a pipeline, you'll reap a variety of benefits like...\\n\\n* Faster releases, which means you can get value to your end users quicker)\\n* Smaller releases, which can you help you find bugs faster\\n* Fewer manual tasks, which can reduce manual errors in things like testing and deployment.\\n\\nAs Tom Haverford from the incredible TV show Parks and Recreation wisely said, \\\"Sometimes you gotta **work a little**, so you can **ball a lot**.\\\" (View the entire scene [here](https://www.youtube.com/watch?v=BcJaSl2UZcw&t=194s). But don't get too sucked into the silliness that you forget to return to this article ðŸ˜‰.)\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/ballalot_1bbe08b37d.gif\\\" width=\\\"400\\\" alt=\\\"Screen recording of user adding an item to the inventory in the Inventory App\\\" align=\\\"center\\\"/>\\n</div>\\n\\n\\nIn this article, I'll walk you through how I crafted a CI/CD pipeline for a mobile app built with MongoDB Realm. I'll provide strategies as well as code you can reuse and modify, so you can put in just **a little bit of work** to craft a pipeline for your app and **ball a lot**.\\n\\nThis article covers the following topics:\\n\\n- [All About the Inventory App](#all-about-the-inventory-app)\\n   - [What the App Does](#what-the-app-does)\\n   - [The System Architecture](#the-system-architecture)\\n- [All About the Pipeline](#all-about-the-pipeline)\\n    - [Pipeline Implementation Using GitHub Actions](#pipeline-implementation-using-github-actions)\\n    - [MongoDB Atlas Project Configuration](#mongodb-atlas-project-configuration)\\n    - [What Happens in Each Stage of the Pipeline](#what-happens-in-each-stage-of-the-pipeline)\\n- [Building Your Pipeline](#building-your-pipeline)\\n   - [Map Your Pipeline](#map-your-pipeline)\\n   - [Implement Your Pipeline](#implement-your-pipeline)\\n- [Summary](#summary) \\n\\n> More of a video person? No worries. Check out the recording below of a talk I gave at MongoDB.live 2021 that covers the exact same content this article does. :youtube[]{vid=-JcEa1snwVQ}\\n\\n## All About the Inventory App\\n\\nI recently created a CI/CD pipeline for an iOS app that manages stores' inventories. In this section, I'll walk you through what the app does and how it was architected. This information will help you understand why I built my CI/CD pipeline the way that I did.\\n\\n### What the App Does\\n\\nThe Inventory App is a fairly simple iOS app that allows users to manage the online record of their physical stores' inventories. The app allows users to take the following actions:\\n\\n* Create an account\\n* Login and logout\\n* Add an item to the inventory\\n* Adjust item quantities and prices\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/completedemo_small_fee3ae5aa6.gif\\\" width=\\\"400\\\" alt=\\\"Screen recording of a user interacting with the Inventory App to login, add an item named 'Concealer' to the inventory, adjust item quantities, and logout\\\" style=\\\"text-align: center;\\\"/>\\n</div>\\n\\nIf you'd like to try the app for yourself, you can get a copy of the code in the GitHub repo: [mongodb-developer/realm-demos](https://github.com/mongodb-developer/realm-demos).\\n\\n### The System Architecture\\n\\nThe system has three major components:\\n\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/general_objects_mobile_4x_6fe67c6c8c.png\\\" width=\\\"30\\\" alt=\\\"Mobile device icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/> **The Inventory App** is the iOS app that will be installed on the mobile device. The local Realm database is embedded in the Inventory App and stores a local copy of the inventory data.\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Realm_Icon_2x_9bef9956b3.png\\\" width=\\\"30\\\" alt=\\\"Realm icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/>**The Realm App** is the central MongoDB Realm backend instance of the mobile application. In this case, the Realm App utilizes Realm features like [authentication](https://docs.mongodb.com/realm/authentication/), [rules](https://docs.mongodb.com/realm/mongodb/), [schema](https://docs.mongodb.com/realm/mongodb/document-schemas/), [GraphQL API](https://docs.mongodb.com/realm/graphql/), and [Sync](https://docs.mongodb.com/realm/sync/). The Inventory App is connected to the Realm App. **Note**: The Inventory App and the Realm App are NOT the same thing; they have two different code bases.\\n* <img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/mongodb_atlas_cluster_4x_ce6d233ecb.png\\\" width=\\\"30\\\" alt=\\\"Atlas database icon\\\" style=\\\"float: left; padding-right: 5px;\\\"/> **The Atlas Database** stores the inventory data. [Atlas](https://cloud.mongodb.com/) is MongoDB's fully managed Database-as-a-Service. Realm Sync handles keeping the data synced between Atlas and the mobile apps.\\n\\n![Diagram showing how the Mobile App syncs with the Atlas database using Realm Sync](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_14_at_7_50_18_AM_09bb66451d.png)\\n\\nAs you're building a CI/CD pipeline for a mobile app with an associated Realm App and Atlas database, you'll need to take into consideration how you're going to build and deploy both the mobile app and the Realm App. You'll also need to figure out how you're going to indicate which database the Realm App should be syncing to. Don't worry, I'll share strategies for how to do all of this in the sections below.\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/bored_5c6b8e36c1.gif\\\" width=\\\"400\\\" alt=\\\"I've never been more bored in my entire life\\\"/>\\n</div>\\n\\nOkay, that's enough boring stuff. Let's get to my favorite part: the CI/CD pipeline!\\n\\n## All About the Pipeline\\n\\nNow that you know what the Inventory App does and how it was architected, let's dive into the details of the CI/CD pipeline for this app. You can use this pipeline as a basis for your pipeline and tweak it to fit your team's process.\\n\\nMy pipeline has three main stages:\\n\\n* **Development**: In the Development Stage, developers do their development work like creating new features and fixing bugs.\\n* **Staging**: In the Staging Stage, the team simulates the production environment to make sure everything works together as intended. The Staging Stage could also be known as QA (Quality Assurance), Testing, or Pre-Production.\\n* **Production**: The Production Stage is the final stage where the end users have access to your apps.\\n\\n![Diagram showing the three stages of the pipeline: Development, Staging, and Production](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_14_at_7_53_34_AM_5062cea6d6.png)\\n\\n### Pipeline Implementation Using GitHub Actions\\n\\nA variety of tools exist to help teams implement CI/CD pipelines. I chose to use [GitHub Actions](https://github.com/features/actions), because it works well with GitHub (which is where my code is already) and it has a free plan for public repositories (and I like free things!). GitHub Actions allows you to automate [workflows](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#workflows). As you'll see in later sections, I implemented my CI/CD pipeline using a workflow. Each workflow can contain one or more [jobs](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#jobs), and each job contains one or more [steps](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#steps).\\n\\nThe complete workflow is available in [build.yml](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/build.yml) in the [Inventory App's GitHub repository](https://github.com/mongodb-developer/realm-demos).\\n\\n### MongoDB Atlas Project Configuration\\n\\nThroughout the pipeline, the workflow will deploy to new or existing Realm Apps that are associated with new or existing databases based on the pipeline stage. I decided to create four Atlas projects to support my pipeline:\\n* **Inventory Demo - Feature Development.** This project contains the Realm Apps associated with every new feature. Each Realm App syncs with a database that has a custom name based on the feature (for example,Â a feature branch named `beta6-improvements` would have a database named `InventoryDemo-beta6-improvements`). All of the databases for feature branches are stored in this project's Atlas cluster. The Realm Apps and databases for feature branches are deleted after the feature work is completed.\\n* **Inventory Demo - Pull Requests.**Â This project contains the Realm Apps that are created for every pull request. Each Realm App syncs with a database that has a custom name based on the time the workflow runs (for example,Â `InventoryDemo-2021-06-07_1623089424`). All of the databases associated with pull requests are stored in this project's Atlas cluster.Â  \\n\\n   As part of my pipeline, I chose to delete the Realm App and associated database at the end of the workflow that was triggered by the pull request.Â Another option would be to skip deleting the Realm App and associated database when the tests in the workflow fail, so that a developer could manually investigate the source of the failure.\\n* **Inventory Demo - Staging.** This project contains the Realm App for Staging. The Realm App syncs with a database used only for Staging.Â The Staging database is the only database in this project's cluster. The Realm App and database are never deleted, so the team can always look in the same consistent locations for the Staging app and its data.\\n* **Inventory Demo - Production.**Â This project contains the Realm App for Production.Â The Realm App syncs with a database used only for Production.Â The Production database is the only database in this project's cluster.Â The Realm App and database are never deleted.\\n\\nNote: This app requires only a single database. If your app uses more than one database, the principles described above would still hold true.\\n\\n### What Happens in Each Stage of the Pipeline\\n\\nI've been assigned a ticket to change the color of the **Log In** button in the iOS app from blue to pink. In the following sections, I'll walk you through what happens in each stage of the pipeline and how my code change is moved from one stage to the next.\\n\\nAll of the stages and transitions below use the same GitHub Actions workflow. The workflow has conditions that modify which steps are taken. I'll walk you through what steps are run in each workflow execution in the sections below. The workflow uses [environment variables](https://docs.github.com/en/actions/reference/environment-variables) and [secrets](https://docs.github.com/en/actions/reference/encrypted-secrets) to store values. Visit the [realm-demos GitHub repo](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/build.yml) to see the complete workflow source code.\\n\\n#### Development\\n\\nThe Development stage is where I'll do my work to update the button color. In the subsections below, I'll walk you through how I do my work and trigger a workflow.\\n\\n##### Updating the Inventory App\\n\\nSince I want to update my iOS app code, I'll begin by opening a copy of my app's code in [Xcode](https://developer.apple.com/xcode/). I'll change the color of the **Log In** button there. I'm a good developer ðŸ˜‰, so I'll run the automated tests to make sure I didn't break anything. The Inventory App has automated unit and UI tests that were implemented using [XCTest](https://developer.apple.com/documentation/xctest). I'll also kick off a simulator, so I can manually test that the new button color looks fabulous.\\n\\n![Updating the button color in Xcode](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_52_51_PM_231b26e4c2.png \\\"Updating the button color in Xcode\\\")\\n\\n##### Updating the Realm App\\n\\nIf I wanted to make an update to the Realm App code, I could either:\\n\\n* work in the cloud in the Realm web interface or\\n* work locally in a code editor like Visual Studio Code.\\n\\nIf I choose to work in the Realm web interface, I can make changes and deploy them. The Realm web interface was recently updated to allow developers to commit changes they make there to their GitHub repositories. This means changes made in the web interface won't get lost when changes are deployed through other methods (like through the Realm Command Line Interface or automated GitHub deployments).\\n\\n![Updating the Realm App code in the Realm web interface](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_2_00_42_PM_e78f5d2efc.png \\\"Updating the Realm App code in the Realm web interface\\\")\\n\\nIf I choose to work with my Realm App code locally, I could make my code changes and then run unit tests. If I want to run integration tests or do some manual testing, I need to deploy the Realm App. One option is to use the [Realm Command Line Interface](https://docs.mongodb.com/realm/deploy/realm-cli-reference/#realm-cli) (Realm CLI) to deploy with a command like [`realm-cli push`](https://docs.mongodb.com/realm/deploy/deploy-cli/#deploy-the-updated-app). Another option is to automate the deployment using a GitHub Actions workflow.\\n\\n![Updating the Realm App code locally in Visual Studio Code](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_52_32_PM_d331a77e6e.png \\\"Updating the Realm App code locally in Visual Studio Code\\\")\\n\\nI've chosen to automate the deployment using a GitHub Actions workflow, which I'll describe in the following section.\\n\\n##### Kicking Off the Workflow\\n\\nAs I am working locally to make changes to both the Inventory App and the Realm App, I can commit the changes to a new [feature branch](https://martinfowler.com/bliki/FeatureBranch.html) in my GitHub repository.\\n\\nWhen I am ready to deploy my Realm App and run all of my automated tests, I will push the commits to my repository. The push will trigger the workflow. \\n\\n![Screenshot of the GitHub Actions web interface after a push to a feature branch triggers a workflow](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Screen_Shot_2021_06_07_at_1_55_38_PM_9499d4483d.png \\\"The workflow is in progress after a push to a feature branch\\\")\\n\\nThe workflow runs the [`build`](https://github.com/mongodb-developer/realm-demos/blob/5c3a1d3554527fe9fb2602dcbc84e2cc4d39acac/.github/workflows/build.yml#L6) job, which runs the following steps:\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out the repository so the workflow can access the code.\\n3. <a name=\\\"store-current-time\\\">**Store current time in variable.** Stores the current time in an environment variable named `CURRENT_TIME`. This variable is used later in the workflow.</a>\\n\\n    ```\\n    echo \\\"CURRENT_TIME=$(date +'%Y-%m-%d_%s')\\\" >> $GITHUB_ENV\\n    ```\\n\\n4. **Is this a push to a feature branch?** If this is a push to a feature branch (which it is), do the following:\\n    * Create a new environment variable to store the name of the feature branch.\\n       ```\\n       ref=$(echo ${{ github.ref }})\\n       branch=$(echo \\\"${ref##*/}\\\")\\n       echo \\\"FEATURE_BRANCH=$branch\\\" >> $GITHUB_ENV\\n       ```\\n    * Check the `GitHubActionsMetadata` Atlas database to see if a Realm App already exists for this feature branch. If a Realm App exists, store the Realm App ID in an environment variable. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n       ```\\n       output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.findOne({'branch': '$branch'})\\\")\\n        \\n       if [[ $output == *null ]]; then\\n           echo \\\"No Realm App found for this branch. A new app will be pushed later in this workflow\\\"\\n       else\\n           echo \\\"A Realm App was found for this branch. Updates will be pushed to the existing app later in this workflow\\\"\\n           app_id=$(echo $output | sed 's/^.*realm_app_id\\\" : \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n           echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n       fi\\n       ```\\n\\n    * Update the `databaseName` in the `development.json` [environment file](https://docs.mongodb.com/realm/config/environments/). Set the database name to contain the branch name to ensure it's unique.\\n\\n      ```\\n      cd inventory/export/sync/environments\\n      printf '{\\\\n     \\\"values\\\": {\\\"databaseName\\\": \\\"InventoryDemo-%s\\\"}\\\\n}' \\\"$branch\\\" > development.json \\n       ```\\n    * Indicate that the Realm App should use the `development` [environment](https://docs.mongodb.com/realm/values-and-secrets/define-environment-values/) by updating `realm_config.json`.\\n       ```\\n       cd ..\\n       sed -i txt 's/{/{ \\\"environment\\\": \\\"development\\\",/' realm_config.json\\n       ```\\n\\n5. <a name=\\\"install-realm-cli\\\">**Install the Realm CLI and authenticate.**</a>  This step installs the Realm CLI and authenticates using the API keys that are stored as GitHub secrets.\\n   ```\\n   npm install -g mongodb-realm-cli@beta\\n   realm-cli login --api-key=\\\"${{ secrets.REALM_API_PUBLIC_KEY }}\\\" --private-api-key=\\\"${{ secrets.REALM_API_PRIVATE_KEY }}\\\" --realm-url https://realm.mongodb.com --atlas-url https://cloud.mongodb.com\\n   ```\\n6. **Create a new Realm App for feature branches where the Realm App does not yet exist.** This step has three primary pieces:\\n   * Push the Realm App to the Atlas project specifically for feature branches.\\n      ```\\n      cd inventory/export/sync\\n      realm-cli push -y --project 609ea554944fe545460529a1\\n       ```\\n   * Retrieve and store the Realm App ID from the output of `realm-cli app describe`.\\n      ```\\n      output=$(realm-cli app describe)\\n      app_id=$(echo $output | sed 's/^.*client_app_id\\\": \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n      echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n      ```\\n   * Store the Realm App ID in the GitHubActionsMetadata database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n      ```\\n      mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.insertOne({'branch': '${{ env.FEATURE_BRANCH}}', 'realm_app_id': '$app_id'})\\\"\\n      ```\\n7. <a name=\\\"create-realm-app-id-txt\\\">**Create `realm-app-id.txt` that stores the Realm App ID.** This file will be stored in the mobile app code. The sole purpose of this file is to tell the mobile app to which Realm App it should connect.</a>\\n   ```\\n   echo \\\"${{ env.REALM_APP_ID }}\\\" > $PWD/inventory/clients/ios-swiftui/InventoryDemo/realm-app-id.txt\\n   ```\\n8. <a name=\\\"build-mobile-app\\\">**Build mobile app and run tests.** This step builds the mobile app for testing and then runs the tests using a variety of simulators. If you have integration tests, you could also choose to checkout previous releases of the mobile app and run the integration tests against the current version of the Realm App to ensure backwards compatibility.</a>\\n   * Navigate to the mobile app's directory.\\n      ```\\n      cd inventory/clients/ios-swiftui/InventoryDemo\\n      ```\\n   * Build the mobile app for testing.\\n      ```\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 12 Pro Max,OS=14.4' -derivedDataPath './output' build-for-testing\\n      ```\\n   * Define the simulators that will be used for testing.\\n      ```\\n      iPhone12Pro='platform=iOS Simulator,name=iPhone 12 Pro Max,OS=14.4'\\n      iPhone12='platform=iOS Simulator,name=iPhone 12,OS=14.4'\\n      iPadPro4='platform=iOS Simulator,name=iPad Pro (12.9-inch) (4th generation)'\\n      ```   \\n   * Run the tests on a variety of simulators. Optionally, you could put these in separate jobs to run in parallel.\\n      ```\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPhone12Pro\\\" -derivedDataPath './output' test-without-building\\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPhone12\\\" -derivedDataPath './output' test-without-building     \\n      xcodebuild -project InventoryDemo.xcodeproj -scheme \\\"ci\\\" -sdk iphonesimulator -destination \\\"$iPadPro4\\\" -derivedDataPath './output' test-without-building\\n        ```\\n9. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n10. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nThe nice thing here is that simply by pushing my code changes to my feature branch, my Realm App is deployed and the tests are run. When I am finished making updates to the code, I can feel confident that a Staging build will be successful.\\n\\n#### Moving from Development to Staging\\n\\nNow that I'm done working on my code changes, I'm ready to move to Staging. I can kick off this process by creating a [GitHub pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). In the pull request, I'll request to merge my code from my feature branch to the `staging` branch. When I submit the pull request, GitHub will automatically kick off another workflow for me. \\n\\n![Screenshot of a pull request](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/pull_request_dbe365f655.png \\\"The pull request shows that a workflow is in progress\\\")\\n\\nThe workflow runs the following steps.\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out the repository so the workflow can access the code.\\n3. **Store current time in variable.** See the [section above](#store-current-time) for more information on this step.\\n4. **Set environment variables for all other runs.** This step sets the necessary environment variables for pull requests where a new Realm App and database will be created for *each* pull request. This step has three primary pieces.\\n    * Create a new environment variable named `IS_DYNAMICALLY_GENERATED_APP` to indicate this is a dynamically generated app that should be deleted later in this workflow.\\n       ```\\n       echo \\\"IS_DYNAMICALLY_GENERATED_APP=true\\\" >> $GITHUB_ENV\\n       ```\\n    * Update the `databaseName` in the `testing.json` [environment file](https://docs.mongodb.com/realm/config/environments/). Set the database name to contain the current time to ensure it's unique.\\n       ```\\n       cd inventory/export/sync/environments\\n       printf '{\\\\n     \\\"values\\\": {\\\"databaseName\\\": \\\"InventoryDemo-%s\\\"}\\\\n}' \\\"${{ env.CURRENT_TIME }}\\\" > testing.json  \\n       ```\\n   * Indicate that the Realm App should use the `testing` [environment](https://docs.mongodb.com/realm/values-and-secrets/define-environment-values/) by updating `realm_config.json`.\\n      ```\\n      cd ..\\n      sed -i txt 's/{/{ \\\"environment\\\": \\\"testing\\\",/' realm_config.json \\n      ```\\n5. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n6. **Create a new Realm App for pull requests.** Since this is a pull request, the workflow creates a new Realm App just for this workflow. The Realm App will be deleted at the end of the workflow.\\n    * Push to the Atlas project specifically for pull requests.\\n       ```\\n       cd inventory/export/sync\\n       realm-cli push -y --project 609ea554944fe545460529a1\\n        ```\\n    * Retrieve and store the Realm App ID from the output of `realm-cli app describe`.\\n       ```\\n       output=$(realm-cli app describe)\\n       app_id=$(echo $output | sed 's/^.*client_app_id\\\": \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n       echo \\\"REALM_APP_ID=$app_id\\\" >> $GITHUB_ENV\\n        ```\\n    * Store the Realm App ID in the `GitHubActionsMetadata` database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n       ```\\n       mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.insertOne({'branch': '${{ env.FEATURE_BRANCH}}', 'realm_app_id': '$app_id'})\\\"\\n       ```\\n7. **Create `realm-app-id.txt` that stores the Realm App ID.** See the [section above](#create-realm-app-id-txt) for more information on this step.\\n8. **Build mobile app and run tests.** See the [section above](#build-mobile-app) for more information on this step.\\n9. **Delete dynamically generated Realm App.** The workflow created a Realm App just for this pull request in an earlier step. This step deletes that Realm App.\\n   ```\\n   realm-cli app delete --app ${{ env.REALM_APP_ID }}\\n   ```\\n10. **Delete dynamically generated database.** The workflow also created a database just for this pull request in an earlier step. This step deletes that database.\\n    ```\\n    mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_PULL_REQUESTS }}/InventoryDemo-${{ env.CURRENT_TIME }}\\\" --username ${{ secrets.ATLAS_USERNAME_PULL_REQUESTS }} --password ${{ secrets.ATLAS_PASSWORD_PULL_REQUESTS }} --eval \\\"db.dropDatabase()\\\"\\n    ```\\n11. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n12. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nThe results of the workflow are included in the pull request.\\n\\n![\\\"Screenshot of the workflow results in the pull request](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/prcheckspassed_a67dde1eaa.png \\\"The pull request shows that all workflows completed successfully\\\")\\n\\nMy teammate will review the pull request. They will likely review the code and double check that the workflow passed. We might go back and forth with suggestions and updates until we both agree the code is ready to be merged into the `staging` branch.\\n\\nWhen the code is ready, my teammate will approve the pull request and then click the button to squash and merge the commits. My teammate may also choose to delete the branch as it is no longer needed. \\n\\n![Screenshot of the option to delete the branch](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/deletebranch_ff52d9ee1c.png \\\"My teammate can delete the branch with the click of a button in the pull request\\\")\\n\\nDeleting the branch triggers the `delete-feature-branch-artifacts` workflow. This workflow is different from all of the workflows I will discuss in this article. This workflow's job is to delete the artifacts that were associated with the branch. \\n\\n![Screenshot of the GitHub Actions web interface after deleting a branch triggers a workflow](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/deletebuild_474562b75d.png \\\"The workflow to delete the feature branch artifacts is in progress\\\")\\n\\nThe [`delete-feature-branch-artifacts`](https://github.com/mongodb-developer/realm-demos/blob/main/.github/workflows/delete-feature-branch-artifacts.yml) workflow runs the following steps.\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n3. **Store the name of the branch.** This step retrieves the name of the branch that was just deleted and stores it in an environment variable named `FEATURE_BRANCH`.\\n   ```\\n   ref=$(echo ${{ github.event.ref }})\\n   branch=$(echo \\\"${ref##*/}\\\")\\n   echo \\\"FEATURE_BRANCH=$branch\\\" >> $GITHUB_ENV\\n   ```\\n\\n4. **Delete the Realm App associated with the branch.** This step queries the `GitHubActionsMetadata` database for the ID of the Realm App associated with this branch. Then it deletes the Realm App, and deletes the information in the `GitHubActionsMetadata` database. Note: Accessing the Atlas database requires the IP address of the GitHub Actions virtual machine to be in the [Atlas IP Access List](https://docs.atlas.mongodb.com/security/ip-access-list/).\\n\\n   ```\\n   # Get the Realm App associated with this branch\\n   output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.findOne({'branch': '${{ env.FEATURE_BRANCH }}'})\\\")\\n   \\n   if [[ $output == *null ]]; then\\n       echo \\\"No Realm App found for this branch\\\"\\n   else\\n       # Parse the output to retrieve the realm_app_id\\n       app_id=$(echo $output | sed 's/^.*realm_app_id\\\" : \\\"\\\\([^\\\"]*\\\\).*/\\\\1/')\\n              \\n       # Delete the Realm App\\n       echo \\\"A Realm App was found for this branch: $app_id. It will now be deleted\\\"\\n       realm-cli app delete --app $app_id\\n        \\n       # Delete the record in the GitHubActionsMetadata database\\n       output=$(mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/GitHubActionsMetadata\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.metadata.deleteOne({'branch': '${{ env.FEATURE_BRANCH }}'})\\\")\\n   fi\\n   ```\\n\\n5. **Delete the database associated with the branch.** This step deletes the database associated with the branch that was just deleted.\\n\\n   ```\\n   mongo \\\"mongodb+srv://${{ secrets.ATLAS_URI_FEATURE_BRANCHES }}/InventoryDemo-${{ env.FEATURE_BRANCH }}\\\" --username ${{ secrets.ATLAS_USERNAME_FEATURE_BRANCHES }} --password ${{ secrets.ATLAS_PASSWORD_FEATURE_BRANCHES }} --eval \\\"db.dropDatabase()\\\"\\n   ```\\n\\n6. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\n#### Staging\\n\\nAs part of the pull request process, my teammate merged my code change into the `staging` branch. I call this stage \\\"Staging,\\\" but teams have a variety of names for this stage. They might call it \\\"QA (Quality Assurance),\\\" \\\"Testing,\\\" \\\"Pre-Production,\\\" or scom/actions/checkout) to check out the repository so the workflow can access the code.\\n3. **Store current time in variable.** See the [section above](#store-current-time) for more information on this step.\\n4. **Is this a push to the Staging branch?** This step checks if the workflow was triggered by a push to the `staging` branch. If so, it stores the ID of the Staging Realm App in the `REALM_APP_ID` environment variable.\\n   ```\\n   echo \\\"REALM_APP_ID=inventorydemo-staging-zahjj\\\" >> $GITHUB_ENV\\n   ```\\n\\n5. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n6. <a name=\\\"push-updated-copy\\\">**Push updated copy of the Realm App for existing apps (Main, Staging, or Feature branches).** This step pushes an updated copy of the Realm App (stored in `inventory/export/sync`) for cases when the Realm App already exists.</a>\\n   ```\\n   cd inventory/export/sync\\n   realm-cli push --remote=\\\"${{ env.REALM_APP_ID }}\\\" -y\\n   ```\\n7. **Create `realm-app-id.txt` that stores the Realm App ID.** See the [section above](#create-realm-app-id-txt) for more information on this step.\\n8. **Build mobile app and run tests.** See the [section above](#build-mobile-app) for more information on this step.\\n9. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n10. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nRealm has a new feature releasing soon that will allow you to roll back deployments. When this feature releases, I plan to add a step to the workflow above to automatically roll back the deployment to the previous one in the event of test failures.\\n\\n#### Moving from Staging to Production\\n\\nAt this point, some teams may choose to have their pipeline automation stop before automatically moving to production. They may want to run manual tests. Or they may want to intentionally limit their number of releases.\\n\\nI've chosen to move forward with continuous deployment in my pipeline. So, if the tests in Staging pass, the workflow above continues on to the [`pushToMainBranch`](https://github.com/mongodb-developer/realm-demos/blob/5c3a1d3554527fe9fb2602dcbc84e2cc4d39acac/.github/workflows/build.yml#L238) job that automatically pushes the latest commits to the `main` branch. The job runs the following steps:\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out all branches in the repository, so the workflow can access both the `main` and `staging` branches.\\n3. **Push to the Main branch.** Merges the code from `staging` into `main`.\\n   ```\\n   git merge origin/staging\\n   git push\\n    ```\\n4. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n5. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\n#### Production\\n\\nNow my code is in the final stage: production. Production is where the end users get access to the application.\\n\\nWhen the previous workflow merged the code changes from the `staging` branch into the `main` branch, another workflow began. \\n\\n![Screenshot of the GitHub Actions web interface after a push to the 'main' branch triggers a workflow](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/prod_build_5eac510122.png \\\"The workflow that was kicked off when code was merged into the 'main' branch is in progress\\\")\\n\\nThe workflow runs the following steps.\\n\\n1. **Set up job.** This step is created by GitHub Actions to prepare the workflow.\\n2. **Run actions/checkout@v2.** Uses the [Checkout V2 Action](https://github.com/actions/checkout) to check out the repository so the workflow can access the code.\\n3. **Store current time in variable.** See the [section above](#store-current-time) for more information on this step.\\n4. **Is this a push to the Main branch?** This step checks if the workflow was triggered by a push to the `main` branch. If so, it stores the ID of the Production Realm App in the `REALM_APP_ID` environment variable.\\n   ```\\n   echo \\\"REALM_APP_ID=inventorysync-ctnnu\\\" >> $GITHUB_ENV\\n   ```\\n5. **Install the Realm CLI and authenticate.** See the [section above](#install-realm-cli) for more information on this step.\\n6. **Push updated copy of the Realm App for existing apps (Main, Staging, or Feature branches).** See the [section above](#push-updated-copy) for more information on this step.\\n7. **Create `realm-app-id.txt` that stores the Realm App ID.** See the [section above](#create-realm-app-id-txt) for more information on this step.\\n8. **Build mobile app and run tests.** See the [section above](#build-mobile-app) for more information on this step.\\n9. **Install the Apple certificate and provisioning profile (so we can create the archive).** When the workflow is in the production stage, it does something that is unique to all of the other workflows: This workflow creates the [mobile app archive file](https://en.wikipedia.org/wiki/.ipa) (the `.ipa` file). In order to create the archive file, the Apple certificate and provisioning profile need to be installed. For more information on how the Apple certificate and provisioning profile are installed, see the [GitHub documentation](https://docs.github.com/en/actions/guides/installing-an-apple-certificate-on-macos-runners-for-xcode-development).\\n10. **Archive the mobile app.** This step creates the mobile app archive file (the `.ipa` file).\\n    ```\\n    cd inventory/clients/ios-swiftui/InventoryDemo\\n    xcodebuild -workspace InventoryDemo.xcodeproj/project.xcworkspace/ -scheme ci archive -archivePath $PWD/build/ci.xcarchive -allowProvisioningUpdates\\n    xcodebuild -exportArchive -archivePath $PWD/build/ci.xcarchive -exportPath $PWD/build -exportOptionsPlist $PWD/build/ci.xcarchive/Info.plist\\n    ```\\n11. **Store the Archive in a GitHub Release.** This step uses the [gh-release action](https://github.com/softprops/action-gh-release) to store the mobile app archive in a [GitHub Release](https://github.com/mongodb-developer/realm-demos/releases) as shown in the screenshot below. ![Screenshot of a GitHub release that contains a mobile app archive](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/releases_d967ea181b.png)\\n12. **Post Run actions/checkout@v2.** This cleanup step runs automatically when you use the [Checkout V2 Action](https://github.com/actions/checkout).\\n13. **Complete job.** This step is created by GitHub Actions to complete the workflow.\\n\\nAs I described above, my pipeline creates a GitHub release and stores the `.ipa` file in the release. Another option would be to push the `.ipa` file to [TestFlight](https://developer.apple.com/testflight/) so you could send it to your users for beta testing. Or you could automatically upload the `.ipa` to the [App Store](https://developer.apple.com/ios/submit/) for Apple to review and approve for publication. You have the ability to customize your worfklow based on your team's process.\\n\\nThe nice thing about automating the deployment to production is that no one has to build the mobile app archive locally. You don't have to worry about that one person who knows how to build the archive going on vacation or leaving the companyâ€”everything is automated, so you can keep delivering new features to your users without the panic of what to do if a key person is out of the office.\\n\\n## Building Your Pipeline\\n\\nAs I wrap up this article, I want to help you get started building your pipeline.\\n\\n### Map Your Pipeline\\n\\nI encourage you to begin by working with key stakeholders to map your ideal pipeline. Ask questions like the following:\\n\\n* **What stages will be in the pipeline?** Do you have more stages than just Development, Staging, and Production?\\n* **What automated tests should be run in the various stages of your pipeline?** Consider if you need to create more automated tests so that you feel confident in your releases.\\n* **What should be the final output of your pipeline?** Is the result a fully automated pipeline that pushes changes automatically to the App Store? Or do you want to do some steps manually?\\n\\n### Implement Your Pipeline\\n\\nOnce you've mapped out your pipeline and figured out what your steps should be, it's time to start implementing your pipeline. Starting from scratch can be challenging... but you don't have to start from scratch. Here are some resources you can use:\\n\\n1. The [**mongodb-developer/realm-demos GitHub repo**](https://github.com/mongodb-developer/realm-demos) contains the code I discussed today.\\n    * The repo has example mobile app and sync code, so you can see how the app itself was implemented. Check out the [ios-swiftui](https://github.com/mongodb-developer/realm-demos/tree/main/inventory/clients/ios-swiftui) directory.\\n    * The repo also has automated tests in it, so you can take a peak at those and see how my team wrote those. Check out the [InventoryDemoTests](https://github.com/mion**](https://docs.mongodb.com/realm/) has a ton of great information and is really helpful in figuring out what you can do with the Realm CLI.\\n3. The [**MongoDB Community**](https://community.mongodb.com) is the best place to ask questions as you are implementing your pipeline. If you want to show off your pipeline and share your knowledge, we'd love to hear that as well. I hope to see you there!\\n\\n## Summary\\n\\nYou've learned a lot about how to craft your own CI/CD pipeline in this article. Creating a CI/CD pipeline can seem like a daunting task. \\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/itshard_360adab29b.gif\\\" width=\\\"400\\\" alt=\\\"But it's so hard!\\\"/>\\n</div>\\n\\nWith the resources I've given you in this article, you can create a CI/CD pipeline that is customized to your team's process.  \\n\\nAs Tom Haverford wisely said, \\\"Sometimes you gotta work a little so you can ball a lot.\\\" Once you put in the work of building a pipeline that works for you and your team, your app development can really fly, and you can feel confident in your releases. And that's a really big deal.\\n\\n<div style=\\\"text-align: center\\\">\\n<img src=\\\"https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/bigdeal_fc038aaa03.gif\\\" width=\\\"400\\\" alt=\\\"That's a really big deal\\\"/>\\n</div>\\n\n",
  "name": "How to Build CI/CD Pipelines for MongoDB Realm Apps Using GitHub Actions",
  "description": "Learn how to build CI/CD pipelines in GitHub Actions for apps built using MongoDB Realm.",
  "calculated_slug": "/products/realm/build-ci-cd-pipelines-realm-apps-github-actions",
  "date": "2021-07-08T18:45:36.603Z",
  "image": {
    "url": "https://images.contentstack.io/v3/assets/blt39790b633ee0d5a7/blt7293c5324cecd628/647a2ae9d5884b36dd7e942d/realm-logo.jpeg",
    "alternativeText": "MongoDB Realm Logo"
  },
  "authors": [
    {
      "name": "Lauren Schaefer",
      "image": {
        "url": "https://images.contentstack.io/v3/assets/blt39790b633ee0d5a7/blta5315a7a861b784f/647a309f3674f8090378d150/bio-lauren.jpg",
        "alternativeText": ""
      }
    }
  ],
  "tags": [
    { "name": "Realm", "type": "L1Product", "slug": "/products/realm" },
    {
      "name": "MongoDB",
      "type": "AuthorType",
      "slug": "/author-types/mongodb"
    },
    { "name": "Tutorial", "type": "ContentType", "slug": "/tutorials" },
    {
      "name": "Advanced",
      "type": "ExpertiseLevel",
      "slug": "/expertise-levels/advanced"
    },
    {
      "name": "English",
      "type": "SpokenLanguage",
      "slug": "/spoken-languages/english"
    },
    {
      "name": "GitHub Actions",
      "type": "Technology",
      "slug": "/technologies/github-actions"
    },
    {
      "name": "JavaScript",
      "type": "ProgrammingLanguage",
      "slug": "/technologies/github-actions"
    }
  ],
  "type": "Tutorial",
  "rating_metrics": { "average": null, "median": null, "count": 0 }
}
