#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../source/core/capped-collections.txt:5
msgid "Capped Collections"
msgstr ""

#: ../source/core/capped-collections.txt:16
msgid "Overview"
msgstr ""

#: ../source/core/capped-collections.txt:18
msgid ""
":term:`Capped collections <capped collection>` are fixed-size collections"
" that support high-throughput operations that insert and retrieve "
"documents based on insertion order. Capped collections work in a way "
"similar to circular buffers: once a collection fills its allocated space,"
" it makes room for new documents by overwriting the oldest documents in "
"the collection."
msgstr ""

#: ../source/core/capped-collections.txt:25
msgid ""
"See :method:`~db.createCollection()` or :dbcommand:`create` for more "
"information on creating capped collections."
msgstr ""

#: ../source/core/capped-collections.txt:29
msgid "Behavior"
msgstr ""

#: ../source/core/capped-collections.txt:32
msgid "Insertion Order"
msgstr ""

#: ../source/core/capped-collections.txt:34
msgid ""
"Capped collections guarantee preservation of the insertion order. As a "
"result, queries do not need an index to return documents in insertion "
"order. Without this indexing overhead, capped collections can support "
"higher insertion throughput."
msgstr ""

#: ../source/core/capped-collections.txt:40
msgid "Automatic Removal of Oldest Documents"
msgstr ""

#: ../source/core/capped-collections.txt:42
msgid ""
"To make room for new documents, capped collections automatically remove "
"the oldest documents in the collection without requiring scripts or "
"explicit remove operations."
msgstr ""

#: ../source/core/capped-collections.txt:46
msgid ""
"For example, the :term:`oplog.rs <oplog>` collection that stores a log of"
" the operations in a :term:`replica set` uses a capped collection. "
"Consider the following potential use cases for capped collections:"
msgstr ""

#: ../source/core/capped-collections.txt:51
msgid ""
"Store log information generated by high-volume systems. Inserting "
"documents in a capped collection without an index is close to the speed "
"of writing log information directly to a file system. Furthermore, the "
"built-in *first-in-first-out* property maintains the order of events, "
"while managing storage use."
msgstr ""

#: ../source/core/capped-collections.txt:57
msgid ""
"Cache small amounts of data in a capped collections. Since caches are "
"read rather than write heavy, you would either need to ensure that this "
"collection *always* remains in the working set (i.e. in RAM) *or* accept "
"some write penalty for the required index or indexes."
msgstr ""

#: ../source/core/capped-collections.txt:64
msgid "``_id`` Index"
msgstr ""

#: ../source/core/capped-collections.txt:66
msgid ""
"Capped collections have an ``_id`` field and an index on the ``_id`` "
"field by default."
msgstr ""

#: ../source/core/capped-collections.txt:72
msgid "Restrictions and Recommendations"
msgstr ""

#: ../source/core/capped-collections.txt:75
msgid "Updates"
msgstr ""

#: ../source/core/capped-collections.txt:77
msgid ""
"If you plan to update documents in a capped collection, create an index "
"so that these update operations do not require a collection scan."
msgstr ""

#: ../source/core/capped-collections.txt:81
msgid "Document Size"
msgstr ""

#: ../source/includes/extracts/capped-collection-immutable-document-size.rst:1
msgid ""
"If an update or a replacement operation changes the document size, the "
"operation will fail."
msgstr ""

#: ../source/core/capped-collections.txt:88
msgid "Document Deletion"
msgstr ""

#: ../source/core/capped-collections.txt:90
msgid ""
"You cannot delete documents from a capped collection. To remove all "
"documents from a collection, use the :method:`~db.collection.drop()` "
"method to drop the collection and recreate the capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:95
msgid "Sharding"
msgstr ""

#: ../source/core/capped-collections.txt:97
msgid "You cannot shard a capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:100
msgid "Query Efficiency"
msgstr ""

#: ../source/core/capped-collections.txt:102
msgid ""
"Use natural ordering to retrieve the most recently inserted elements from"
" the collection efficiently. This is (somewhat) analogous to tail on a "
"log file."
msgstr ""

#: ../source/core/capped-collections.txt:107
msgid "Aggregation ``$out``"
msgstr ""

#: ../source/core/capped-collections.txt:109
msgid ""
"The aggregation pipeline operator :pipeline:`$out` cannot write results "
"to a capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:115
msgid "Procedures"
msgstr ""

#: ../source/core/capped-collections.txt:118
msgid "Create a Capped Collection"
msgstr ""

#: ../source/core/capped-collections.txt:120
msgid ""
"You must create capped collections explicitly using the "
":method:`db.createCollection()` method, which is a helper in the "
":binary:`~bin.mongo` shell for the :dbcommand:`create` command. When "
"creating a capped collection you must specify the maximum size of the "
"collection in bytes, which MongoDB will pre-allocate for the collection. "
"The size of the capped collection includes a small amount of space for "
"internal overhead."
msgstr ""

#: ../source/core/capped-collections.txt:132
msgid ""
"If the ``size`` field is less than or equal to 4096, then the collection "
"will have a cap of 4096 bytes. Otherwise, MongoDB will raise the provided"
" size to make it an integer multiple of 256."
msgstr ""

#: ../source/core/capped-collections.txt:136
msgid ""
"Additionally, you may also specify a maximum number of documents for the "
"collection using the ``max`` field as in the following document:"
msgstr ""

#: ../source/core/capped-collections.txt:143
msgid ""
"The ``size`` argument is *always* required, even when you specify ``max``"
" number of documents. MongoDB will remove older documents if a collection"
" reaches the maximum size limit before it reaches the maximum document "
"count."
msgstr ""

#: ../source/core/capped-collections.txt:153
msgid "Query a Capped Collection"
msgstr ""

#: ../source/core/capped-collections.txt:155
msgid ""
"If you perform a :method:`~db.collection.find()` on a capped collection "
"with no ordering specified, MongoDB guarantees that the ordering of "
"results is the same as the insertion order."
msgstr ""

#: ../source/core/capped-collections.txt:159
msgid ""
"To retrieve documents in reverse insertion order, issue "
":method:`~db.collection.find()` along with the :method:`~cursor.sort()` "
"method with the :operator:`$natural` parameter set to ``-1``, as shown in"
" the following example:"
msgstr ""

#: ../source/core/capped-collections.txt:169
msgid "Check if a Collection is Capped"
msgstr ""

#: ../source/core/capped-collections.txt:171
msgid ""
"Use the :method:`~db.collection.isCapped()` method to determine if a "
"collection is capped, as follows:"
msgstr ""

#: ../source/core/capped-collections.txt:179
msgid "Convert a Collection to Capped"
msgstr ""

#: ../source/core/capped-collections.txt:181
msgid ""
"You can convert a non-capped collection to a capped collection with the "
":dbcommand:`convertToCapped` command:"
msgstr ""

#: ../source/core/capped-collections.txt:188
msgid ""
"The ``size`` parameter specifies the size of the capped collection in "
"bytes."
msgstr ""

#: ../source/includes/fact-database-lock.rst:1
msgid ""
"This holds a database exclusive lock for the duration of the operation. "
"Other operations which lock the same database will be blocked until the "
"operation completes. See :ref:`faq-concurrency-operations-locks` for "
"operations that lock the database."
msgstr ""

#: ../source/core/capped-collections.txt:194
msgid "Automatically Remove Data After a Specified Period of Time"
msgstr ""

#: ../source/core/capped-collections.txt:196
msgid ""
"As an alternative to capped collections, consider MongoDB's :term:`TTL` "
"(\\\"*time to live*\\\") indexes. As described in :doc:`/tutorial/expire-"
"data`, these indexes allow you to expire and remove data from normal "
"collections based on the value of a date-typed field and a TTL value for "
"the index."
msgstr ""

#: ../source/core/capped-collections.txt:205
msgid ""
":doc:`TTL indexes </tutorial/expire-data>` are not compatible with capped"
" collections."
msgstr ""

#: ../source/core/capped-collections.txt:209
msgid "Tailable Cursor"
msgstr ""

#: ../source/core/capped-collections.txt:211
msgid ""
"You can use a :term:`tailable cursor` with capped collections. Similar to"
" the Unix ``tail -f`` command, the tailable cursor \"tails\" the end of a"
" capped collection. As new documents are inserted into the capped "
"collection, you can use the tailable cursor to continue retrieving "
"documents."
msgstr ""

#: ../source/core/capped-collections.txt:217
msgid ""
"See :doc:`/core/tailable-cursors` for information on creating a tailable "
"cursor."
msgstr ""

#~ msgid "Capped collections have the following behaviors:"
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee preservation of"
#~ " the insertion order. As a result,"
#~ " queries do not need an index "
#~ "to return documents in insertion order."
#~ " Without this indexing overhead, they "
#~ "can support higher insertion throughput."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee that insertion"
#~ " order is identical to the order "
#~ "on disk (:term:`natural order`) and do"
#~ " so by prohibiting updates that "
#~ "increase document size. Capped collections "
#~ "only allow updates that fit the "
#~ "original document size, which ensures a"
#~ " document does not change its "
#~ "location on disk."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections automatically remove the"
#~ " oldest documents in the collection "
#~ "without requiring scripts or explicit "
#~ "remove operations."
#~ msgstr ""

#~ msgid "Recommendations and Restrictions"
#~ msgstr ""

#~ msgid ""
#~ "You can only make in-place updates"
#~ " of documents. If the update "
#~ "operation causes the document to grow"
#~ " beyond their original size, the "
#~ "update operation will fail."
#~ msgstr ""

#~ msgid ""
#~ "If you plan to update documents in"
#~ " a capped collection, create an index"
#~ " so that these update operations do"
#~ " not require a table scan."
#~ msgstr ""

#~ msgid ""
#~ "If you update a document in a "
#~ "capped collection to a size smaller "
#~ "than its original size, and then a"
#~ " secondary resyncs from the primary, "
#~ "the secondary will replicate and "
#~ "allocate space based on the current "
#~ "smaller document size. If the primary"
#~ " then receives an update which "
#~ "increases the document back to its "
#~ "original size, the primary will accept"
#~ " the update but the secondary will"
#~ " fail with a ``failing update: "
#~ "objects in a capped ns cannot "
#~ "grow`` error message."
#~ msgstr ""

#~ msgid ""
#~ "To prevent this error, create your "
#~ "secondary from a snapshot of one "
#~ "of the other up-to-date members"
#~ " of the replica set. Follow :doc:`our"
#~ " tutorial on filesystem snapshots "
#~ "</tutorial/backup-with-filesystem-snapshots>` "
#~ "to seed your new secondary."
#~ msgstr ""

#~ msgid ""
#~ "Seeding the secondary with a filesystem"
#~ " snapshot is the only way to "
#~ "guarantee the primary and secondary "
#~ "binary files are compatible. |MMS| "
#~ "Backup snapshots are insufficient in "
#~ "this situation since you need more "
#~ "than the content of the secondary "
#~ "to match the primary."
#~ msgstr ""

#~ msgid ""
#~ "You cannot delete documents from a "
#~ "capped collection.  To remove all "
#~ "documents from a collection, use the "
#~ ":method:`~db.collection.drop()` method to drop "
#~ "the collection."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections created after 2.2 "
#~ "have an ``_id`` field and an index"
#~ " on the ``_id`` field by default. "
#~ "Capped collections created before 2.2 do"
#~ " not have an index on the "
#~ "``_id`` field by default. If you "
#~ "are using capped collections with "
#~ "replication prior to 2.2, you should "
#~ "explicitly create an index on the "
#~ "``_id`` field."
#~ msgstr ""

#~ msgid ""
#~ "If you have a capped collection in"
#~ " a :term:`replica set` outside of the"
#~ " ``local`` database, before 2.2, you "
#~ "should create a unique index on "
#~ "``_id``. Ensure uniqueness using the "
#~ "``unique: true`` option to the "
#~ ":method:`~db.collection.createIndex()` method or by"
#~ " using an :term:`ObjectId` for the "
#~ "``_id`` field. Alternately, you can use"
#~ " the ``autoIndexId`` option to "
#~ ":dbcommand:`create` when creating the capped"
#~ " collection, as in the :ref:`capped-"
#~ "collections-options` procedure."
#~ msgstr ""

#~ msgid ""
#~ "You must create capped collections "
#~ "explicitly using the "
#~ ":method:`~db.createCollection()` method, which is"
#~ " a helper in the :program:`mongo` "
#~ "shell for the :dbcommand:`create` command. "
#~ "When creating a capped collection you"
#~ " must specify the maximum size of "
#~ "the collection in bytes, which MongoDB"
#~ " will pre-allocate for the "
#~ "collection. The size of the capped "
#~ "collection includes a small amount of"
#~ " space for internal overhead."
#~ msgstr ""

#~ msgid ""
#~ "Before 2.2, capped collections did not"
#~ " have an index on ``_id`` unless "
#~ "you specified ``autoIndexId`` to the "
#~ ":dbcommand:`create`, after 2.2 this became "
#~ "the default."
#~ msgstr ""

#~ msgid ""
#~ "See :doc:`/tutorial/create-tailable-cursor` "
#~ "for information on creating a tailable"
#~ " cursor."
#~ msgstr ""

#~ msgid "See"
#~ msgstr ""

#~ msgid ""
#~ "This command obtains a global write "
#~ "lock and will block other operations "
#~ "until it has completed."
#~ msgstr ""

#~ msgid ""
#~ "For additional flexibility when expiring "
#~ "data, consider MongoDB's :term:`TTL` indexes,"
#~ " as described in :doc:`/tutorial/expire-"
#~ "data`. These indexes allow you to "
#~ "expire and remove data from normal "
#~ "collections using a special type, based"
#~ " on the value of a date-typed"
#~ " field and a TTL value for the"
#~ " index."
#~ msgstr ""

#~ msgid ""
#~ ":doc:`TTL Collections </tutorial/expire-data>` "
#~ "are not compatible with capped "
#~ "collections."
#~ msgstr ""

#~ msgid "On this page"
#~ msgstr ""

#~ msgid ""
#~ "You must create capped collections "
#~ "explicitly using the :method:`db.createCollection()`"
#~ " method, which is a helper in "
#~ "the :program:`mongo` shell for the "
#~ ":dbcommand:`create` command. When creating a"
#~ " capped collection you must specify "
#~ "the maximum size of the collection "
#~ "in bytes, which MongoDB will pre-"
#~ "allocate for the collection. The size"
#~ " of the capped collection includes a"
#~ " small amount of space for internal"
#~ " overhead."
#~ msgstr ""

