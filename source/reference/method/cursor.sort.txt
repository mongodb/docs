=============
cursor.sort()
=============

.. default-domain:: mongodb

Definition
----------

.. method:: cursor.sort(sort)

   Controls the order that the query returns matching documents. For
   each field in the sort document, if the field's corresponding value
   is positive, then :method:`~cursor.sort()` returns query
   results in ascending order for that attribute. If the field's
   corresponding value is negative, then :method:`~cursor.sort()` returns query results in descending order.

   The :method:`~cursor.sort()` method has the following parameter:

   .. include:: /reference/method/cursor.sort-param.rst

   The ``sort`` parameter contains field and value pairs, in the
   following form:

   .. code-block:: javascript

      { field: value }

   - ``field`` is the field by which to sort documents.

   - ``value`` is either 1 for ascending or -1 for descending.

   .. note::

      You must apply :method:`~cursor.sort()` to the cursor before
      retrieving any documents from the database.

      .. todo: verify "must," seems a bit strong.

Behavior
--------

Sort Order
~~~~~~~~~~

.. include:: /includes/fact-sort-order.rst

Limit Results
~~~~~~~~~~~~~

The sort operation requires that the entire sort be able to complete
within 32 megabytes.

When the sort operation consumes more than 32 megabytes, MongoDB
returns an error. To avoid this error, either create an index to
support the sort operation or use :method:`~cursor.sort()` in
conjunction with :method:`~cursor.limit()`. The specified limit must
result in a number of documents that fall within the 32 megabyte limit.

For example, if the following sort operation ``stocks_quotes`` exceeds
the 32 megabyte limit:

.. code-block:: javascript

   db.stocks.find().sort( { ticker: 1, date: -1 } )

Either create an index to support the sort operation:

.. code-block:: javascript

   db.stocks.ensureIndex( { ticker: 1, date: -1 } )

Or use :method:`~cursor.sort()` in conjunction with
:method:`~cursor.limit()`:

.. code-block:: javascript

   db.stocks.find().sort( { ticker: 1, date: -1 } ).limit(100)

.. _sort-with-projection:

Interaction with :term:`Projection`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a set of results are both sorted and projected, the MongoDB query engine
will always apply the sorting **first**.

Examples
--------

A collection ``orders`` contain the following documents:

.. code-block:: javascript

   { _id: 1, item: { category: "cake", type: "chiffon" }, amount: 10 }
   { _id: 2, item: { category: "cookies", type: "chocolate chip" }, amount: 50 }
   { _id: 3, item: { category: "cookies", type: "chocolate chip" }, amount: 15 }
   { _id: 4, item: { category: "cake", type: "lemon" }, amount: 30 }
   { _id: 5, item: { category: "cake", type: "carrot" }, amount: 20 }
   { _id: 6, item: { category: "brownies", type: "blondie" }, amount: 10 }

The following query, which returns all documents from the ``orders``
collection, does not specify a sort order:

.. code-block:: javascript

   db.orders.find()

The query returns the documents in indeterminate order:

.. code-block:: none

   { "_id" : 1, "item" : { "category" : "cake", "type" : "chiffon" }, "amount" : 10 }
   { "_id" : 2, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 50 }
   { "_id" : 3, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 15 }
   { "_id" : 4, "item" : { "category" : "cake", "type" : "lemon" }, "amount" : 30 }
   { "_id" : 5, "item" : { "category" : "cake", "type" : "carrot" }, "amount" : 20 }
   { "_id" : 6, "item" : { "category" : "brownies", "type" : "blondie" }, "amount" : 10 }

The following query specifies a sort on the ``amount`` field in
descending order.

.. code-block:: javascript

   db.orders.find().sort( { amount: -1 } )

The query returns the following documents, in descending order of
``amount``:

.. code-block:: javascript

   { "_id" : 2, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 50 }
   { "_id" : 4, "item" : { "category" : "cake", "type" : "lemon" }, "amount" : 30 }
   { "_id" : 5, "item" : { "category" : "cake", "type" : "carrot" }, "amount" : 20 }
   { "_id" : 3, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 15 }
   { "_id" : 1, "item" : { "category" : "cake", "type" : "chiffon" }, "amount" : 10 }
   { "_id" : 6, "item" : { "category" : "brownies", "type" : "blondie" }, "amount" : 10 }

The following query specifies the sort order using the fields from a
sub-document ``item``. The query sorts first by the ``category`` field
in ascending order, and then within each ``category``, by the ``type``
field in ascending order.

.. code-block:: javascript

   db.orders.find().sort( { "item.category": 1, "item.type": 1 } )

The query returns the following documents, ordered first by the
``category`` field, and within each category, by the ``type`` field:

.. code-block:: javascript

   { "_id" : 6, "item" : { "category" : "brownies", "type" : "blondie" }, "amount" : 10 }
   { "_id" : 5, "item" : { "category" : "cake", "type" : "carrot" }, "amount" : 20 }
   { "_id" : 1, "item" : { "category" : "cake", "type" : "chiffon" }, "amount" : 10 }
   { "_id" : 4, "item" : { "category" : "cake", "type" : "lemon" }, "amount" : 30 }
   { "_id" : 2, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 50 }
   { "_id" : 3, "item" : { "category" : "cookies", "type" : "chocolate chip" }, "amount" : 15 }

.. _return-storage-order:
.. _return-natural-order:

Return in Natural Order
-----------------------

The :operator:`$natural` parameter returns items according to their
:term:`natural order` within the database. This ordering is an internal
implementation feature, and you should not rely on any particular structure
within it.

Typically, the natural order reflects insertion order, *except* when
documents relocate because of :ref:`document growth due to updates
<data-model-document-growth>` or remove operations free up space which
are then taken up by newly inserted documents.

Consider the sequence of insert operations to the ``trees`` collection:

.. code-block:: javascript

   db.trees.insert( { _id: 1, common_name: "oak", genus: "quercus" } )
   db.trees.insert( { _id: 2, common_name: "chestnut", genus: "castanea" } )
   db.trees.insert( { _id: 3, common_name: "maple", genus: "aceraceae" } )
   db.trees.insert( { _id: 4, common_name: "birch", genus: "betula" } )

The following query returns the documents in the natural order:

.. code-block:: javascript

   db.trees.find().sort( { $natural: 1 } )

The documents return in the following order:

.. code-block:: javascript

   { "_id" : 1, "common_name" : "oak", "genus" : "quercus" }
   { "_id" : 2, "common_name" : "chestnut", "genus" : "castanea" }
   { "_id" : 3, "common_name" : "maple", "genus" : "aceraceae" }
   { "_id" : 4, "common_name" : "birch", "genus" : "betula" }

Update a document such that the document outgrows its current allotted space:

.. code-block:: javascript

   db.trees.update(
      { _id: 1 },
      { $set: { famous_oaks: [ "Emancipation Oak", "Goethe Oak" ] } }
   )

Rerun the query to returns the documents in natural order:

.. code-block:: javascript

   db.trees.find().sort( { $natural: 1 } )

The documents return in the following natural order:

.. code-block:: javascript

   { "_id" : 2, "common_name" : "chestnut", "genus" : "castanea" }
   { "_id" : 3, "common_name" : "maple", "genus" : "aceraceae" }
   { "_id" : 4, "common_name" : "birch", "genus" : "betula" }
   { "_id" : 1, "common_name" : "oak", "genus" : "quercus", "famous_oaks" : [ "Emancipation Oak", "Goethe Oak" ] }

.. seealso:: :operator:`$natural`
