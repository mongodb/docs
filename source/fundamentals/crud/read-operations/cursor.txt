=========================
Access Data From a Cursor
=========================

.. default-domain:: mongodb

Read operations that return multiple documents do not immediately return
all values matching the query. Because a query can potentially match
very large sets of documents, these operations rely upon an
object called a :node-api:`cursor <Cursor.html>`
that fetches documents in batches to reduce both memory consumption and
network bandwidth usage. Cursors are highly configurable and offer
multiple interaction paradigms for different use cases.

The following functions directly return cursors:

- ``Collection.find()``

- ``Collection.aggregate()``

- ``Collection.listIndexes()``

- ``Db.aggregate()``

- ``Db.listCollections()``

Other methods such as :doc:`Collection.findOne() </usage-examples/findOne>`
and :doc:`Collection.watch() </usage-examples/changeStream>` use
cursors internally, and return the results of the operations instead of
a cursor.

Cursor Paradigms
----------------

You can work with cursors using a number of **cursor paradigms**.
Most cursor paradigms allow you to access query results one document at
a time, abstracting away network and caching logic. However, since use
cases differ, other paradigms offer different access patterns, like
pulling all matching documents into a collection in process memory.

.. warning::

   Do not combine different cursor paradigms on a single cursor.
   Operations such as ``hasNext()``, ``forEach()``, and ``toArray()``
   each predictably modify the original cursor. If you mix these calls
   on a single cursor, you may receive unexpected results.

.. warning::

   Because asynchronous calls directly modify the cursor, executing
   asynchronous calls on a single cursor simultaneously can also cause
   undefined behaviour. Always wait for the previous
   asynchronous operation to complete before running another.

.. note::

   When you reach the last result through iteration or through an at-once
   fetch, the cursor is exhausted which means it ceases to respond to methods
   that access the results.
   
For Each Functional Iteration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can pass a function to the :node-api:`forEach()
<Cursor.html#forEach>` method of any cursor to iterate through
results in a functional style:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start foreach cursor example
   :end-before: end foreach cursor example

Asynchronous Iteration
~~~~~~~~~~~~~~~~~~~~~~

Cursors implement the :mdn:`AsyncIterator
<Web/JavaScript/Reference/Statements/for-await...of>` interface, which
allows you to use cursors in ``for``...``await`` loops:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start async cursor example
   :end-before: end async cursor example

Manual Iteration
~~~~~~~~~~~~~~~~

You can use the :node-api:`hasNext() <Cursor.html#hasNext>`
method to check if a cursor can provide additional data, and then use
the :node-api:`next() <Cursor.html#next>`
method to retrieve the subsequent element of the cursor:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start manual cursor example
   :end-before: end manual cursor example

Stream API
~~~~~~~~~~

All cursors are Node Readable Streams that operate in **Object Mode** which
passes JavaScript objects rather than Buffers or Strings through the
pipeline. Cursors work with most Node stream APIs:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start stream cursor example
   :end-before: end stream cursor example

Event API
~~~~~~~~~

As Readable Streams, cursors also support the Event API's
``close``, ``data``, ``end`` and ``readable`` events:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start event cursor example
   :end-before: end event cursor example

Fetch All Documents At Once
~~~~~~~~~~~~~~~~~~~~~~~~~~~

For use cases that require all documents matched by a query to be held
in memory at the same time, use :node-api:`toArray()
<Cursor.html#toArray>`. Note that large sets of
matched documents can cause performance issues or even failures due to
exceeding memory constraints.

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start fetchAll cursor example
   :end-before: end fetchAll cursor example


Cursor Utility Methods
----------------------

Count
~~~~~

For an estimated count of the number of documents referenced by the
cursor, use :node-api:`count() <Cursor.html#count>`:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start count cursor example
   :end-before: end count cursor example

Rewind
~~~~~~

To reset a cursor to its initial position in the set of returned
documents, use :node-api:`rewind() <Cursor.html#rewind>`.

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start rewind cursor example
   :end-before: end rewind cursor example

Close
~~~~~

Cursors consume memory and network resources both in the client
application and in the connected instance of MongoDB. Use
:node-api:`close() <Cursor.html#close>`
to free up a cursor's resources in both the client application
and the MongoDB server:

.. literalinclude:: /code-snippets/crud/cursor.js
   :language: javascript
   :start-after: start close cursor example
   :end-before: end close cursor example
