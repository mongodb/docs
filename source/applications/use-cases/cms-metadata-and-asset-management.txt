==================================
CMS: Metadata and Asset Management
==================================

Problem
=======

You are designing a content management system (CMS) and you want to use
MongoDB to store the content of your sites.

Solution Overview
=================

The approach in this solution is inspired by the design of Drupal, an
open source CMS written in PHP on relational databases that is available
at `http://www.drupal.org <http://www.drupal.org>`_. In this case, you
will take advantage of MongoDB's dynamically typed collections to
*polymorphically* store all your content nodes in the same collection.
Navigational information will be stored in its own collection since
it has relatively little in common with the content nodes, and is not covered in
this use case.

The main node types which are covered here are:

Basic page
    Basic pages are useful for displaying
    infrequently-changing text such as an 'about' page. With a basic
    page, the salient information is the title and the
    content.
Blog entry
    Blog entries record a "stream" of posts from users
    on the CMS and store title, author, content, and date as relevant
    information.
Photo
    Photos participate in photo galleries, and store title,
    description, author, and date along with the actual photo binary
    data.

Schema Design
=============

The node collection contains documents of various formats, but they
will all share a similar structure, with each document including an
``_id``, ``type``, ``section``, ``slug``, ``title``, ``created`` date,
``author``, and ``tags``. The
``section`` property is used to identify groupings of items (grouped to a
particular blog or photo gallery, for instance). The ``slug`` property is
a url-friendly representation of the node that is unique within its
section, and is used for mapping URLs to nodes. Each document also
contains a ``detail`` field which will vary per document type:

.. code-block:: javascript

    {
        _id: ObjectId(…),
        nonce: ObjectId(…),
        metadata: {
            type: 'basic-page'
            section: 'my-photos',
            slug: 'about',
            title: 'About Us',
            created: ISODate(...),
            author: { _id: ObjectId(…), name: 'Rick' },
            tags: [ ... ],
            detail: { text: '# About Us\n…' }
        }
    }

For the basic page above, the detail field might simply contain the text
of the page. In the case of a blog entry, the document might resemble
the following instead:

.. code-block:: javascript

    {
        …
        metadata: {
            …
            type: 'blog-entry',
            section: 'my-blog',
            slug: '2012-03-noticed-the-news',
            …
            detail: {
                publish_on: ISODate(…),
                text: 'I noticed the news from Washington today…'
            }
        }
    }

Photos present something of a special case. Since you'll need to store
potentially very large photos, it's nice to be able to separate the binary
storage of photo data from the metadata storage. GridFS provides just such a
mechanism, splitting a "filesystem" of potentially very large "files" into
two collections, the ``files`` collection and the ``chunks`` collection. In
this case, the two collections will be called ``cms.assets.files`` and
``cms.assets.chunks``. Documents in the ``cms.assets.files``
collection will be used to store the normal GridFS metadata as well as CMS node
metadata:

.. code-block:: javascript

    {
        _id: ObjectId(…),
        length: 123...,
        chunkSize: 262144,
        uploadDate: ISODate(…),
        contentType: 'image/jpeg',
        md5: 'ba49a...',
        metadata: {
            nonce: ObjectId(…),
            slug: '2012-03-invisible-bicycle',
            type: 'photo',
            section: 'my-album',
            title: 'Kitteh',
            created: ISODate(…),
            author: { _id: ObjectId(…), name: 'Jared' },
            tags: [ … ],
            detail: {
                filename: 'kitteh_invisible_bike.jpg',
                resolution: [ 1600, 1600 ], … }
        }
    }

NOte that the "normal" node schema is embedded here in the photo schema, allowing
the use of the same code to manipulate nodes of all types.

Operations
==========

Here, some common queries and updates that you might need for your CMS are
described, paying particular attention to any "tweaks" necessary for the various
node types. The examples use the Python
programming language and the ``pymongo`` MongoDB driver, but implementations
would be similar in other languages as well.

Create and Edit Content Nodes
-----------------------------

The content producers using your CMS will be creating and editing content
most of the time. Most content-creation activities are relatively
straightforward:

.. code-block:: python

    db.cms.nodes.insert({
        'nonce': ObjectId(),
        'metadata': {
            'section': 'myblog',
            'slug': '2012-03-noticed-the-news',
            'type': 'blog-entry',
            'title': 'Noticed in the News',
            'created': datetime.utcnow(),
            'author': { 'id': user_id, 'name': 'Rick' },
            'tags': [ 'news', 'musings' ],
            'detail': {
                'publish_on': datetime.utcnow(),
                'text': 'I noticed the news from Washington today…' }
            }
         })

Once the node is in the database, there is a potential problem with
multiple editors. In order to support this, the schema uses the special ``nonce``
value to detect when another editor may have modified the document and
allow the application to resolve any conflicts:

.. code-block:: python

    def update_text(section, slug, nonce, text):
        result = db.cms.nodes.update(
            { 'metadata.section': section,
              'metadata.slug': slug,
              'nonce': nonce },
            { '$set':{'metadata.detail.text': text, 'nonce': ObjectId() } },
            safe=True)
        if not result['updatedExisting']:
            raise ConflictError()

You might also want to perform metadata edits to the item such as adding
tags:

.. code-block:: python

    db.cms.nodes.update(
        { 'metadata.section': section, 'metadata.slug': slug },
        { '$addToSet': { 'tags': { '$each': [ 'interesting', 'funny' ] } } })

In this case, you don't actually need to supply the nonce (nor update it)
since you're using the atomic ``$addToSet`` modifier in MongoDB.

Index Support
~~~~~~~~~~~~~

Updates in this case are based on equality queries containing the
(``section``, ``slug``, and ``nonce``) values. To support these queries, you
*might* use the following index:

.. code-block:: python

    >>> db.cms.nodes.ensure_index([
    ...    ('metadata.section', 1), ('metadata.slug', 1), ('nonce', 1) ])

Also note, however, that you'd like to ensure that two editors don't
create two documents with the same section and slug. To support this, you need a
second index with a unique constraint:

.. code-block:: python

    >>> db.cms.nodes.ensure_index([
    ...    ('metadata.section', 1), ('metadata.slug', 1)], unique=True)

In fact, since the expectation is that most of the time (``section``, ``slug``,
``nonce``) is going to be unique, you don't actually get much benefit from the
first index and can use only the second one to satisfy the update queries as
well.

Upload a Photo
--------------

Uploading photos shares some things in common with node
update, but it also has some extra nuances:

.. code-block:: python

    def upload_new_photo(
        input_file, section, slug, title, author, tags, details):
        fs = GridFS(db, 'cms.assets')
        with fs.new_file(
            content_type='image/jpeg',
            metadata=dict(
                type='photo',
                locked=datetime.utcnow(),
                section=section,
                slug=slug,
                title=title,
                created=datetime.utcnow(),
                author=author,
                tags=tags,
                detail=detail)) as upload_file:
            while True:
                chunk = input_file.read(upload_file.chunk_size)
                if not chunk: break
                upload_file.write(chunk)
        # unlock the file
        db.assets.files.update(
            {'_id': upload_file._id},
            {'$set': { 'locked': None } } )

Here, since uploading the photo is a non-atomic operation, you need to
"lock" the file during upload by writing the current datetime into the
record. This lets the application detect when a file upload may be stalled, which
is helpful when working with multiple editors. This solution assumes that, for
photo upload, the last update wins:

.. code-block:: python

    def update_photo_content(input_file, section, slug):
        fs = GridFS(db, 'cms.assets')

        # Delete the old version if it's unlocked or was locked more than 5
        #    minutes ago
        file_obj = db.cms.assets.find_one(
            { 'metadata.section': section,
              'metadata.slug': slug,
              'metadata.locked': None })
        if file_obj is None:
            threshold = datetime.utcnow() - timedelta(seconds=300)
            file_obj = db.cms.assets.find_one(
                { 'metadata.section': section,
                  'metadata.slug': slug,
                  'metadata.locked': { '$lt': threshold } })
        if file_obj is None: raise FileDoesNotExist()
        fs.delete(file_obj['_id'])

        # update content, keep metadata unchanged
        file_obj['locked'] = datetime.utcnow()
        with fs.new_file(**file_obj):
            while True:
                chunk = input_file.read(upload_file.chunk_size)
                if not chunk: break
                upload_file.write(chunk)
        # unlock the file
        db.assets.files.update(
            {'_id': upload_file._id},
            {'$set': { 'locked': None } } )

You can, of course, perform metadata edits to the item such as adding
tags without the extra complexity:

.. code-block:: python

    db.cms.assets.files.update(
        { 'metadata.section': section, 'metadata.slug': slug },
        { '$addToSet': {
            'metadata.tags': { '$each': [ 'interesting', 'funny' ] } } })

Index Support
~~~~~~~~~~~~~

Updates here are also based on equality queries containing the
(``section``, ``slug``) values, so you can use the same types of indexes as were
used in the "regular" node case. Note in particular that you need a
unique constraint on (``section``, ``slug``) to ensure that one of the calls to
``GridFS.new_file()`` will fail if multiple editors try to create or update
the file simultaneously.

.. code-block:: python

    >>> db.cms.assets.files.ensure_index([
    ...    ('metadata.section', 1), ('metadata.slug', 1)], unique=True)

Locate and Render a Node
------------------------

You need to be able to locate a node based on its section and slug, which
have been extracted from the page definition and URL by some
other technology.

.. code-block:: python

    node = db.nodes.find_one(
        {'metadata.section': section, 'metadata.slug': slug })

Index Support
~~~~~~~~~~~~~

The same indexes defined above on (``section``, ``slug``) would
efficiently render this node.

Locate and Render a Photo
-------------------------

You want to locate an image based on its section and slug,
which have been extracted from the page definition and URL
just as with other nodes.

.. code-block:: python

    fs = GridFS(db, 'cms.assets')
    with fs.get_version(
        **{'metadata.section': section, 'metadata.slug': slug }) as img_fp:
       # do something with the image file

Index Support
~~~~~~~~~~~~~

The same indexes defined above on (``section``, ``slug``) would also
efficiently render this image.

Search for Nodes by Tag
-----------------------

You'd like to retrieve a list of nodes based on their tags:

.. code-block:: python

    nodes = db.nodes.find({'metadata.tags': tag })

Index Support
~~~~~~~~~~~~~

To support searching efficiently, you should define indexes on any fields
you intend on using in your query:

.. code-block:: python

    >>> db.cms.nodes.ensure_index('tags')

Search for Images by Tag
------------------------

Here, you'd like to retrieve a list of images based on their tags:

.. code-block:: python

    image_file_objects = db.cms.assets.files.find({'metadata.tags': tag })
    fs = GridFS(db, 'cms.assets')
    for image_file_object in db.cms.assets.files.find(
        {'metadata.tags': tag }):
        image_file = fs.get(image_file_object['_id'])
        # do something with the image file

Index Support
~~~~~~~~~~~~~

As above, in order to support searching efficiently, you should define
indexes on any fields you expect to use in the query:

.. code-block:: python

    >>> db.cms.assets.files.ensure_index('tags')

Generate a Feed of Recently Published Blog Articles
---------------------------------------------------

Here, you need to generate an .rss or .atom feed for your recently
published blog articles, sorted by date descending:

.. code-block:: python

    articles = db.nodes.find({
        'metadata.section': 'my-blog'
        'metadata.published': { '$lt': datetime.utcnow() } })
    articles = articles.sort({'metadata.published': -1})

Index Support
~~~~~~~~~~~~~

In order to support this operation, you'll need to create an index on (``section``,
``published``) so the items are 'in order' for the query. Note that in cases
where you're sorting or using range queries, as here, the field on which
you're sorting or performing a range query must be the final field in the
index:

.. code-block:: python

    >>> db.cms.nodes.ensure_index(
    ...     [ ('metadata.section', 1), ('metadata.published', -1) ])

Sharding
========

In a CMS system, read performance is generally much more important
than write performance. As such, you'll want to optimize the sharding setup
for read performance. In order to achieve the best read performance, you
need to ensure that queries are *routeable* by the mongos process. A
second consideration when sharding is that unique indexes do not span
shards. As such, the shard key must include the unique indexes in order to get
the same semantics as described above. Given
these constraints, sharding the nodes and assets on (``section``, ``slug``)
is a reasonable approach:

.. code-block:: python

    >>> db.command('shardcollection', 'cms.nodes', {
    ...     key : { 'metadata.section': 1, 'metadata.slug' : 1 } })
    { "collectionsharded" : "cms.nodes", "ok" : 1 }
    >>> db.command('shardcollection', 'cms.assets.files', {
    ...     key : { 'metadata.section': 1, 'metadata.slug' : 1 } })
    { "collectionsharded" : "cms.assets.files", "ok" : 1 }

If you wish to shard the ``cms.assets.chunks`` collection, you need to shard
on the ``_id`` field (none of the node metadata is available on the
``cms.assets.chunks`` collection in GridFS:)

.. code-block:: python

    >>> db.command('shardcollection', 'cms.assets.chunks', {
    ...     key: { '_id': 1 } })
    { "collectionsharded" : "cms.assets.chunks", "ok" : 1 }

This actually still maintains the query-routability constraint, since
all reads from GridFS must first look up the document in ``cms.assets.files`` and
then look up the chunks separately (though the GridFS API sometimes
hides this detail.)
