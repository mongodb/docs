# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2014, MongoDB, Inc.
# This file is distributed under the same license as the mongodb-manual
# package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: MongoDB Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:30-0400\n"
"PO-Revision-Date: 2014-04-08 19:27+0000\n"
"Last-Translator: tychoish <tychoish@gmail.com>\n"
"Language: es\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/mongodb-"
"manual/language/es/)\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../source/core/index-multikey.txt:7
msgid "Multikey Indexes"
msgstr ""

#: ../source/core/index-multikey.txt:17
msgid ""
"To index a field that holds an array value, MongoDB creates an index key "
"for each element in the array. These *multikey* indexes support efficient"
" queries against array fields. Multikey indexes can be constructed over "
"arrays that hold both scalar values [#scalar]_ (e.g. strings, numbers) "
"*and* nested documents."
msgstr ""

#: ../source/core/index-multikey.txt:26
msgid ""
"A scalar value refers to value that is neither an embedded document nor "
"an array."
msgstr ""

#: ../source/core/index-multikey.txt:30
msgid "Create Multikey Index"
msgstr ""

#: ../source/core/index-multikey.txt:32
msgid ""
"To create a multikey index, use the :method:`db.collection.createIndex()`"
" method:"
msgstr ""

#: ../source/core/index-multikey.txt:39
msgid ""
"MongoDB automatically creates a multikey index if any indexed field is an"
" array; you do not need to explicitly specify the multikey type."
msgstr ""

#: ../source/core/index-multikey.txt:44
msgid "*For the WiredTiger and In-Memory storage engines only*,"
msgstr ""

#: ../source/core/index-multikey.txt:46
msgid ""
"Starting in MongoDB 3.4, for multikey indexes created using MongoDB 3.4 "
"or later, MongoDB keeps track of which indexed field or fields cause an "
"index to be a multikey index. Tracking this information allows the "
"MongoDB query engine to use tighter index bounds."
msgstr ""

#: ../source/core/index-multikey.txt:52
msgid "Index Bounds"
msgstr ""

#: ../source/core/index-multikey.txt:54
msgid ""
"If an index is multikey, then computation of the index bounds follows "
"special rules. For details on multikey index bounds, see :doc:`/core"
"/multikey-index-bounds`."
msgstr ""

#: ../source/core/index-multikey.txt:59
msgid "Unique Multikey Index"
msgstr ""

#: ../source/core/index-multikey.txt:61
msgid ""
"For :doc:`unique </core/index-unique>` indexes, the unique constraint "
"applies across separate documents in the collection rather than within a "
"single document."
msgstr ""

#: ../source/core/index-multikey.txt:65
msgid ""
"Because the unique constraint applies to separate documents, for a "
":ref:`unique multikey index <unique-separate-documents>`, a document may "
"have array elements that result in repeating index key values as long as "
"the index key values for that document do not duplicate those of another "
"document."
msgstr ""

#: ../source/core/index-multikey.txt:71
msgid "For more information, see :ref:`unique-separate-documents`."
msgstr ""

#: ../source/core/index-multikey.txt:74
msgid "Limitations"
msgstr ""

#: ../source/core/index-multikey.txt:77
msgid "Compound Multikey Indexes"
msgstr ""

#: ../source/core/index-multikey.txt:79
msgid ""
"For a :ref:`compound <index-type-compound>` multikey index, each indexed "
"document can have *at most* one indexed field whose value is an array. "
"That is:"
msgstr ""

#: ../source/core/index-multikey.txt:83
msgid ""
"You cannot create a compound multikey index if more than one to-be-"
"indexed field of a document is an array. For example, consider a "
"collection that contains the following document:"
msgstr ""

#: ../source/core/index-multikey.txt:91
msgid ""
"You cannot create a compound multikey index ``{ a: 1, b: 1 }`` on the "
"collection since both the ``a`` and ``b`` fields are arrays."
msgstr ""

#: ../source/core/index-multikey.txt:94
msgid ""
"Or, if a compound multikey index already exists, you cannot insert a "
"document that would violate this restriction."
msgstr ""

#: ../source/core/index-multikey.txt:97
msgid "Consider a collection that contains the following documents:"
msgstr ""

#: ../source/core/index-multikey.txt:104
msgid ""
"A compound multikey index ``{ a: 1, b: 1 }`` is permissible since for "
"each document, only one field indexed by the compound multikey index is "
"an array; i.e. no document contains array values for both ``a`` and ``b``"
" fields."
msgstr ""

#: ../source/core/index-multikey.txt:109
msgid ""
"However, after creating the compound multikey index, if you attempt to "
"insert a document where both ``a`` and ``b`` fields are arrays, MongoDB "
"will fail the insert."
msgstr ""

#: ../source/core/index-multikey.txt:113
msgid ""
"If a field is an array of documents, you can index the embedded fields to"
" create a compound index. For example, consider a collection that "
"contains the following documents:"
msgstr ""

#: ../source/core/index-multikey.txt:122
msgid ""
"You can create a compound index on ``{ \"a.x\": 1, \"a.z\": 1 }``. The "
"restriction where *at most* one indexed field can be an array also "
"applies."
msgstr ""

#: ../source/core/index-multikey.txt:126
msgid "For an example, see :ref:`multikey-embedded-documents`."
msgstr ""

#: ../source/core/index-multikey.txt:130
msgid ":ref:`unique-separate-documents`"
msgstr ""

#: ../source/core/index-multikey.txt:132
msgid ":ref:`index-unique-index`"
msgstr ""

#: ../source/core/index-multikey.txt:135
msgid "Sorting"
msgstr ""

#: ../source/includes/fact-multikey-index-sort-limitation.rst:1
msgid ""
"As a result of changes to sorting behavior on array fields in MongoDB "
"3.6, when sorting on an array indexed with a :doc:`multikey index </core"
"/index-multikey/>` the query plan includes a blocking SORT stage. The new"
" sorting behavior may negatively impact performance."
msgstr ""

#: ../source/includes/fact-multikey-index-sort-limitation.rst:7
msgid ""
"In a blocking SORT, all input must be consumed by the sort step before it"
" can produce output. In a non-blocking, or *indexed* sort, the sort step "
"scans the index to produce results in the requested order."
msgstr ""

#: ../source/core/index-multikey.txt:140
msgid "Shard Keys"
msgstr ""

#: ../source/core/index-multikey.txt:142
msgid "You **cannot** specify a multikey index as the shard key index."
msgstr ""

#: ../source/core/index-multikey.txt:144
msgid ""
"However, if the shard key index is a :ref:`prefix <compound-index-"
"prefix>` of a compound index, the compound index is allowed to become a "
"compound *multikey* index if one of the other keys (i.e. keys that are "
"not part of the shard key) indexes an array. Compound multikey indexes "
"can have an impact on performance."
msgstr ""

#: ../source/core/index-multikey.txt:151
msgid "Hashed Indexes"
msgstr ""

#: ../source/core/index-multikey.txt:153
msgid ":doc:`Hashed </core/index-hashed>` indexes **cannot** be multikey."
msgstr ""

#: ../source/core/index-multikey.txt:156
msgid "Covered Queries"
msgstr ""

#: ../source/includes/fact-multikey-index-covered-query.rst:1
msgid ""
":ref:`Multikey indexes <index-type-multikey>` cannot cover queries over "
"array field(s)."
msgstr ""

#: ../source/core/index-multikey.txt:160
msgid ""
"However, starting in 3.6, multikey indexes can cover queries over the "
"non-array fields if the index tracks which field or fields cause the "
"index to be multikey. Multikey indexes created in MongoDB 3.4 or later on"
" storage engines other than MMAPv1 track this data."
msgstr ""

#: ../source/core/index-multikey.txt:166
msgid "Query on the Array Field as a Whole"
msgstr ""

#: ../source/core/index-multikey.txt:168
msgid ""
"When a query filter specifies an :ref:`exact match for an array as a "
"whole <array-match-exact>`, MongoDB can use the multikey index to look up"
" the first element of the query array but cannot use the multikey index "
"scan to find the whole array. Instead, after using the multikey index to "
"look up the first element of the query array, MongoDB retrieves the "
"associated documents and filters for documents whose array matches the "
"array in the query."
msgstr ""

#: ../source/core/index-multikey.txt:176
msgid ""
"For example, consider an ``inventory`` collection that contains the "
"following documents:"
msgstr ""

#: ../source/core/index-multikey.txt:187
msgid "The collection has a multikey index on the ``ratings`` field:"
msgstr ""

#: ../source/core/index-multikey.txt:193
msgid ""
"The following query looks for documents where the ``ratings`` field is "
"the array ``[ 5, 9 ]``:"
msgstr ""

#: ../source/core/index-multikey.txt:200
msgid ""
"MongoDB can use the multikey index to find documents that have ``5`` at "
"any position in the ``ratings`` array. Then, MongoDB retrieves these "
"documents and filters for documents whose ``ratings`` array equals the "
"query array ``[ 5, 9 ]``."
msgstr ""

#: ../source/core/index-multikey.txt:206
msgid "Examples"
msgstr ""

#: ../source/core/index-multikey.txt:209
msgid "Index Basic Arrays"
msgstr ""

#: ../source/core/index-multikey.txt:211
msgid "Consider a ``survey`` collection with the following document:"
msgstr ""

#: ../source/core/index-multikey.txt:217
msgid "Create an index on the field ``ratings``:"
msgstr ""

#: ../source/core/index-multikey.txt:223
msgid ""
"Since the ``ratings`` field contains an array, the index on ``ratings`` "
"is multikey. The multikey index contains the following three index keys, "
"each pointing to the same document:"
msgstr ""

#: ../source/core/index-multikey.txt:227
msgid "``2``,"
msgstr ""

#: ../source/core/index-multikey.txt:229
msgid "``5``, and"
msgstr ""

#: ../source/core/index-multikey.txt:231
msgid "``9``."
msgstr ""

#: ../source/core/index-multikey.txt:236
msgid "Index Arrays with Embedded Documents"
msgstr ""

#: ../source/core/index-multikey.txt:238
msgid ""
"You can create multikey indexes on array fields that contain nested "
"objects."
msgstr ""

#: ../source/core/index-multikey.txt:241
msgid "Consider an ``inventory`` collection with documents of the following form:"
msgstr ""

#: ../source/core/index-multikey.txt:277
msgid ""
"The following operation creates a multikey index on the ``stock.size`` "
"and ``stock.quantity`` fields:"
msgstr ""

#: ../source/core/index-multikey.txt:284
msgid ""
"The compound multikey index can support queries with predicates that "
"include both indexed fields as well as predicates that include only the "
"index prefix ``\"stock.size\"``, as in the following examples:"
msgstr ""

#: ../source/core/index-multikey.txt:293
msgid ""
"For details on how MongoDB can combine multikey index bounds, see "
":doc:`/core/multikey-index-bounds`. For more information on behavior of "
"compound indexes and prefixes, see :ref:`compound indexes and prefixes "
"<compound-index-prefix>`."
msgstr ""

#: ../source/core/index-multikey.txt:298
msgid ""
"The compound multikey index can also support sort operations, such as the"
" following examples:"
msgstr ""

#: ../source/core/index-multikey.txt:306
msgid ""
"For more information on behavior of compound indexes and sort operations,"
" see :doc:`/tutorial/sort-results-with-indexes`."
msgstr ""

#~ msgid ""
#~ "If you attempt to insert a such"
#~ " a document, MongoDB will reject the"
#~ " insertion, and produce an error that"
#~ " says ``cannot index parallel arrays``. "
#~ "MongoDB does not index parallel arrays"
#~ " because they require the index to"
#~ " include each value in the Cartesian"
#~ " product of the compound keys, which"
#~ " could quickly result in incredibly "
#~ "large and difficult to maintain indexes."
#~ msgstr ""

# c1cd78c966654ef1a073ca936284f0ae
#~ msgid ""
#~ "To index a field that holds an "
#~ "array value, MongoDB adds index items"
#~ " for each item in the array. "
#~ "These *multikey* indexes allow MongoDB "
#~ "to return documents from queries using"
#~ " the value of an array. MongoDB "
#~ "automatically determines whether to create "
#~ "a multikey index if the indexed "
#~ "field contains an array value; you "
#~ "do not need to explicitly specify "
#~ "the multikey type."
#~ msgstr ""

# 2550dc2baa334240a80c08165cf25a8d
#~ msgid "Consider the following illustration of a multikey index:"
#~ msgstr ""

# c766959fd2204d759f48ec5c1fd896aa
#~ msgid ""
#~ "Multikey indexes support all operations "
#~ "supported by other MongoDB indexes; "
#~ "however, applications may use multikey "
#~ "indexes to select documents based on "
#~ "ranges of values for the value of"
#~ " an array. Multikey indexes support "
#~ "arrays that hold both values (e.g. "
#~ "strings, numbers) *and* nested documents."
#~ msgstr ""

# be9a882da3634e93817aecfb8b266d05
#~ msgid "Interactions between Compound and Multikey Indexes"
#~ msgstr ""

# 2241568e67fe40b9a83948cc4ef4424b
#~ msgid ""
#~ "While you can create multikey "
#~ ":ref:`compound indexes <index-type-compound>`,"
#~ " at most one field in a "
#~ "compound index may hold an array. "
#~ "For example, given an index on ``{"
#~ " a: 1, b: 1 }``, the following"
#~ " documents are permissible:"
#~ msgstr ""

# 928099ffb53d4ea1b7420efa56eab514
#~ msgid ""
#~ "However, the following document is "
#~ "impermissible, and MongoDB cannot insert "
#~ "such a document into a collection "
#~ "with the ``{a: 1, b: 1 }`` "
#~ "index:"
#~ msgstr ""

# 4cf05dc09bcc47739a11d935ae2b8947
#~ msgid "The index of a shard key **cannot** be a multi-key index."
#~ msgstr ""

# 64d43f2f7eb748a2b6ba51b78bbf97bd
#~ msgid "``hashed`` indexes are not compatible with multi-key indexes."
#~ msgstr ""

# a6a4c1b14123415086ccb34792cd279e
#~ msgid ""
#~ "To compute the hash for a "
#~ "``hashed`` index, MongoDB collapses sub-"
#~ "documents and computes the hash for "
#~ "the entire value. For fields that "
#~ "hold arrays or sub-documents, you "
#~ "cannot use the index to support "
#~ "queries that introspect the sub-"
#~ "document."
#~ msgstr ""

# afbe334b71a341b6ac0ed0bffaccb3d2
#~ msgid "Given the following document:"
#~ msgstr ""

# 94ebbf97ace94502ab3e67ac27283141
#~ msgid ""
#~ "Then an index on the ``tags`` "
#~ "field, ``{ tags: 1 }``, would be"
#~ " a multikey index and would include"
#~ " these four separate entries for that"
#~ " document:"
#~ msgstr ""

# 3e805961388d451b940a133e4637da6b
#~ msgid "``\"weather\"``,"
#~ msgstr ""

# ce60597bee164b2c8dbb08ba130aa3d9
#~ msgid "``\"hot\"``,"
#~ msgstr ""

# 1316fad612584db0a844b4918d83f9eb
#~ msgid "``\"record\"``, and"
#~ msgstr ""

# 9c2be69972974b169c818a151dafdc83
#~ msgid "``\"april\"``."
#~ msgstr ""

# c26c9212a0fc4a369bbcec8e4b5da914
#~ msgid ""
#~ "Queries could use the multikey index "
#~ "to return queries for any of the"
#~ " above values."
#~ msgstr ""

# b9611f6fceeb41f8a01c0c75a06b562d
#~ msgid ""
#~ "You can create multikey indexes on "
#~ "fields in objects embedded in arrays,"
#~ " as in the following example:"
#~ msgstr ""

# 87e7116eefd443cb84b46190352258e2
#~ msgid ""
#~ "Consider a ``feedback`` collection with "
#~ "documents in the following form:"
#~ msgstr ""

# a49c45e680b840848e0f822b1863bb7d
#~ msgid ""
#~ "An index on the ``comments.text`` field"
#~ " would be a multikey index and "
#~ "would add items to the index for"
#~ " all embedded documents in the array."
#~ msgstr ""

# 2002d396e9844708844a83d5aff20c24
#~ msgid ""
#~ "With the index ``{ \"comments.text\": 1"
#~ " }`` on the ``feedback`` collection, "
#~ "consider the following query:"
#~ msgstr ""

# b053458279ce40c7a79e8c98e06124d6
#~ msgid ""
#~ "The query would select the documents "
#~ "in the collection that contain the "
#~ "following embedded document in the "
#~ "``comments`` array:"
#~ msgstr ""

# d4e92037324f43f0bcfa16ca01304b1a
#~ msgid "index"
#~ msgstr ""

# d4e92037324f43f0bcfa16ca01304b1a
#~ msgid "multikey"
#~ msgstr ""

#~ msgid ""
#~ "If you attempt to insert such a"
#~ " document, MongoDB will reject the "
#~ "insertion, and produce an error that "
#~ "says ``cannot index parallel arrays``. "
#~ "MongoDB does not index parallel arrays"
#~ " because they require the index to"
#~ " include each value in the Cartesian"
#~ " product of the compound keys, which"
#~ " could quickly result in incredibly "
#~ "large and difficult to maintain indexes."
#~ msgstr ""

